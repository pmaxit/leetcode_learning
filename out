Connected to database
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"two-sum","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"add-two-numbers","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"longest-substring-without-repeating-characters","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"median-of-two-sorted-arrays","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"longest-palindromic-substring","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"zigzag-conversion","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"reverse-integer","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"string-to-integer-atoi","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"palindrome-number","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
{
    "query": "\n    query communitySolutions($questionSlug: String!, $skip: Int!, $first: Int!, $query: String, $orderBy: TopicSortingOption, $languageTags: [String!], $topicTags: [String!]) {\n  questionSolutions(\n    filters: {questionSlug: $questionSlug, skip: $skip, first: $first, query: $query, orderBy: $orderBy, languageTags: $languageTags, topicTags: $topicTags}\n  ) {\n    hasDirectResults\n    totalNum\n    solutions {\n      id\n      title\n      commentCount\n      topLevelCommentCount\n      viewCount\n      pinned\n      isFavorite\n      solutionTags {\n        name\n        slug\n      }\n      post {\n        id\n      content\n  status\n        voteStatus\n        voteCount\n        creationDate\n        isHidden\n        author {\n          username\n          isActive\n          nameColor\n          activeBadge {\n            displayName\n            icon\n          }\n          profile {\n            userAvatar\n            reputation\n          }\n        }\n      }\n      searchMeta {\n        content\n        contentType\n        commentAuthor {\n          username\n        }\n        replyAuthor {\n          username\n        }\n        highlights\n      }\n    }\n  }\n}\n    ",
    "variables": {"query":"","languageTags":["python3"],"topicTags":[],"questionSlug":"regular-expression-matching","skip":0,"first":15,"orderBy":"most_votes"},
    "operationName":"communitySolutions"
    }
[{data: {questionSolutions: {hasDirectResults: true, totalNum: 4164, solutions: [{id: 3619262, title: âœ…3 Method's || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥, commentCount: 190, topLevelCommentCount: 149, viewCount: 968181, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: Hash Table, slug: hash-table}], post: {id: 5545248, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe Two Sum problem asks us to find two numbers in an array that sum up to a given target value. We need to return the indices of these two numbers.\n# Approach\n<!-- Describe your approach to solving the problem. -->\n1. One brute force approach is to consider every pair of elements and check if their sum equals the target. This can be done using nested loops, where the outer loop iterates from the first element to the second-to-last element, and the inner loop iterates from the next element to the last element. However, this approach has a time complexity of O(n^2).\n2. A more efficient approach is to use a hash table (unordered_map in C++). We can iterate through the array once, and for each element, check if the target minus the current element exists in the hash table. If it does, we have found a valid pair of numbers. If not, we add the current element to the hash table.\n\n**Approach using a hash table:**\n1. Create an empty hash table to store elements and their indices.\n2. Iterate through the array from left to right.\n3. For each element nums[i], calculate the complement by subtracting it from the target: complement = target - nums[i].\n4. Check if the complement exists in the hash table. If it does, we have found a solution.\n5. If the complement does not exist in the hash table, add the current element nums[i] to the hash table with its index as the value.\n6. Repeat steps 3-5 until we find a solution or reach the end of the array.\n7. If no solution is found, return an empty array or an appropriate indicator.\n\nThis approach has a time complexity of O(n) since hash table lookups take constant time on average. It allows us to solve the Two Sum problem efficiently by making just one pass through the array.\n\n# Code\n# Solution 1: (Brute Force)\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {}; // No solution found\n    }\n};\n\n```\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{}; // No solution found\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []  # No solution found\n\n```\n\n# Solution 2: (Two-pass Hash Table)\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;\n        int n = nums.size();\n\n        // Build the hash table\n        for (int i = 0; i < n; i++) {\n            numMap[nums[i]] = i;\n        }\n\n        // Find the complement\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (numMap.count(complement) && numMap[complement] != i) {\n                return {i, numMap[complement]};\n            }\n        }\n\n        return {}; // No solution found\n    }\n};\n\n```\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> numMap = new HashMap<>();\n        int n = nums.length;\n\n        // Build the hash table\n        for (int i = 0; i < n; i++) {\n            numMap.put(nums[i], i);\n        }\n\n        // Find the complement\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (numMap.containsKey(complement) && numMap.get(complement) != i) {\n                return new int[]{i, numMap.get(complement)};\n            }\n        }\n\n        return new int[]{}; // No solution found\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        numMap = {}\n        n = len(nums)\n\n        # Build the hash table\n        for i in range(n):\n            numMap[nums[i]] = i\n\n        # Find the complement\n        for i in range(n):\n            complement = target - nums[i]\n            if complement in numMap and numMap[complement] != i:\n                return [i, numMap[complement]]\n\n        return []  # No solution found\n\n```\n# Solution 3: (One-pass Hash Table)\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (numMap.count(complement)) {\n                return {numMap[complement], i};\n            }\n            numMap[nums[i]] = i;\n        }\n\n        return {}; // No solution found\n    }\n};\n\n```\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> numMap = new HashMap<>();\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (numMap.containsKey(complement)) {\n                return new int[]{numMap.get(complement), i};\n            }\n            numMap.put(nums[i], i);\n        }\n\n        return new int[]{}; // No solution found\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        numMap = {}\n        n = len(nums)\n\n        for i in range(n):\n            complement = target - nums[i]\n            if complement in numMap:\n                return [numMap[complement], i]\n            numMap[nums[i]] = i\n\n        return []  # No solution found\n\n```\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/9c6f9412-c860-47d6-9a2e-7fcf37ff3321_1686334926.180891.png)\n\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\n\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\n, status: null, voteStatus: 0, voteCount: 5295, creationDate: 1686334644, isHidden: null, author: {username: rahulvarma5297, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1690766901.png, reputation: 34032}}}, searchMeta: null}, {id: 737092, title: Sum MegaPost - Python3 Solution with a detailed explanation, commentCount: 57, topLevelCommentCount: 47, viewCount: 115116, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1357852, content: If you\'re a newbie and sometimes have a hard time understanding the logic. Don\'t worry, you\'ll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It\'d help. I\'ve compiled a bunch on `sum` problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck. \n\nIn general, `sum` problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a `target`, or 2) you need to return indices of numbers that sum up to a (or close to) a `target` value.  Note that when the problem is looking for a indices, `sort`ing the array is probably NOT a good idea. \n\n\n **[Two Sum:](https://leetcode.com/problems/two-sum/)**  \n \n This is the second type of the problems where we\'re looking for indices, so sorting is not necessary. What you\'d want to do is to go over the array, and try to find two integers that sum up to  a `target` value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you\'ve observations in a dictionary and use it once you get to the results. \n\nNote: try to be comfortable to use `enumerate` as it\'s sometime out of comfort zone for newbies. `enumerate` comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn\'t comfortable with at the start and have found them super helpful, I\'d probably say `enumerate`, `zip` and `set`. \n \nSolution: In this problem, you initialize a dictionary (`seen`). This dictionary will keep track of numbers (as `key`) and indices (as `value`). So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in array. As an example, let\'s do `nums = [2,3,1]` and `target = 3`. Let\'s say you\'re at index `i = 0` and `value = 2`, ok? you need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. Since `remaining + value = target`, you\'re done once you found it, right? So when going through the array, you calculate the `remaining` and check to see whether `remaining` is in the `seen` dictionary (line `#3`). If it is, you\'re done! you\'re current number and the remaining from `seen` would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) since it\'s going to be a `remaining` for (probably) a number you\'ll see in the future assuming that there is at least one instance of answer.  \n \n \n ```\n class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, value in enumerate(nums): #1\n            remaining = target - nums[i] #2\n            \n            if remaining in seen: #3\n                return [i, seen[remaining]]  #4\n            else:\n                seen[value] = i  #5\n```\n \n \n\n **[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**  \n\nFor this, you can do exactly as the previous. The only change I made below was to change the order of line `#4`. In the previous example, the order didn\'t matter. But, here the problem asks for asending order and since the values/indicess in `seen` has always lower indices than your current number, it should come first.  Also, note that the problem says it\'s not zero based, meaning that indices don\'t start from zero, that\'s why I added 1 to both of them. \n\n```\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        \n        seen = {}\n        for i, value in enumerate(numbers): \n            remaining = target - numbers[i] \n           \n            if remaining in seen: \n                return [seen[remaining]+1, i+1]  #4\n            else:\n                seen[value] = i  \n```\n\nAnother approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you\'d need three pointers as you\'ll see in the future examples). One pointer move from `left` and one from `right`. Let\'s say you `numbers = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, and  `right` points to 9. There are three possibilities. If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). If `temp_sum` is your target, you\'r done! You\'re return it (line `#9`). If it\'s more than your `target`, it means that `right` is poiting to a very large value (line `#5`) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line `#6`)  by adding one to the index . If the `temp_sum` is less than `target` (line `#7`), then you need to move your `left` to a little bit larger value by adding one to the index (line `#9`). This way, you try to narrow down the range in which you\'re looking at and will eventually find a couple of number that sum to `target`, then, you\'ll return this in line `#9`. In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to `target`, you can\'t simply return the first instace and you need to collect all the possibilities and return the list altogether (you\'ll see something like this in the next example). \n\n```\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        \n        for left in range(len(numbers) -1): #1\n            right = len(numbers) - 1 #2\n            while left < right: #3\n                temp_sum = numbers[left] + numbers[right] #4\n                if temp_sum > target:  #5\n                    right -= 1 #6\n                elif temp_sum < target: #7\n                    left +=1 #8\n                else:\n                    return [left+1, right+1] #9\n```\n\n\n\n\n[**3Sum**](https://leetcode.com/problems/3sum/)\n\nThis is similar to the previous example except that it\'s looking for three numbers. There are some minor differences in the problem statement. It\'s looking for all combinations (not just one) of solutions returned as a list. And second, it\'s looking for unique combination, repeatation is not allowed. \n\nHere, instead of looping (line `#1`) to `len(nums) -1`, we loop to `len(nums) -2` since we\'re looking for three numbers. Since we\'re returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, you cannot reducing `right` pointer or increasing `left` pointer easily, makes sense? \n\nSo, first you `sort` the array and define `res = []` to collect your outputs. In line `#2`, we check wether two consecutive elements are equal or not because if they are, we don\'t want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that `i > 0`. This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. If we didn\'t have `i > 0`, then we\'d skip the only correct solution and would return `[]` as our answer which is wrong (correct answer is `[[1,1,1]]`.  \n\nWe define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. For example, if `nums = [-2,-1,0,1,2]`, all the points in the case of `i=1` are looking at: `i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. There is only one change with respect to the previous example here between lines `#5` and `#10`.  If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? However, we\'re not done yet. For a fixed `i`, we still need to check and see whether there are other combinations by just changing `left` and `right` pointers. That\'s what we are doing in lines `#6, 7, 8`. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it are not the same, we move `left` one index to right (line `#6`). Similarly, if `nums[right]` and the value to left of it is not the same, we move `right` one index to left. This way for a fixed `i`, we get rid of repeative cases. For example, if `nums = [-3, 1,1, 3,5]` and `target = 3`, one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don\'t want the `left` variable to look at it simply because it\'d again return `[-3,1,5]`, right? So, we move `left` one index. Finally, if the repeating elements don\'t exists, lines `#6` to `#8` won\'t get activated. In this case we still need to move forward by adding 1 to `left` and extracting 1 from `right` (lines `#9, 10`). \n\n```\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \n        nums.sort()\n        res = []\n\n        for i in range(len(nums) -2): #1\n            if i > 0 and nums[i] == nums[i-1]: #2\n                continue\n            left = i + 1 #3\n            right = len(nums) - 1 #4\n            \n            while left < right:  \n                temp = nums[i] + nums[left] + nums[right]\n                                    \n                if temp > 0:\n                    right -= 1\n                    \n                elif temp < 0:\n                    left += 1\n                \n                else:\n                    res.append([nums[i], nums[left], nums[right]]) #5\n                    while left < right and nums[left] == nums[left + 1]: #6\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:#7\n                        right -= 1    #8\n                \n                    right -= 1 #9 \n                    left += 1 #10\n                       \n```\n\nAnother way to solve this problem is to change it into a two sum problem. Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to find two numbers `a` and `b` that are equal to `-c`, right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it\'d return indices and not numbers. Also, we need to re-arrage this problem in a way that we have `nums` and `target`. This code is not a good code and can be optimipized but you got the idea. For a better version of this, check [this](https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37). \n\n```\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n        \n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\n            if output_2sum ==[]:\n                continue\n            else:\n                for idx in output_2sum:\n                    instance = idx+[nums[i]]\n                    res.append(instance)\n        \n        output = []\n        for idx in res:\n            if idx not in output:\n                output.append(idx)\n                \n        \n        return output\n    \n    \n    def twoSum(self, nums, target):\n        seen = {}\n        res = []\n        for i, value in enumerate(nums): #1\n            remaining = target - nums[i] #2\n           \n            if remaining in seen: #3\n                res.append([value, remaining])  #4\n            else:\n                seen[value] = i  #5\n            \n        return res\n```\n\n[**4Sum**](https://leetcode.com/problems/4sum/)\n\nYou should have gotten the idea, and what you\'ve seen so far can be generalized to `nSum`. Here, I write the generic code using the same ideas as before. What I\'ll do is to break down each case to a `2Sum II` problem, and solve them recursively using the approach in `2Sum II` example above. \n\nFirst sort `nums`, then I\'m using two extra functions, `helper` and `twoSum`. The `twoSum` is similar to the `2sum II` example with some modifications. It doesn\'t return the first instance of results, it check every possible combinations and return all of them now. Basically, now it\'s more similar to the `3Sum` solution. Understanding this function shouldn\'t be difficult as it\'s very similar to `3Sum`. As for `helper` function, it first tries to check for cases that don\'t work (line `#1`). And later, if the `N` we need to sum to get to a `target` is 2 (line `#2`), then runs the `twoSum` function. For the more than two numbers, it recursively breaks them down to two sum (line `#3`). There are some cases like line `#4` that we don\'t need to proceed with the algorithm anymore and we can `break`. These cases include if multiplying the lowest number in the list by `N` is more than `target`. Since its sorted array, if this happens, we can\'t find any result. Also, if the largest array (`nums[-1]`) multiplied by `N` would be less than `target`, we can\'t find any solution. So, `break`. \n\n\nFor other cases, we run the `helper` function again with new inputs, and we keep doing it until we get to `N=2` in which we use `twoSum` function, and add the results to get the final output. \n\n```\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        results = []\n        self.helper(nums, target, 4, [], results)\n        return results\n    \n    def helper(self, nums, target, N, res, results):\n        \n        if len(nums) < N or N < 2: #1\n            return\n        if N == 2: #2\n            output_2sum = self.twoSum(nums, target)\n            if output_2sum != []:\n                for idx in output_2sum:\n                    results.append(res + idx)\n        \n        else: \n            for i in range(len(nums) -N +1): #3\n                if nums[i]*N > target or nums[-1]*N < target: #4\n                    break\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\n    \n    \n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        res = []\n        left = 0\n        right = len(nums) - 1 \n        while left < right: \n            temp_sum = nums[left] + nums[right] \n\n            if temp_sum == target:\n                res.append([nums[left], nums[right]])\n                right -= 1\n                left += 1\n                while left < right and nums[left] == nums[left - 1]:\n                    left += 1\n                while right > left and nums[right] == nums[right + 1]:\n                    right -= 1\n                                \n            elif temp_sum < target: \n                left +=1 \n            else: \n                right -= 1\n                                        \n        return res\n```\n[**Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\nI don\'t post combination sum here since it\'s basically this problem a little bit easier. \nCombination questions can be solved with `dfs` most of the time. if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \n\nRead my older post first [here](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation). This should give you a better idea of what\'s going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the `dfs` function where it doesn\'t need the `index` parameter anymore. This is taken care of by `candidates[i+1:]` in line `#3`. Note that we had `candidates` here in the previous post. \n\n```\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        """\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        """\n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    \n    def dfs(self, candidates, target, path, res):\n        if target < 0:\n            return\n        \n        if target == 0:\n            res.append(path)\n            return res\n        \n        for i in range(len(candidates)):\n            if i > 0 and candidates[i] == candidates[i-1]: #1\n                continue #2\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\n```\n\n\nThe only differences are lines `#1, 2, 3`. The difference in problem statement in this one and `combinations` problem of my previous post is >>>candidates must be used once<<< and lines `#1` and `2` are here to take care of this.  Line `#1` has two components where first `i > 0` and second `candidates[i] == candidates[i-1]`. The second component `candidates[i] == candidates[i-1]` is to take care of duplicates in the `candidates` variable as was instructed in the problem statement. Basically, if the next number in `candidates` is the same as the previous one, it means that it has already been taken care of, so `continue`. The first component takes care of cases like an input  `candidates = [1]` with `target = 1` (try to remove this component and submit your solution. You\'ll see what I mean). The rest is similar to the previous [post](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation)\n\n================================================================\nFinal note: Please let me know if you found any typo/error/ect. I\'ll try to fix them., status: null, voteStatus: 0, voteCount: 1063, creationDate: 1594796312, isHidden: null, author: {username: peyman_np, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 2520}}}, searchMeta: null}, {id: 3307600, title: Hash Table Concept-->Python3, commentCount: 39, topLevelCommentCount: 23, viewCount: 58221, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5145992, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dict={}\n        for i,n in enumerate(nums):\n            if n in dict:\n                return dict[n],i\n            else:\n                dict[target-n]=i\n    #please upvote me it would encourage me alot\n\n```, status: null, voteStatus: 0, voteCount: 294, creationDate: 1679057864, isHidden: null, author: {username: GANJINAVEEN, isActive: true, nameColor: null, activeBadge: {displayName: Binary Search I, icon: https://assets.leetcode.com/static_assets/others/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE_%E5%85%A5%E9%97%A8.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1671736128.png, reputation: 3849}}}, searchMeta: null}, {id: 3082556, title: 3 Best Solutions explained, commentCount: 17, topLevelCommentCount: 10, viewCount: 132739, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}], post: {id: 4854074, content: https://youtu.be/--qiegimDZM, status: null, voteStatus: 0, voteCount: 115, creationDate: 1674322836, isHidden: null, author: {username: James781, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1674323016.png, reputation: 122}}}, searchMeta: null}, {id: 3061014, title: (VIDEO) Step-by-Step Visualization of O(n) Solution, commentCount: 12, topLevelCommentCount: 10, viewCount: 26139, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: Hash Table, slug: hash-table}], post: {id: 4825294, content: https://youtu.be/luicuNOBTAI\n\nInstead of checking every single combination of pairs, the key realization is that for each number in the array, there is only **one** number that can be added to it to reach the target.\n\nWe combine this with a hash table, which can look up values in constant time, to keep track of array elements and its indices as we traverse it.  For each array element **x**, we calculate **target - x** and check if we\'ve encountered it in the array before.\n\nIn the worst case, the array will only have to be traversed once, resulting in an O(n) solution.\n\n# Code\n```\nclass Solution(object):\n    def twoSum(self, nums, target):\n        seen = {}\n        for i in range(len(nums)):\n            diff = target - nums[i]\n            if diff in seen:\n                return [seen[diff], i]\n            else:\n                seen[nums[i]] = i\n```, status: null, voteStatus: 0, voteCount: 94, creationDate: 1673908161, isHidden: null, author: {username: AlgoEngine, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1673908639.png, reputation: 5273}}}, searchMeta: null}, {id: 3556832, title: Two sums || 3 easy methods in Python, commentCount: 17, topLevelCommentCount: 9, viewCount: 53449, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 5463583, content: # Intuition\nMethod 1: A brute-force solution to find two numbers in the nums list that add up to the target value.\n\nMethod 2: By list concept\n\nMethod 3: By Dictionary (more efficient solution)\n# Approach\nMethod 1: \nThe code uses nested loops to iterate over each pair of numbers in the nums list. The outer loop runs from 0 to len(nums)-1, and the inner loop runs from i+1 to len(nums)-1, where i is the current index of the outer loop. Within the nested loops, constant time operations are performed, such as checking if the sum of two numbers equals the target, appending indices to the a list, and using break and continue statements.\nTherefore, the overall time complexity of the code is O(n^2) due to the nested loops.\n\nMethod 2: \nThe code uses one loop to iterate over the number and subtract from target and if that subtracted number is present in list then return the index of both number. \n(here if condition of a==i means that possibly the target is 10 and present number in list might be [5,5] but it will return the same index so we need to skip)\n\nMethod 3: \nThe dictionary will help us to find the complement of each number more efficiently. In Method 2, Change the loop variable from i to num using the enumerate() function. This allows us to directly access the numbers from the nums list instead of using indexing.\nReplaced the variable p with complement to improve code readability.\nReplaced if p in nums with if complement in num_dict. This change allows us to check if the complement exists in the num_dict dictionary, which provides a more efficient lookup compared to the in operator on a list.\nModified the return statement to return [num_dict[complement], i] instead of i, a. This returns the indices of the two numbers that add up to the target, as required.\n\n\n# Complexity\n- Time complexity:\n\nMethod 1: \nO(n^2) due to nested loops\n\nMethod 2: \nO(n^2) because the the code uses a single loop that iterates over each element in the nums list which takes O(n) and index() method is called within the loop which takes O(n) time in the worst case to call the index of element.\n\nMethod 3: \n**O(n)**  The use of the dictionary (num_dict) allows for efficient lookup of complements in constant time, improving the overall time complexity to O(n) compared to the previous methods with a time complexity of O(n^2) when using the brute force and index() method.\n\n\n- Space complexity:\nthe space complexity of the code is O(1) in all 3 methods.\n\n$$KINDLY$$ $$UPVOTE$$\n# Code\n\nMethod 1: \n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        a=[]\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if (nums[i]+nums[j]==target):\n                    a.append(i)\n                    a.append(j)\n                    break     \n        return a\n```\nMethod 2:\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        a=0\n        for i in range(len(nums)):\n            p = target-nums[i]\n            if p in nums:\n                a=nums.index(p)\n                if a==i:\n                    continue\n                break\n        return i,a\n```\nMethod 3:\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_dict = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_dict:\n                return [num_dict[complement], i]\n            num_dict[num] = i\n        return []\n```, status: null, voteStatus: 0, voteCount: 76, creationDate: 1684870617, isHidden: null, author: {username: Priyanka0505, isActive: true, nameColor: null, activeBadge: {displayName: Jun LeetCoding Challenge, icon: /static/images/badges/dcc-2023-6.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1688105034.png, reputation: 80}}}, searchMeta: null}, {id: 1525998, title: âœ…ðŸ”¥Multiples Methods <Vector & Unordered> - C++/Java/Python, commentCount: 3, topLevelCommentCount: 3, viewCount: 4928, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2647917, content: # Intuition\nThe problem requires finding two numbers in an array that add up to a given target. The intuition behind the solution is to iterate through the array while keeping track of the indices of elements using a data structure. By checking for the complement of the current element in the data structure, we can efficiently find the pair that sums up to the target.\n\n\n# Approach 01\n<!-- Describe your approach to solving the problem. -->\n1. Initialize an empty vector named ans to store the resulting indices.\n1. Use two nested loops:\n    - Outer loop variable i ranges from 0 to the second-to-last element.\n    - Inner loop variable j ranges from i+1 to the last element.\n1. For each pair of indices (i, j), calculate the sum of nums[i] and nums[j].\n1. If the sum is equal to the given target, add the pair of indices (i, j) to the ans vector.\n1. Continue the loop until all possible pairs are checked.\n1. After the loops, return the ans vector containing the indices of the elements that add up to the target.\n\n# Complexity\n- Time complexity: The time complexity of this algorithm is O(n^2), where n is the number of elements in the array.\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: The space complexity is O(1), as only a constant amount of extra space (ans vector) is used regardless of the input size.\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> ans;\n       \n        for(int i=0; i<nums.size(); i++){\n            for(int j=i+1; j<nums.size();j++){\n                if(nums[i]+nums[j]==target){\n                    ans.push_back(i);\n                    ans.push_back(j);\n                    break;\n                }  \n            }\n        }\n        return ans;\n    }\n};\n```\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] ans = new int[2];\n        \n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] + nums[j] == target) {\n                    ans[0] = i;\n                    ans[1] = j;\n                    break;\n                }\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        ans = []\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    ans.append(i)\n                    ans.append(j)\n                    break\n        \n        return ans\n```\n---\n# Approach 02\n<!-- Describe your approach to solving the problem. -->\n1. Create an empty unordered map named `numIndices` to store elements.\n2. Iterate through each element in the array.\n3. For each element, calculate its complement (i.e., `target - current element`).\n4. Check if the complement exists in the `numIndices` map using the `find()`  or `count()`function.\n5. If the complement is found:\n   - Return the pair of indices `[numIndices.get(complement), current index]`.\n6. If the complement is not found:\n   - Insert the current element and its index into the `numIndices` map (`numIndices[nums[i]] = i`).\n7. Continue this process for all elements in the array.\n8. If no solution is found:\n   - Return an empty vector `[]`.\n\n# Complexity\n- Time complexity: The time complexity is O(n) since we iterate through the array once, and the average time complexity of the find function in an unordered map is O(1).\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: The space complexity is O(n) as we may need to store all elements and their indices in the `numIndices` map. The space required is directly proportional to the size of the input array.\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        int n= nums.size();\n        \n        for(int i=0; i<n; i++){\n            if (mp.find(target-nums[i]) != mp.end()) //if(mp.count(target-nums[i]))\n                return {mp[target-nums[i]],i};\n            \n            mp[nums[i]]=i;\n        }\n        return {};\n    }\n};\n```\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer, Integer> numIndices = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n\n            if (numIndices.containsKey(complement)) {\n                result[0] = numIndices.get(complement);\n                result[1] = i;\n                break;\n            }\n\n            numIndices.put(nums[i], i);\n        }\n\n        return result;\n    }\n}\n```\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        num_indices = {}\n        \n        for i in range(len(nums)):\n            complement = target - nums[i]\n            \n            if complement in num_indices:\n                return [num_indices[complement], i]\n            \n            num_indices[nums[i]] = i\n```\n\n---\n\n### Difference between \'find()\' and \'count()\' function in map!\n\n- Since a map can only have at most one key, count will essentially stop after one element has been found. However, in view of more general containers such as multimaps and multisets, find is strictly better if you only care whether some element with this key exists, since it can really stop once the first matching element has been found.\n- In general, both count and find will use the container-specific lookup methods (tree traversal or hash table lookup), which are always fairly efficient. It\'s just that count has to continue iterating until the end of the equal-range, whereas find does not. Moreover, your code should document intent, so if you want to find something, use find.\n\n\n---\n\n> **Please upvote this solution**\n>, status: null, voteStatus: 0, voteCount: 62, creationDate: 1634467698, isHidden: null, author: {username: dhruba-datta, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1670256064.png, reputation: 2973}}}, searchMeta: null}, {id: 1549537, title: Python simple solution, commentCount: 9, topLevelCommentCount: 6, viewCount: 9766, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Enumeration, slug: enumeration}], post: {id: 2685782, content: **Python :**\n\n```\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n\tfor i, n in enumerate(nums):\n\t\tif target - n in nums and i != nums.index(target - n):\n\t\t\treturn i, nums.index(target - n)\n```\n\n**Like it ? please upvote !**, status: null, voteStatus: 0, voteCount: 58, creationDate: 1635625516, isHidden: null, author: {username: TovAm, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1646133189.png, reputation: 2830}}}, searchMeta: null}, {id: 1378197, title: ðŸ Simple || 100% faster || 5 Lines code || Well-Explained ðŸ“ŒðŸ“Œ, commentCount: 16, topLevelCommentCount: 6, viewCount: 8532, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2414672, content: ## Idea : \n* In this we can store each number in a dictionary with the index as a value.\n* By subtracting every number from target, we can check remaining part in dictionary if found then we can directly return the index of both number.\n\n\'\'\'\n\n\tclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        store = dict()\n        for i in range(len(nums)):\n            sec = target - nums[i]\n            if sec not in store:\n                store[nums[i]]=i\n            else:\n                return [store[sec],i] \n\n## Idea :\n* sort the given array into *tmp* variable.\n* now find both number whose sum comes as target.\n* Find the index of that both number in original *nums* array. (Ologn)\n\n\'\'\'\n\n\tclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        tmp = sorted(nums)\n        n, i, j = len(nums), 0, (n-1)\n        while True:\n            s = tmp[i]+tmp[j]\n            if s>target:\n                j-=1\n            elif s<target:\n                i+=1\n            else:\n                break\n        return [nums.index(tmp[i]),n-(nums[::-1].index(tmp[j]))-1]\n\nIf you have any doubt feel free to ask.\uD83E\uDD17\n##### Thank you and **upvote** if you got any help!!, status: null, voteStatus: 0, voteCount: 50, creationDate: 1627892109, isHidden: null, author: {username: abhi9Rai, isActive: true, nameColor: null, activeBadge: {displayName: Algorithm I, icon: https://assets.leetcode.com/static_assets/others/algorithm_I.png}, profile: {userAvatar: https://assets.leetcode.com/users/abhi9Rai/avatar_1629228452.png, reputation: 1098}}}, searchMeta: null}, {id: 2838362, title: 100 % âœ”ï¸ Solution using 3 Methods (Nested LOOPS, Hash Table, Two Pointers), commentCount: 8, topLevelCommentCount: 6, viewCount: 16476, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}], post: {id: 4534398, content: [https://youtu.be/--qiegimDZM](), status: null, voteStatus: 0, voteCount: 42, creationDate: 1669099776, isHidden: null, author: {username: CoderrrMan, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1669150350.png, reputation: 6225}}}, searchMeta: null}, {id: 3515235, title: Java, Python, C++, C#, JS | Easy to Understand | O(n), commentCount: 11, topLevelCommentCount: 6, viewCount: 47142, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}], post: {id: 5409493, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nTo solve this problem, we need to find a pair of numbers from the given array whose sum equals the target. One approach to solve this problem is to use a hash table. We can store each element of the array in the hash table along with its index. Then, for each element, we can check if the difference between the target and the element is already in the hash table. If it is, we have found a pair that adds up to the target.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n1 Create an empty hash map.\n2 Iterate over the array and for each element:\n1.1 Calculate the complement by subtracting the element from the target.\n1.2 Check if the complement exists in the hash map.\n1.3 If the complement exists, return the indices of the current element and the complement.\n1.4 If the complement does not exist, add the element and its index to the hash map.\n3 If no pair is found, return null or an empty result.\n\n# Complexity\n- Time complexity:O(n)\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity:O(n)\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nTime complexity: Where n is the length of the input array. We need to traverse the array once to find the pair.\nSpace complexity: Where n is the length of the input array. In the worst case, we need to store all the elements in the hash table.\n\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map < Integer, Integer > seen = new HashMap < > ();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (seen.containsKey(complement)) {\n                return new int[] {\n                    seen.get(complement), i\n                };\n            }\n            seen.put(nums[i], i);\n        }\n        return null; // No solution found\n    }\n}\n```\n```Python []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in hash_map:\n                return [hash_map[complement], i]\n            hash_map[num] = i\n        return []\n```\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for(int i=0; i<nums.size(); i++){\n            int complement = target - nums[i];\n            if(map.find(complement) != map.end()){\n                return {map[complement], i};\n            }\n            \n            map[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n```C# []\nusing System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        Dictionary<int, int> map = new Dictionary<int, int>();\n        \n        for(int i=0; i<nums.Length; i++){\n            int complement = target - nums[i];\n            if(map.ContainsKey(complement)){\n                return new int[] {map[complement], i};\n            }\n            \n            map[nums[i]] = i;\n        }\n        return new int[0];\n    }\n}\n```\n```JavaScript []\nvar twoSum = function(nums, target) {\n    const map = new Map();\n    for(let i=0; i<nums.length; i++){\n        const complement = target - nums[i];\n        if(map.has(complement))\n            return [map.get(complement), i];\n        map.set(nums[i], i);\n    }\n    return [];\n};\n```\n, status: null, voteStatus: 0, voteCount: 40, creationDate: 1683876372, isHidden: null, author: {username: chandru3493, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1649779935.png, reputation: 66}}}, searchMeta: null}, {id: 4082514, title: âœ…98.21%ðŸ”¥HashMap & Time complexityðŸ”¥1 line Code ðŸ”¥, commentCount: 6, topLevelCommentCount: 6, viewCount: 35859, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}], post: {id: 6155835, content: # Problem\n#### The problem statement describes a classic coding interview question. You are given an array of integers (nums) and an integer (target). Your task is to find two distinct numbers in the array that add up to the target. You need to return the indices of these two numbers.\n\n---\n# Solution\n\n##### 1. The twoSum function takes two arguments: nums, which is the list of integers, and target, which is the desired sum.\n\n##### 2. The solution uses a nested loop. The outer loop iterates through the elements of the nums list using enumerate. The outer loop variable i represents the index, and x represents the element at that index.\n\n##### 3.The inner loop also uses enumerate but starts from the i+1 index. This ensures that you don\'t use the same element twice (as the problem specifies). The inner loop variable j represents the index, and y represents the element at that index.\n\n##### 4.The condition if x + y == target checks whether the sum of the current elements x and y is equal to the target.\n\n##### 5.If a pair of elements is found that satisfies the condition, the next function returns a tuple (i, j) representing the indices of the two elements that add up to the target.\n---\n\n# Code\n```Python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        return next((i, j) for i, x in enumerate(nums) for j, y in enumerate(nums[i+1:], i+1) if x + y == target)\n\n```\n```python []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        return next((i, j) for i, x in enumerate(nums) for j, y in enumerate(nums[i+1:], i+1) if x + y == target)\n\n```\n```C# []\npublic class Solution\n{\n    public int[] TwoSum(int[] nums, int target)\n    {\n        for (int i = 0; i < nums.Length; i++)\n        {\n            for (int j = i + 1; j < nums.Length; j++)\n            {\n                if (nums[i] + nums[j] == target)\n                {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        throw new ArgumentException("No solution found");\n    }\n}\n\n```\n```javascript []\nvar twoSum = function(nums, target) {\n    const numToIndex = new Map(); // Create a Map to store numbers and their indices\n\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n\n        // Check if the complement exists in the Map\n        if (numToIndex.has(complement)) {\n            return [numToIndex.get(complement), i];\n        }\n\n        // Store the current number and its index in the Map\n        numToIndex.set(nums[i], i);\n    }\n\n    throw new Error("No solution found");\n};\n```\n```C []\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    int* result = (int*)malloc(2 * sizeof(int)); // Allocate memory for the result array\n    if (result == NULL) {\n        *returnSize = 0;\n        return NULL; // Return NULL if memory allocation fails\n    }\n\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                *returnSize = 2; // Set the return size to 2\n                return result; // Return the result array\n            }\n        }\n    }\n\n    *returnSize = 0; // If no solution found, set return size to 0\n    free(result); // Free the allocated memory before returning NULL\n    return NULL; // Return NULL if no solution is found\n}\n```\n```Java []\npublic class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> numToIndex = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (numToIndex.containsKey(complement)) {\n                return new int[]{numToIndex.get(complement), i};\n            }\n            numToIndex.put(nums[i], i);\n        }\n        throw new IllegalArgumentException("No solution found");\n    }\n}\n\n```\n```C++ []\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::unordered_map<int, int> numToIndex;\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (numToIndex.find(complement) != numToIndex.end()) {\n                return {numToIndex[complement], i};\n            }\n            numToIndex[nums[i]] = i;\n        }\n        throw std::invalid_argument("No solution found");\n    }\n};\n\n```\n\n, status: null, voteStatus: 0, voteCount: 37, creationDate: 1695517783, isHidden: null, author: {username: MrAke, isActive: true, nameColor: null, activeBadge: {displayName: 30 Days of Pandas, icon: https://assets.leetcode.com/static_assets/others/Pandas_icon.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1690932359.png, reputation: 5082}}}, searchMeta: null}, {id: 3743025, title: PythonðŸ”¥JavaðŸ”¥ C++ðŸ”¥Video SolutionðŸ”¥Easy to Understand, commentCount: 2, topLevelCommentCount: 2, viewCount: 8072, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Hash Table, slug: hash-table}], post: {id: 5710001, content: # Please UPVOTE \uD83D\uDC4D\n# !! BIG ANNOUNCEMENT !!\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. This is Only for first 10,000 subscribers. **DON\'T FORGET** to Subscribe\n\n**Click this link to Subscribe \uD83D\uDC49https://www.youtube.com/@techwired8/?sub_confirmation=1**\n\nLet\'s connect!\n\nDiscord \uD83D\uDC49 https://discord.gg/gJDCyeGh6X\nTwitter \uD83D\uDC49 https://twitter.com/TechWired8\n\nHappy Learning, Cheers Guys \uD83D\uDE0A\n\n# Video Solution\nhttps://youtu.be/oadssnyJA90\n\n\n# Recursion Explained (How to think recursively)\nhttps://youtu.be/KjpmuPDQWcU\n\n\n```Python []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        d = {}\n        for i, j in enumerate(nums):\n            r = target - j\n            if r in d: return [d[r], i]\n            d[j] = i\n\t\t\n\t\t# An Upvote will be encouraging\n```\n```Java []\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {-1, -1};\n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (map.find(complement) != map.end()) {\n                return { map[complement], i };\n            }\n            map[nums[i]] = i;\n        }\n        return {-1, -1}; // or return {};\n    }\n};\n```\n![image.png](https://assets.leetcode.com/users/images/49bf68b0-1327-4d05-a418-7d6f44f43739_1686744656.3821855.png)\n\n\n# Please UPVOTE \uD83D\uDC4D, status: null, voteStatus: 0, voteCount: 35, creationDate: 1688950483, isHidden: null, author: {username: mangoip, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1688872081.png, reputation: 155}}}, searchMeta: null}, {id: 2378786, title: Fast and Easy Solution || Time Complexity O(N), commentCount: 11, topLevelCommentCount: 3, viewCount: 3934, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Enumeration, slug: enumeration}], post: {id: 3907525, content: Time Complexity : O(n)\nSpace Complexity: O(n)\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n\t\t# Using hashmap\n        HM={}\n        \n        #Getting key and value from nums using enumerate\n        for i, n in enumerate(nums):\n            dif = target-n #getting the difference between target value and n\n            # Check if difference is in Hashmap or not\n            if dif in HM:\n                return [HM[dif], i] #if present return index of both values\n            HM[n] = i #if not update the hashmap\n        return\n\t\t\n\t\t\n\t\t#Upvote is appreciated., status: null, voteStatus: 0, voteCount: 35, creationDate: 1659620856, isHidden: null, author: {username: rishitamishra2211, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1686485036.png, reputation: 216}}}, searchMeta: null}, {id: 4791305, title: ðŸŒˆ 5 Methods Python | C++ | Python3  From ðŸŸ¢ easy to ðŸ”´ difficult, commentCount: 18, topLevelCommentCount: 11, viewCount: 11339, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: Hash Table, slug: hash-table}], post: {id: 7069574, content: ![Screen Shot 2024-03-14 at 11.30.19.png](https://assets.leetcode.com/users/images/99fe0b15-b318-4601-af0f-574bc98640ee_1710652249.4421208.png)\n1. **Method 1 - Efficient Hash Map Solution:** Utilizing a hash map for constant-time lookups, this method is efficient and commonly used.\n\n2. **Method 2 - Brute Force Solution:** This is often considered the simplest but less efficient approach, as it involves checking every pair of elements.\n\n3. **Method 3 - Two-Pointer Technique for Sorted Array:** This method involves sorting the array and using two pointers. While it\'s not necessarily difficult, the sorting step adds some complexity.\n\n4. **Method 4 - Using Set for Efficient Lookup:** This method introduces the use of a set for efficient lookup, making it a bit more optimized than brute force.\n\n5. **Method 5 - Another Efficient Hash Map Solution:** Similar to Method 1, it uses a hash map but may have slight differences in implementation.\n\n![i_pixian_ai.png](https://assets.leetcode.com/users/images/37180aa3-e8b8-4106-a9b7-7bfdf148e173_1709125369.0298688.png)\n# Method 1\n\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        num_indices = {}\n        \n        for i, num in enumerate(nums):\n            complement = target - num\n            \n            if complement in num_indices:\n                return [num_indices[complement], i]\n\n            num_indices[num] = i\n```\n```python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_indices = {}\n        \n        for i, num in enumerate(nums):\n            complement = target - num\n            \n            if complement in num_indices:\n                return [num_indices[complement], i]\n\n            num_indices[num] = i\n```\n```C++ []\n#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::unordered_map<int, int> num_indices;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            int num = nums[i];\n            int complement = target - num;\n\n            if (num_indices.find(complement) != num_indices.end()) {\n                return {num_indices[complement], i};\n            }\n\n            num_indices[num] = i;\n        }\n\n        return {}; \n    }\n};\n\n```\n\n# Method 2\n\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []\n\n```\n```python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []\n```\n```C++ []\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        \n        return {};\n    }\n};\n\n```\n\n# Method 3\n\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        nums_with_indices = [(num, i) for i, num in enumerate(nums)]\n        \n        nums_with_indices.sort(key=lambda x: x[0])\n\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            current_sum = nums_with_indices[left][0] + nums_with_indices[right][0]\n            if current_sum == target:\n                return [nums_with_indices[left][1], nums_with_indices[right][1]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return []\n\n    def findIndex(self, nums, target):\n        for i, num in enumerate(nums):\n            if num == target:\n                return i\n\n        return -1\n\n```\n```python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums_with_indices = [(num, i) for i, num in enumerate(nums)]\n        \n        nums_with_indices.sort(key=lambda x: x[0])\n\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            current_sum = nums_with_indices[left][0] + nums_with_indices[right][0]\n            if current_sum == target:\n                return [nums_with_indices[left][1], nums_with_indices[right][1]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return []\n\n    def findIndex(self, nums, target):\n        for i, num in enumerate(nums):\n            if num == target:\n                return i\n\n        return -1\n```\n```C++ []\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::vector<std::pair<int, int>> numsWithIndices;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            numsWithIndices.push_back(std::make_pair(nums[i], i));\n        }\n\n        std::sort(numsWithIndices.begin(), numsWithIndices.end(),\n                  [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                      return a.first < b.first;\n                  });\n\n        int left = 0, right = nums.size() - 1;\n\n        while (left < right) {\n            int currentSum = numsWithIndices[left].first + numsWithIndices[right].first;\n\n            if (currentSum == target) {\n                return {numsWithIndices[left].second, numsWithIndices[right].second};\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return {};\n    }\n\n    int findIndex(std::vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n};\n\n\n```\n\n# Method 4\n\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        num_set = set()\n\n        for num in nums:\n            complement = target - num\n            if complement in num_set:\n\n                index1 = nums.index(complement)\n                index2 = nums.index(num, index1 + 1)\n                return [index1, index2]\n            \n            num_set.add(num)\n\n        return []\n```\n```python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_set = set()\n\n        for num in nums:\n            complement = target - num\n            if complement in num_set:\n\n                index1 = nums.index(complement)\n                index2 = nums.index(num, index1 + 1)\n                return [index1, index2]\n            \n            num_set.add(num)\n\n        return []\n```\n```C++ []\n#include <vector>\n#include <unordered_set>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::unordered_set<int> numSet;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (numSet.find(complement) != numSet.end()) {\n                int index1 = i;\n                int index2;\n                for (int j = 0; j < nums.size(); ++j) {\n                    if (nums[j] == complement && j != index1) {\n                        index2 = j;\n                        break;\n                    }\n                }\n\n                return {index1, index2};\n            }\n\n            numSet.insert(nums[i]);\n        }\n\n        return {};\n    }\n};\n\n\n```\n# Method 5\n\n```python []\nclass Solution(object):\n    def twoSum(self, nums, target):\n        num_indices = {}\n\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_indices:\n\n                return [num_indices[complement], i]\n            \n            num_indices[num] = i\n\n        return []\n```\n```python3 []\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_indices = {}\n\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_indices:\n\n                return [num_indices[complement], i]\n            \n            num_indices[num] = i\n\n        return []\n```\n```C++ []\n#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::unordered_map<int, int> num_indices;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            int num = nums[i];\n            int complement = target - num;\n\n            if (num_indices.find(complement) != num_indices.end()) {\n\n                return {num_indices[complement], i};\n            }\n\n            num_indices[num] = i;\n        }\n\n        return {};\n    }\n};\n```\n![Screen Shot 2024-03-14 at 11.30.19.png](https://assets.leetcode.com/users/images/99fe0b15-b318-4601-af0f-574bc98640ee_1710652249.4421208.png)\n\n## **My solutions**\n\n\uD83D\uDFE2 - $$easy$$  \n\uD83D\uDFE1 - $$medium$$ \n\uD83D\uDD34 - $$hard$$\n\n\uD83D\uDFE1 [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/4845532/there-is-an-80-chance-of-being-in-the-interview-full-problem-explanation)\n\uD83D\uDFE1 [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/solutions/4845742/simple-explanation-with-pictures)\n\uD83D\uDFE1 [39. Combination Sum](https://leetcode.com/problems/combination-sum/solutions/4847482/beat-8292-full-explanation-with-pictures)\n\uD83D\uDFE2 [2540. Minimum Common Value](https://leetcode.com/problems/minimum-common-value/solutions/4845076/beat-9759-full-explanation-with-pictures)\n\uD83D\uDFE2 [3005. Count Elements With Maximum Frequency](https://leetcode.com/problems/count-elements-with-maximum-frequency/solutions/4839796/beat-8369-full-explanation-with-pictures)\n\uD83D\uDFE2 [3028. Ant on the Boundary](https://leetcode.com/problems/ant-on-the-boundary/solutions/4837433/full-explanation-with-pictures)\n\uD83D\uDFE2 [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/solutions/4834682/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE1 [1750. Minimum Length of String After Deleting Similar Ends](https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/solutions/4824224/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE1 [948. Bag of Tokens](https://leetcode.com/problems/bag-of-tokens/solutions/4818912/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE1 [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/4813340/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE2 [977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/solutions/4807704/square-sorter-python-python3-javascript-c)\n\uD83D\uDFE2 [2864. Maximum Odd Binary Number](https://leetcode.com/problems/maximum-odd-binary-number/solutions/4802402/visual-max-odd-binary-solver-python-python3-javascript-c)\n\uD83D\uDFE1 [1609. Even Odd Tree](https://leetcode.com/problems/even-odd-tree/solutions/4797529/even-odd-tree-validator-python-python3-javascript-c)\n\uD83D\uDFE2 [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/4795373/why-not-1-line-of-code-python-python3-c-everyone-can-understand)\n\uD83D\uDFE1 [513. Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/solutions/4792022/binary-tree-explorer-mastered-javascript-python-python3-c-10000-efficiency-seeker)\n\uD83D\uDFE2 [1. Two Sum](https://leetcode.com/problems/two-sum/solutions/4791305/5-methods-python-c-python3-from-easy-to-difficult)\n\uD83D\uDFE2 [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/solutions/4787634/surpassing-9793-memory-magician-excelling-at-9723)\n[More...](https://leetcode.com/DevOgabek/)\n\n, status: null, voteStatus: 0, voteCount: 33, creationDate: 1709058644, isHidden: null, author: {username: DevOgabek, isActive: true, nameColor: null, activeBadge: {displayName: Mar LeetCoding Challenge, icon: /static/images/badges/dcc-2024-3.png}, profile: {userAvatar: https://assets.leetcode.com/users/DevOgabek/avatar_1711458357.png, reputation: 5628}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 1664, solutions: [{id: 3675747, title: âœ…Beats 100% || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥, commentCount: 99, topLevelCommentCount: 55, viewCount: 287706, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Linked List, slug: linked-list}, {name: Math, slug: math}], post: {id: 5620761, content: # Intuition:\nThe Intuition is to iterate through two linked lists representing non-negative integers in reverse order, starting from the least significant digit. It performs digit-wise addition along with a carry value and constructs a new linked list to represent the sum. The process continues until both input lists and the carry value are exhausted. The resulting linked list represents the sum of the input numbers in the correct order.\n\n# Explanation: \n1. Create a placeholder node called `dummyHead` with a value of 0. This node will hold the resulting linked list.\n2. Initialize a pointer called `tail` and set it to `dummyHead`. This pointer will keep track of the last node in the result list.\n3. Initialize a variable called `carry` to 0. This variable will store the carry value during addition.\n4. Start a loop that continues until there are no more digits in both input lists (`l1` and `l2`) and there is no remaining carry value.\n5. Inside the loop:\n   - Check if there is a digit in the current node of `l1`. If it exists, assign its value to a variable called `digit1`. Otherwise, set `digit1` to 0.\n   - Check if there is a digit in the current node of `l2`. If it exists, assign its value to a variable called `digit2`. Otherwise, set `digit2` to 0.\n   - Add the current digits from `l1` and `l2`, along with the carry value from the previous iteration, and store the sum in a variable called `sum`.\n   - Calculate the unit digit of `sum` by taking the modulus (`%`) of `sum` by 10. This digit will be placed in a new node for the result.\n   - Update the `carry` variable by dividing `sum` by 10 and taking the integer division (`/`) part. This gives us the carry value for the next iteration.\n   - Create a new node with the calculated digit as its value.\n   - Attach the new node to the `tail` node of the result list.\n   - Move the `tail` pointer to the newly added node.\n   - Move to the next nodes in both `l1` and `l2`, if they exist. If either list is exhausted, set the corresponding pointer to `nullptr`.\n6. After the loop, obtain the actual result list by skipping the `dummyHead` node.\n7. Delete the `dummyHead` node.\n8. Return the resulting list.\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* tail = dummyHead;\n        int carry = 0;\n\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            int digit1 = (l1 != nullptr) ? l1->val : 0;\n            int digit2 = (l2 != nullptr) ? l2->val : 0;\n\n            int sum = digit1 + digit2 + carry;\n            int digit = sum % 10;\n            carry = sum / 10;\n\n            ListNode* newNode = new ListNode(digit);\n            tail->next = newNode;\n            tail = tail->next;\n\n            l1 = (l1 != nullptr) ? l1->next : nullptr;\n            l2 = (l2 != nullptr) ? l2->next : nullptr;\n        }\n\n        ListNode* result = dummyHead->next;\n        delete dummyHead;\n        return result;\n    }\n};\n```\n```Java []\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode tail = dummyHead;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            int digit1 = (l1 != null) ? l1.val : 0;\n            int digit2 = (l2 != null) ? l2.val : 0;\n\n            int sum = digit1 + digit2 + carry;\n            int digit = sum % 10;\n            carry = sum / 10;\n\n            ListNode newNode = new ListNode(digit);\n            tail.next = newNode;\n            tail = tail.next;\n\n            l1 = (l1 != null) ? l1.next : null;\n            l2 = (l2 != null) ? l2.next : null;\n        }\n\n        ListNode result = dummyHead.next;\n        dummyHead.next = null;\n        return result;\n    }\n}\n```\n```Python3 []\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummyHead = ListNode(0)\n        tail = dummyHead\n        carry = 0\n\n        while l1 is not None or l2 is not None or carry != 0:\n            digit1 = l1.val if l1 is not None else 0\n            digit2 = l2.val if l2 is not None else 0\n\n            sum = digit1 + digit2 + carry\n            digit = sum % 10\n            carry = sum // 10\n\n            newNode = ListNode(digit)\n            tail.next = newNode\n            tail = tail.next\n\n            l1 = l1.next if l1 is not None else None\n            l2 = l2.next if l2 is not None else None\n\n        result = dummyHead.next\n        dummyHead.next = None\n        return result\n```\n\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/aad37c06-5cd4-4eec-8ccc-6ceaae6e4a6d_1687514630.867168.png)\n\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\n10. **Practice them in a row for better understanding and please Upvote the post for more questions.**\n\n\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**, status: null, voteStatus: 0, voteCount: 1380, creationDate: 1687584371, isHidden: null, author: {username: rahulvarma5297, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1690766901.png, reputation: 34032}}}, searchMeta: null}, {id: 352181, title: [Python3]  Carry =sum//10, commentCount: 16, topLevelCommentCount: 11, viewCount: 20216, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 671218, content: * we need to deal with one situation here: \n```\nl1     1     3                              1     \n+      +     +                              +\nl2     1     9                              1 \n-----------------------------------------------------------------------------------\ncur    2    12(we need to put 2 here)        2+carry(carry from the previous 12)\n            12 %10 = 2\n\t\t    carry = 12//10 =1\t   \n```\nBy adding a variable called carry can deal with this situation: align the addends vertically and add the columns, starting from the left-most column. If a column\'s sum exceeds nine, the extra digit "carried" add into the next column.\n```\nl1          1                  3                       1     \n+           +                  +                       +\nl2          1                  9                       1 \n-----------------------------------------------------------------------------------\ncarry  0+1+1=3             0+3+9=12              1+1+1 = 3  \ncur     3%10=3             12%10=2               3%10 = 3\ncarry  3//10 =0             12//10=1             3//10 = 0 \n```\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        """\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        """\n        dummy = cur =ListNode(0)\n        carry = 0\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry%10)\n            cur = cur.next\n            carry //=10\n        return dummy.next\n```\n\n**Complexity Analysis**\n* Time Complexity: O(max(m,n)+1)\n\twhere m is the length of linked list l1, n is the length of linked list l2.\n\tThe algorithm needs to iterate at most O(max(m,n)+1) times. "+1" comes from the carry.\n* Space Complexity:O(max(m,n) + 1)\n\twhere m is the length of linked list l1, n is the length of linked list l2.\n\tThe algorithm needs to create a new list, and the length will be at most max(m,n)+1, status: null, voteStatus: 0, voteCount: 142, creationDate: 1565060799, isHidden: null, author: {username: zhanweiting, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/weiting-zhan/avatar_1529194985.png, reputation: 3849}}}, searchMeta: null}, {id: 1835217, title: âœ”ï¸ [Python3] DUMMY CARRY ( â€¢âŒ„â€¢ à¥‚ )âœ§, Explained, commentCount: 17, topLevelCommentCount: 10, viewCount: 12284, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 3139990, content: **UPVOTE if you like (\uD83C\uDF38\u25E0\u203F\u25E0), If you have any question, feel free to ask.**\n\nWe simply traverse lists, sum values and save result in a new list. Sum is equal to `val1` + `val2` + `carry` from the previous operation. `sum%10` gives us resulting digit for current node, and `sum//10` gives us a value to carry to the next operation.\n\nTime: **O(n)**\nSpace: **O(1)**\n\nRuntime: 72 ms, faster than **86.11%** of Python3 online submissions for Add Two Numbers.\nMemory Usage: 13.9 MB, less than **93.12%** of Python3 online submissions for Add Two Numbers.\n\n```\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        res = dummy = ListNode()\n        carry = 0\n        while l1 or l2:\n            v1, v2 = 0, 0\n            if l1: v1, l1 = l1.val, l1.next\n            if l2: v2, l2 = l2.val, l2.next\n            \n            val = carry + v1 + v2\n            res.next = ListNode(val%10)\n            res, carry = res.next, val//10\n            \n        if carry:\n            res.next = ListNode(carry)\n            \n        return dummy.next\n```\n\n**UPVOTE if you like (\uD83C\uDF38\u25E0\u203F\u25E0), If you have any question, feel free to ask.**, status: null, voteStatus: 0, voteCount: 66, creationDate: 1646873009, isHidden: null, author: {username: artod, isActive: true, nameColor: null, activeBadge: {displayName: Jan LeetCoding Challenge, icon: /static/images/badges/dcc-2022-1.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1641775737.png, reputation: 7598}}}, searchMeta: null}, {id: 3330972, title: Easy | Solution | Python |Linked List, commentCount: 6, topLevelCommentCount: 2, viewCount: 17296, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Linked List, slug: linked-list}], post: {id: 5175383, content: # Code\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        d = n = ListNode(0)\n        num1 = num2 = ""\n        while l1:\n            num1 += str(l1.val)\n            l1 = l1.next\n        while l2:\n            num2 += str(l2.val)\n            l2 = l2.next\n        res = str(int(num1[::-1]) + int(num2[::-1]))[::-1]\n        for i in res:\n            d.next = ListNode(i)\n            d = d.next\n        return n.next    \n```\nDo upvote if you like the Solution :), status: null, voteStatus: 0, voteCount: 62, creationDate: 1679549477, isHidden: null, author: {username: atharva77, isActive: true, nameColor: null, activeBadge: {displayName: Algorithm II, icon: https://assets.leetcode.com/static_assets/others/algorithm_II.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1691856692.png, reputation: 201}}}, searchMeta: null}, {id: 452442, title: Python 3: recursion, commentCount: 11, topLevelCommentCount: 8, viewCount: 6647, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Recursion, slug: recursion}], post: {id: 862000, content: ```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        _ = l1.val + l2.val\n        digit, tenth = _ % 10, _ // 10\n        answer = ListNode(digit)\n        if any((l1.next, l2.next, tenth)):\n            l1 = l1.next if l1.next else ListNode(0)\n            l2 = l2.next if l2.next else ListNode(0)\n            l1.val += tenth\n            answer.next = self.addTwoNumbers(l1, l2)    \n        return answer\n```, status: null, voteStatus: 0, voteCount: 49, creationDate: 1576427987, isHidden: null, author: {username: deleted_user, isActive: false, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 4332}}}, searchMeta: null}, {id: 2383456, title: [Fastest Solution Explained][0ms][100%] O(n)time complexity O(n)space complexity, commentCount: 3, topLevelCommentCount: 3, viewCount: 11763, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: JavaScript, slug: javascript}, {name: Swift, slug: swift}, {name: Kotlin, slug: kotlin}, {name: PHP, slug: php}], post: {id: 3913828, content: \n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\n***Take care brother, peace, love!***\n\n```\n```\n\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\n* *** Java ***\n\n```\n\nclass Solution \n{\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) \n    {\n        ListNode head= new ListNode(-1);//creating a node in order to store the sum of digit in a List format \n        ListNode temp= head;//we are using temp to add node to the new List \n        \n        int carry= 0;//we are storing the carry at every digit pair iteration \n        \n        while(l1 != null || l2 != null || carry > 0 )//our loop terminating condtition, all the numbers will be added \n        {\n            int sum= 0;//to store the sum at every digit pair iteration \n            \n            if(l1 != null)//adding list one node to the local sum\n            {\n                sum+= l1.val;//adding to the sum \n                l1= l1.next;//moving the l1 pointer to the next node\n            }\n            \n            if(l2 != null)\n            {\n                sum+= l2.val;//adding to the sum \n                l2= l2.next;//moving the l2 pointer to the next node\n            }\n            sum+= carry;//adding the sum inclusive carry\n            carry= sum / 10;//extracting the first digit \n            ListNode node= new ListNode(sum % 10);//extracting the last digit and creating the node \n            temp.next= node;//linking the node to the list \n            \n            temp= temp.next;//moving the temp \n        }\n        return head.next;//reaturning the new head of the new list \n    }\n}//Please do Upvote, it helps a lot\n\n```\n* Time Complexity :- BigO(max(N, M)) where N is length of l1 & M is length of l2\n\n* Space Complexity :- BigO(max(N,M))\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\n* *** Python ***\n\n```\n\nclass ListNode:\n\t""" Given in the problem """\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\t\t\ndef make_list_from_ListNode(l1):\n    list1 = []\n    while l1: #is not None\n        list1.append(l1.val)\n        l1 = l1.next\n    return list1\n\ndef make_ListNode_from_list(a_list):\n    head = l3 = ListNode(a_list[0])\n    for x in a_list[1:]:\n        l3.next = l3 = ListNode(x)\n    return head\n\n```\n\n```\nclass Solution:\n\tdef addTwoNumbers(self, l1, l2):\n\t\tlist1 = make_list_from_ListNode(l1)\n\t\tlist2 = make_list_from_ListNode(l2)\n\n\t\t### RIGHT PAD WITH ZEROES\n\t\tlen_list1 = len(list1)\n\t\tlen_list2 = len(list2)\n\t\tif len_list1 > len_list2:\n\t\t\tpad = len_list1 - len_list2\n\t\t\tlist2 = list2 + [0,] * pad\n\t\telif len_list2 > len_list1:\n\t\t\tpad = len_list2 - len_list1\n\t\t\tlist1 = list1 + [0,] * pad\n\n\t\t### DO THE MATH\n\t\td = 0\n\t\tthe_sum = list()\n\t\tfor x,y in zip(list1, list2):\n\t\t\td, m = divmod(x + y + d, 10)\n\t\t\tthe_sum.append(m)\n\t\tif d != 0:\n\t\t\tthe_sum.append(d)\n\t\treturn make_ListNode_from_list(the_sum)\n```\n\n```\n##head = l3 = ListNode(\'dummy\')\ntemp = ListNode(\'dummy\')\nhead = temp\nl3 = temp\n\n##l3.next = l3 = ListNode(m)\ntemp = ListNode(m)\nl3.next = temp\nl3 = temp\n\n# also equivalent\nl3.next = ListNode(m)\nl3 = l3.next\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\n* *** C++ ***\n\n\n```\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *ptr = new ListNode();     //new list;\n        ListNode *temp = ptr;\n        \n        int c = 0;\n\t\t//traversing both list till one of the list not reaches NULL\n        while (l1 != NULL ||  l2 != NULL || c)\n        {\n            int sum = 0;\n\t\t\t// if l1  is not null\n\t\t\t// add l1-> value to sum\n            if(l1 != NULL)\n            {\n                sum += l1->val;\n                l1 = l1 -> next;\n            }\n            \n\t\t\t// if l2  is not null\n\t\t\t// add l2-> value to sum\n            if(l2 != NULL)\n            {\n                sum += l2->val;\n                l2 = l2 -> next;\n            }\n            \n\t\t\t// add carry to sum\n            sum += c;\n\t\t\t// carry is updated by sum/10 because for 18 , \n\t\t\t// 18 / 10 is 1 which is the carry\n            c = sum/10;\n\t\t\t// add sum% 10 to new node as it containg the sum\n            ListNode *node = new ListNode(sum%10);\n            temp -> next = node;\n            temp = temp -> next;\n        }\n        return ptr -> next;\n    }\n};\n\n```\n* We have to Traverse Both Lists & add sum to new list.\n* Sum is equivalent to val1 + val2 + carry from previous Operation.\n* The resulting node will be sum%10.\n* Carry is updated by sum/10 for next Opeartion.\n* Time Complexity O(n).\n* Space Compelxity O(max(l1,l2)).\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\n* *** JavaScript ***\n\n\n```\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    var List = new ListNode(0);\n    var head = List;\n    var sum = 0;\n    var carry = 0;\n\n    while(l1!==null||l2!==null||sum>0){\n\n        if(l1!==null){\n            sum = sum + l1.val;\n            l1 = l1.next;\n        }\n        if(l2!==null){\n            sum = sum + l2.val;\n            l2 = l2.next;\n        }\n        if(sum>=10){\n            carry = 1;\n            sum = sum - 10;\n        }\n\n        head.next = new ListNode(sum);\n        head = head.next;\n\n        sum = carry;\n        carry = 0;\n\n    }\n\n    return List.next;\n};\n\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\n* *** Python3 ***\n\n\n```\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        res = dummy = ListNode()\n        carry = 0\n        while l1 or l2:\n            v1, v2 = 0, 0\n            if l1: v1, l1 = l1.val, l1.next\n            if l2: v2, l2 = l2.val, l2.next\n            \n            val = carry + v1 + v2\n            res.next = ListNode(val%10)\n            res, carry = res.next, val//10\n            \n        if carry:\n            res.next = ListNode(carry)\n            \n        return dummy.next\n\n```\n* We simply traverse lists, sum values and save result in a new list. \n* Sum is equal to val1 + val2 + carry from the previous operation. sum%10 gives us resulting digit for current node, and sum//10 gives us a value to carry to the next operation.\n\n* Time: O(n)\n* Space: O(1)\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\n* *** Kotlin ***\n\n\n```\n\nclass Solution {\n    fun ListNode?.value() = this?.`val` ?: 0\n\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?, carry: Int = 0): ListNode? {\n        if (l1 == null && l2 == null && carry == 0) return null\n        val s = l1.value() + l2.value() + carry\n        return ListNode(s % 10).apply { next = addTwoNumbers(l1?.next, l2?.next, s / 10) }\n    }\n}\n\n```\n\n```\nclass Solution {\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {\n        var list1 = l1\n        var list2 = l2\n        val head = ListNode(0)\n        var result: ListNode? = head\n        var carry = 0\n        while (list1 != null || list2 != null || carry > 0) {\n            val x1 = list1?.`val` ?: 0\n            val x2 = list2?.`val` ?: 0\n            val sum = (x1 + x2 + carry) % 10\n            carry = (x1 + x2 + carry) / 10\n            result?.next = ListNode(sum)\n            result = result?.next\n            if (list1 != null) list1 = list1.next\n            if (list2 != null) list2 = list2.next\n        }\n        return head.next\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\n* *** Swift ***\n\n\n```\n\nclass Solution {\n    private var dig = 0\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        if l1 == nil && l2 == nil && dig == 0 { return nil }\n        let sum = (l1?.val ?? 0) + (l2?.val ?? 0) + dig\n        dig = sum / 10\n        return .init(sum % 10, addTwoNumbers(l1?.next, l2?.next))\n    }\n}\n\n```\n\n```\nclass Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        var l1 = l1\n        var l2 = l2\n        var prev = ListNode(0)\n        var carry = 0\n        let head = prev\n        \n        while l1 != nil || l2 != nil || carry != 0 {\n            let cur = ListNode(0)\n            let sum = (l2 == nil ? 0 : l2!.val) + (l1 == nil ? 0 : l1!.val) + carry\n            cur.val = sum % 10\n            carry = sum / 10\n            prev.next = cur\n            prev = cur\n            l1 = l1 == nil ? l1: l1?.next\n            l2 = l2 == nil ? l2: l2?.next\n        }\n        \n        return head.next\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\n* *** PHP ***\n\n\n```\n\nclass Solution {\n\n    /**\n     * @param ListNode $l1\n     * @param ListNode $l2\n     * @return ListNode\n     */\n    function addTwoNumbers($l1, $l2) {\n        $fake_head = new ListNode(0);\n        $res = $fake_head;\n        $carry = 0;\n        while ($l1 != null || $l2 != null) {\n            $sum = $carry;\n            $carry = 0;\n            if ($l1 !== null) {\n                $sum += $l1->val;\n                $l1 = $l1->next;\n            }\n            if ($l2 !== null) {\n                $sum += $l2->val;\n                $l2 = $l2->next;\n            }\n            \n            if ($sum > 9) {\n                $carry += 1;\n                $sum %= 10;\n            }\n            $res->next = new ListNode($sum);\n            $res = $res->next;\n        }\n        \n        if ($carry > 0) {\n            $res->next = new ListNode($carry);\n        }\n        \n        return $fake_head->next;\n    }\n}\n\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\n* *** C ***\n\n\n```\n\n// create a result list\n    struct ListNode* result = malloc(sizeof(struct ListNode)); \n    struct ListNode* ptr = result;\n    result->val = 0;\n    result->next = NULL;\n\n    int carry = 0;\n    \n    while (l1 != NULL || l2!=NULL || carry !=0){\n        \n        int a = (l1 == NULL) ? 0 : l1->val;\n        int b = (l2 == NULL) ? 0 : l2->val;\n        ptr->val = a + b + carry;\n        carry = ptr->val / 10;\n        ptr->val = ptr->val %10;\n        \n        // the reason to check if two pointer is NULL is to ensure it will not update after it is already the Last node.\n        // try consider the case of \n        // [9,9,9,9,9,9,9]\n        // [9,9,9,9]\n        if(l1!=NULL){\n            l1 = (l1->next ==NULL)? NULL: l1->next;\n        }\n        \n        if(l2 !=NULL){\n            l2 = (l2->next !=NULL)? l2->next: NULL;\n        }\n        \n        // this is to ensure only create new node if there some calculations needed\n        if(l1 != NULL || l2!=NULL || carry !=0){\n            ptr->next = malloc(sizeof(struct ListNode));\n            ptr->next->next=NULL;\n            ptr = ptr->next;\n        }\n        \n    }\n    return result;\n}\n\n```\n\n```struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\n\n    struct ListNode * res=NULL,*start=NULL;\n    int x,y,c=0;\n    \n    if (!l1 && !l2)\n        return NULL;\n    else if (!l1)\n        return l2;\n    else if (!l2)\n        return l1;\n\n    while(l1 || l2 || c)\n    {\n        x = l1?l1->val:0;\n        y = l2?l2->val:0;\n        if (!res)\n        {\n            res = malloc(sizeof(struct ListNode));\n            start = res;\n        }\n        else\n        {\n            res->next = malloc(sizeof(struct ListNode));\n            res = res->next;\n        }\n        res->next =NULL;\n        res->val = (x+y+c)%10;\n        c = (x+y+c)/10;\n        l1=l1?l1->next:NULL;\n        l2=l2?l2->next:NULL;\n    }\n    return start;\n}\n```\n\n```\n```\n\n```\n```\n\n***"Open your eyes. Expect us." - \uD835\uDCD0\uD835\uDCF7\uD835\uDCF8\uD835\uDCF7\uD835\uDD02\uD835\uDCF6\uD835\uDCF8\uD835\uDCFE\uD835\uDCFC***\n, status: null, voteStatus: 0, voteCount: 30, creationDate: 1659710854, isHidden: null, author: {username: darian-catalin-cucer, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1680878634.png, reputation: 2245}}}, searchMeta: null}, {id: 4091359, title: 100% Beats | Java | C++ | Python | Javascript | C# | PHP, commentCount: 3, topLevelCommentCount: 1, viewCount: 5158, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}, {name: PHP, slug: php}], post: {id: 6167408, content: \n### steps\n1. Initialize a dummy node and a current node to keep track of the result linked list.\n2. Initialize carry to 0.\n3. Traverse both input linked lists simultaneously.\n4. At each step, calculate the sum of the current nodes\' values along with the carry.\n5. Calculate the carry for the next iteration as sum / 10.\n6. Create a new node with the value sum % 10 and append it to the result list.\n7. Move to the next nodes in both input lists.\n8. Repeat steps 4-7 until you have processed all digits in both input lists.\n9. If there is still a carry left after the loop, create an additional node with the carry as its value and append it to the result list.\n10. Return the next node of the dummy node, which represents the head of the result linked list.\n\n\n``` java []\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0); // Dummy node to simplify result list handling\n        ListNode current = dummy; // Current node to build the result list\n        int carry = 0; // Initialize carry to 0\n\n        while (l1 != null || l2 != null) {\n            int x = (l1 != null) ? l1.val : 0; // Get the current digit from l1 or set to 0 if null\n            int y = (l2 != null) ? l2.val : 0; // Get the current digit from l2 or set to 0 if null\n\n            int sum = x + y + carry; // Calculate the sum of digits and carry\n            carry = sum / 10; // Calculate the carry for the next iteration\n\n            // Create a new node with the value sum % 10 and append it to the result list\n            current.next = new ListNode(sum % 10);\n            current = current.next; // Move to the next node in the result list\n\n            // Move to the next nodes in both input lists if they are not null\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        // If there is still a carry left after the loop, create an additional node for it\n        if (carry > 0) {\n            current.next = new ListNode(carry);\n        }\n\n        return dummy.next; // Return the next node of the dummy node, which is the head of the result list\n    }\n}\n```\n``` C++ []\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy_head = new ListNode(0); // Dummy head to simplify the code\n        ListNode* current = dummy_head;\n        int carry = 0;\n\n        while (l1 || l2) {\n            int x = (l1) ? l1->val : 0;\n            int y = (l2) ? l2->val : 0;\n            int sum = x + y + carry;\n\n            carry = sum / 10;\n            current->next = new ListNode(sum % 10);\n            current = current->next;\n\n            if (l1) l1 = l1->next;\n            if (l2) l2 = l2->next;\n        }\n\n        if (carry > 0) {\n            current->next = new ListNode(carry);\n        }\n\n        return dummy_head->next; // Return the actual result, not the dummy head.\n\n    }\n};\n```\n``` Python []\n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode()\n    current = dummy\n    p, q = l1, l2\n    carry = 0\n    \n    while p or q:\n        x = p.val if p else 0\n        y = q.val if q else 0\n        val = carry + x + y\n        carry = val // 10\n        current.next = ListNode(val % 10)\n        current = current.next\n        \n        if p:\n            p = p.next\n        if q:\n            q = q.next\n    \n    if carry > 0:\n        current.next = ListNode(carry)\n    \n    return dummy.next\n\n```\n``` javascript []\nvar addTwoNumbers = function(l1, l2) {\n    let dummyHead = new ListNode(0); // Create a dummy node to simplify the code.\n    let current = dummyHead; // Initialize a current pointer to the dummy node.\n    let carry = 0; // Initialize a variable to store the carry value.\n\n    while (l1 || l2) {\n        const x = l1 ? l1.val : 0;\n        const y = l2 ? l2.val : 0;\n        const sum = x + y + carry;\n\n        carry = Math.floor(sum / 10); // Calculate the carry for the next iteration.\n        current.next = new ListNode(sum % 10); // Create a new node with the current digit.\n\n        current = current.next; // Move the current pointer to the next node.\n\n        if (l1) l1 = l1.next;\n        if (l2) l2 = l2.next;\n    }\n\n    // If there is a carry after processing all digits, add it as a new node.\n    if (carry > 0) {\n        current.next = new ListNode(carry);\n    }\n\n    return dummyHead.next; // Return the result, skipping the dummy node.\n}\n```\n\n``` C# []\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n       ListNode dummyHead = new ListNode();\n        ListNode current = dummyHead;\n        int carry = 0;\n\n        while (l1 != null || l2 != null)\n        {\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n\n            int sum = x + y + carry;\n            carry = sum / 10;\n\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        if (carry > 0)\n        {\n            current.next = new ListNode(carry);\n        }\n\n        return dummyHead.next;  \n    }\n}\n```\n\n``` PHP []\n\nfunction addTwoNumbers($l1, $l2) {\n    $dummy = new ListNode(0);\n    $current = $dummy;\n    $carry = 0;\n    \n    while ($l1 !== null || $l2 !== null) {\n        $x = ($l1 !== null) ? $l1->val : 0;\n        $y = ($l2 !== null) ? $l2->val : 0;\n        \n        $sum = $x + $y + $carry;\n        $carry = (int)($sum / 10);\n        \n        $current->next = new ListNode($sum % 10);\n        $current = $current->next;\n        \n        if ($l1 !== null) $l1 = $l1->next;\n        if ($l2 !== null) $l2 = $l2->next;\n    }\n    \n    if ($carry > 0) {\n        $current->next = new ListNode($carry);\n    }\n    \n    return $dummy->next;\n}\n```, status: null, voteStatus: 0, voteCount: 21, creationDate: 1695706794, isHidden: null, author: {username: Akhilesh21, isActive: true, nameColor: null, activeBadge: {displayName: Nov LeetCoding Challenge, icon: /static/images/badges/dcc-2023-11.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1699007850.png, reputation: 1139}}}, searchMeta: null}, {id: 4081105, title: Python 99.90 % beats || Easy Solution, commentCount: 6, topLevelCommentCount: 1, viewCount: 6454, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Linked List, slug: linked-list}, {name: Math, slug: math}], post: {id: 6153948, content: # Your upvote is my motivation!\n\n\n# Code\n```\n# Definition for singly-linked list.\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummyHead = ListNode(0)\n        curr = dummyHead\n        carry = 0\n        while l1 != None or l2 != None or carry != 0:\n            l1Val = l1.val if l1 else 0\n            l2Val = l2.val if l2 else 0\n            columnSum = l1Val + l2Val + carry\n            carry = columnSum // 10\n            newNode = ListNode(columnSum % 10)\n            curr.next = newNode\n            curr = newNode\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummyHead.next\n\n\n<!-- ========================================================= -->\n# Long Approach to understand\n<!-- Same Approach but diff way  -- 99.9% beats in Memory -->\n\n        newhead = ListNode(-1)\n        temphead = newhead\n        c = 0\n\n        while l1 and l2:\n            cur_digit = l1.val + l2.val + c   # 25\n\n            if cur_digit >= 10:\n                c = cur_digit // 10                 #2\n                cur_digit = cur_digit % 10      #5\n            else:\n                c = 0\n            \n            new_node = ListNode(cur_digit)\n            temphead.next = new_node\n            temphead = new_node\n        \n            l1 = l1.next\n            l2 = l2.next\n        \n        while l1:\n            cur_digit = l1.val + c\n            if cur_digit >= 10:\n                c = cur_digit // 10                 #2\n                cur_digit = cur_digit % 10      #5\n            else:\n                c = 0\n            new_node = ListNode(cur_digit)\n            temphead.next = new_node\n            temphead = new_node\n            l1 = l1.next\n        \n        while l2:\n            cur_digit = l2.val + c\n            if cur_digit >= 10:\n                c = cur_digit // 10                 #2\n                cur_digit = cur_digit % 10      #5\n            else:\n                c = 0\n            new_node = ListNode(cur_digit)\n            temphead.next = new_node\n            temphead = new_node\n            l2 = l2.next\n        \n        if c == 0:\n            return newhead.next\n        else:\n            new_node = ListNode(c)\n            temphead.next = new_node\n            return newhead.next\n\n```, status: null, voteStatus: 0, voteCount: 19, creationDate: 1695483136, isHidden: null, author: {username: vvivekyadav, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1695548140.png, reputation: 489}}}, searchMeta: null}, {id: 486839, title: Python - Simple Solution - 8 Liner, commentCount: 5, topLevelCommentCount: 2, viewCount: 5891, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 922498, content: ```\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        sumval = 0\n        root = curr = ListNode(0)\n        while l1 or l2 or sumval:\n            if l1: sumval += l1.val; l1 = l1.next\n            if l2: sumval += l2.val; l2 = l2.next\n            curr.next = curr = ListNode(sumval % 10)\n            sumval //= 10\n        return root.next\n```, status: null, voteStatus: 0, voteCount: 19, creationDate: 1579609340, isHidden: null, author: {username: mmbhatk, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 393}}}, searchMeta: null}, {id: 4942742, title: ã€Videoã€‘Simple addition algorithm - Python, JavaScript, Java and C++, commentCount: 2, topLevelCommentCount: 1, viewCount: 2424, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 7270367, content: # Intuition\nSimply calculate addition with a few points.\n\n# Solution Video\n\nhttps://youtu.be/DFDTaCGlzTY\n\n### \u2B50\uFE0F\u2B50\uFE0F Don\'t forget to subscribe to my channel! \u2B50\uFE0F\u2B50\uFE0F\n\n**\u25A0 Subscribe URL**\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\nSubscribers: 3,964\nThank you for your support!\n\n---\n\n# Approach\n\nThis question is very simple. All we have to do is just to calculate node values from `l1` and `l2`. Let\'s think about this case.\n\n```\nInput: l1 = [2,4,3], l2 = [5,6]\n```\nIn the case, output should be\n```\n[2,4,3]\n[5,6]\n-------\n[7,0,4]\n```\nWe will implement simple algorithm and create a new LinkedList.\n\nFirst of all, we create dummy node with value `0`(you can put any number instead of 0).\n\n```\n0 \u2192 None\nd\nr\n\nd is dummy pointer\nr is result pointer\n```\nWe copy dummy pointer and create result pointer. I\'ll explain why we need result pointer later.\n\nBasically, we calculate addition with values from `l1` and `l2` at the same index. Let\'s begin.\n\n```\n[2,4,3]\n[5,6]\n \u2191\n\n2 + 5 = 7\n```\nWe got 7 as a total, so we create a new node with `7` and then connect it with `node 0`.\n```\n0 \u2192 7 \u2192 None\nr   d\n\n```\nWe move dummy pointer to the next node(= `7`) so that we can connect the next new node easily after `7`.\n\nLet\'s calculate addition with the next values.\n```\n[2,4,3]\n[5,6]\n   \u2191\n\n4 + 6 = 10\n```\nWe got `10`. In that case, we want to put `0` for current digit. How can we put `0`?\n\n---\n\n\u2B50\uFE0F Points\n\nSimply, we use remainder divided by `10`.\n\n```\ntotal % 10\n```\nFor example,\n```\n10 % 10 = 0\n15 % 10 = 5\n7 % 10 = 7\n```\nYou can use it when total is one digit. For example, previous digit 2 + 5 = 7\n\n---\n\nWe have one more important thing. We have carry for a next digit, because total of current digit is `10`. How can we calculate the carry?\n\n---\n\n\u2B50\uFE0F Points\n\nJust divide total by `10`, but this time we use `//` in Python.\n```\ntotal // 10\n```\nFor example,\n```\n8 // 10 = 0\n18 // 10 = 1\n```\nNow, we can get `0` for the current digit and carry `1` for the next digit, so we create a new node with `0` and then connect it with `node 7` and move dummy pointer to `node 0`\n```\n0 \u2192 7 \u2192 0 \u2192 None\nr       d\n\ncarry = 1\n```\nNext\n```\n[2,4,3]\n[5,6]\n     \u2191\n\n3 + 0 + 1 = 4\n\n0 comes after 6 in the second list\n1 is carry\n```\nNow, we can get `4` for the current digit and carry `0` for the next digit, so we create a new node with `4` and then connect it with `node 0` and move dummy pointer to `node 4`\n```\n0 \u2192 7 \u2192 0 \u2192 4 \u2192 None\nr           d\n\ncarry = 0\n```\nWe finish iteration. Problem here is that dummy pointer is at `node 4` but we want to return `7 \u2192 0 \u2192 4`, how can we return the whole new list?\n\n---\n\n\u2B50\uFE0F Points\n\nLuckily, we have result pointer that is pointing to the first `node 0`. That is a reason why we copy dummy pointer and create result pointer at first.\n\n---\n\nWe should return `r.next`(= `node 7`).\n```\nreturn 7 \u2192 0 \u2192 4\n```\n\nLet me add one more explanation. This is about conditions to continue calculating addition. To understand it, let\'s add `7` to the second list after `6`.\n\n```\n 0,0,1,1 (= carry)\n[2,4,3]\n[5,6,7]\n--------\n[7,0,1,1]\n```\nIn this case, `1 + 3 + 7` creates carry, so we should add `node 1` at last. From this example, we have 3 conditions to continue calculating.\n\n---\n\n\u2B50\uFE0F Points\n\nIf list 1 has a value or list 2 has a value or we have a carry, then we continue calculating addtion.\n\nIn the solution code, I use `while` instead of `if`. \n\n---\n\nEasy\uD83D\uDE04!\nLet\'s see solution codes and step by step algorithm!\n\n---\n\n\u2B50\uFE0F I recently created a video on how I\'ve been using LeetCode to learn.\n\nhttps://youtu.be/bU_dXCOWHls\n\n---\n\n# Solution Codes\n\n```python []\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \n        dummy = ListNode()\n        res = dummy\n\n        total = carry = 0\n\n        while l1 or l2 or carry:\n            total = carry\n\n            if l1:\n                total += l1.val\n                l1 = l1.next\n            if l2:\n                total += l2.val\n                l2 = l2.next\n            \n            num = total % 10\n            carry = total // 10\n            dummy.next = ListNode(num)\n            dummy = dummy.next\n        \n        return res.next\n```\n```javascript []\nvar addTwoNumbers = function(l1, l2) {\n    let dummy = new ListNode();\n    let res = dummy;\n    let total = 0, carry = 0;\n\n    while (l1 || l2 || carry) {\n        total = carry;\n\n        if (l1) {\n            total += l1.val;\n            l1 = l1.next;\n        }\n        if (l2) {\n            total += l2.val;\n            l2 = l2.next;\n        }\n\n        let num = total % 10;\n        carry = Math.floor(total / 10);\n        dummy.next = new ListNode(num);\n        dummy = dummy.next;\n    }\n\n    return res.next;    \n};\n```\n```java []\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode res = dummy;\n        int total = 0, carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            total = carry;\n\n            if (l1 != null) {\n                total += l1.val;\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                total += l2.val;\n                l2 = l2.next;\n            }\n\n            int num = total % 10;\n            carry = total / 10;\n            dummy.next = new ListNode(num);\n            dummy = dummy.next;\n        }\n\n        return res.next;        \n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        ListNode* res = dummy;\n        int total = 0, carry = 0;\n\n        while (l1 || l2 || carry) {\n            total = carry;\n\n            if (l1) {\n                total += l1->val;\n                l1 = l1->next;\n            }\n            if (l2) {\n                total += l2->val;\n                l2 = l2->next;\n            }\n\n            int num = total % 10;\n            carry = total / 10;\n            dummy->next = new ListNode(num);\n            dummy = dummy->next;\n        }\n\n        return res->next;        \n    }\n};\n```\n\n## Step by step algorithm\n\n1. **Initialization**: Initialize a dummy node and a result pointer to the dummy node. Also, set `total` and `carry` variables to 0.\n\n    ```python\n    dummy = ListNode()\n    res = dummy\n    total = carry = 0\n    ```\n\n2. **Traversing Lists**: Traverse through both linked lists (`l1` and `l2`) until either of them or the carry has a value.\n\n    ```python\n    while l1 or l2 or carry:\n    ```\n\n3. **Calculating Sum**: At each iteration, calculate the total sum of corresponding digits from `l1`, `l2`, and the carry.\n\n    ```python\n    total = carry\n    if l1:\n        total += l1.val\n        l1 = l1.next\n    if l2:\n        total += l2.val\n        l2 = l2.next\n    ```\n\n4. **Extracting Digit and Carry**: Extract the digit by taking the modulo 10 of the total sum and update the carry for the next iteration by dividing the total sum by 10.\n\n    ```python\n    num = total % 10\n    carry = total // 10\n    ```\n\n5. **Creating New Node**: Create a new ListNode with the extracted digit and attach it to the result linked list.\n\n    ```python\n    dummy.next = ListNode(num)\n    dummy = dummy.next\n    ```\n\n6. **Return Result**: Finally, return the next node of the dummy node, which contains the head of the resultant linked list.\n\n    ```python\n    return res.next\n    ```\n\nThis algorithm effectively adds two numbers represented as linked lists, considering carryovers at each step.\n\n# Complexity\n- Time complexity: $$O(n)$$\n`n` is number of nodes in longer list `l1` or `l2`.\n\n- Space complexity:$$O(n)$$ or $$O(1)$$\nIf we count new list we create, that is $$O(n)$$. If we don\'t count, that is $$O(1)$$\n\n---\n\nThank you for reading my post. Please upvote it and don\'t forget to subscribe to my channel!\n\n\u2B50\uFE0F Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\n\u2B50\uFE0F Twitter\nhttps://twitter.com/CodingNinjaAZ\n\n\u2B50\uFE0F The next question #3 - Longest Substring Without Repeating Characters\n\npost\nhttps://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/4840693/video-3-ways-to-solve-this-question-sliding-window-set-hashing-and-the-last-position/\n\nvideo\nhttps://youtu.be/n4zCTMh03_M\n\n, status: null, voteStatus: 0, voteCount: 17, creationDate: 1711724542, isHidden: null, author: {username: niits, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1698738357.png, reputation: 7282}}}, searchMeta: null}, {id: 1013288, title: [Python 3] Solution Explained (video + code), commentCount: 2, topLevelCommentCount: 1, viewCount: 2380, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1833516, content: \n```\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummyHead = ListNode(0)\n        carry = 0\n        curr = dummyHead\n        \n        while l1 or l2:\n            if l1:\n                l1_val = l1.val\n            else:\n                l1_val = 0\n            if l2:\n                l2_val = l2.val\n            else:\n                l2_val = 0\n            \n            sum_ = l1_val + l2_val + carry\n            \n            curr.next = ListNode(sum_ % 10)\n            curr = curr.next\n            carry = sum_ // 10\n            \n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        if carry:\n            curr.next = ListNode(carry)\n        \n        return dummyHead.next\n```, status: null, voteStatus: 0, voteCount: 15, creationDate: 1610464189, isHidden: null, author: {username: spec_he123, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/spec_he123/avatar_1596031486.png, reputation: 742}}}, searchMeta: null}, {id: 2024907, title: Simple Python3 Solutionâœ¨, commentCount: 1, topLevelCommentCount: 1, viewCount: 2060, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Linked List, slug: linked-list}], post: {id: 3412965, content: ```\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n        \n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n            \n            # new digit val\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)  # as in one place we have to put a single digit\n            \n            # update pointers\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            \n        return dummy.next\n        \n# Time: O(n + m)\n# Space: O(n + m)\n```, status: null, voteStatus: 0, voteCount: 12, creationDate: 1652166203, isHidden: null, author: {username: SamirPaulb, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1703107702.png, reputation: 532}}}, searchMeta: null}, {id: 1353295, title: [Python] Runtime 60ms, commentCount: 4, topLevelCommentCount: 3, viewCount: 1576, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2375794, content: ```\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        start = curr = ListNode(0)\n        carry = 0\n        while(l1 or l2 or carry):\n            x = l1.val if l1 else 0\n            y = l2.val if l2 else 0\n            \n            carry, val = divmod(x + y + carry, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n            \n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        return start.next\n```, status: null, voteStatus: 0, voteCount: 12, creationDate: 1626886705, isHidden: null, author: {username: yadvendra, isActive: true, nameColor: null, activeBadge: {displayName: Jun LeetCoding Challenge, icon: /static/images/badges/dcc-2023-6.png}, profile: {userAvatar: https://assets.leetcode.com/users/yadvendra/avatar_1626146482.png, reputation: 36}}}, searchMeta: null}, {id: 4260249, title: âœ…Mastering Adding Two Number ðŸ’¡ Beginner's Guide, commentCount: 1, topLevelCommentCount: 1, viewCount: 1900, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}, {name: Ruby, slug: ruby}, {name: Linked List, slug: linked-list}, {name: Math, slug: math}, {name: Recursion, slug: recursion}], post: {id: 6389650, content: # Adding Two Numbers - LeetCode Problem #2\n---\n---\n\n## \uD83D\uDCA1Approach 1: Recursive Approach\n---\n\n### \u2728Explanation\nIn this approach, we recursively traverse both linked lists `l1` and `l2`, adding their corresponding nodes and handling carry if necessary. We create a new linked list `p` to store the sum.\n\n### \uD83D\uDCDDDry Run\nLet\'s dry run this approach with an example:\n- `l1` = 2 -> 4 -> 3\n- `l2` = 5 -> 6 -> 4\nAdding the numbers:\n- First, we add 2 and 5, resulting in 7.\n- Then, we add 4 and 6, resulting in 10 (with a carry of 1).\n- Finally, we add 3 and 4 with the carry, resulting in 8 (with no carry).\n\nThe resulting linked list `p` will be 7 -> 0 -> 8.\n\n### \uD83D\uDD0DEdge Cases\nThis approach handles cases where the linked lists have different lengths or carry values.\n\n### \uD83D\uDD78\uFE0FComplexity Analysis\n- Time Complexity: O(max(N, M)), where N and M are the lengths of `l1` and `l2`.\n- Space Complexity: O(max(N, M)), as the result linked list can be at most one element longer than the longer of the two input lists.\n\n### \uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDCBBCodes\n\n```cpp []\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        if (!l1 && !l2) return NULL;\n        else if (!l1) return l2;\n        else if (!l2) return l1;\n\n        int a = l1->val + l2->val;\n        ListNode* p = new ListNode(a % 10);\n        p->next = addTwoNumbers(l1->next, l2->next);\n        if (a >= 10) p->next = addTwoNumbers(p->next, new ListNode(1));\n        return p;\n    }\n};\n```\n\n```java []\npublic class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if (l1 == null && l2 == null) return null;\n        else if (l1 == null) return l2;\n        else if (l2 == null) return l1;\n\n        int a = l1.val + l2.val;\n        ListNode p = new ListNode(a % 10);\n        p.next = addTwoNumbers(l1.next, l2.next);\n        if (a >= 10) p.next = addTwoNumbers(p.next, new ListNode(1));\n        return p;\n    }\n}\n```\n\n```python []\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        if not l1 and not l2:\n            return None\n        elif not l1:\n            return l2\n        elif not l2:\n            return l1\n\n        a = l1.val + l2.val\n        p = ListNode(a % 10)\n        p.next = self.addTwoNumbers(l1.next, l2.next)\n        if a >= 10:\n            p.next = self.addTwoNumbers(p.next, ListNode(1))\n        return p\n```\n\n```csharp []\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        if (l1 == null && l2 == null) return null;\n        else if (l1 == null) return l2;\n        else if (l2 == null) return l1;\n\n        int a = l1.val + l2.val;\n        ListNode p = new ListNode(a % 10);\n        p.next = AddTwoNumbers(l1.next, l2.next);\n        if (a >= 10) p.next = AddTwoNumbers(p.next, new ListNode(1));\n        return p;\n    }\n}\n```\n\n```javascript []\nvar addTwoNumbers = function(l1, l2) {\n    if (!l1 && !l2) return null;\n    else if (!l1) return l2;\n    else if (!l2) return l1;\n\n    var a = l1.val + l2.val;\n    var p = new ListNode(a % 10);\n    p.next = addTwoNumbers(l1.next, l2.next);\n    if (a >= 10) p.next = addTwoNumbers(p.next, new ListNode(1));\n    return p;\n};\n```\n\n---\n## \uD83D\uDCCA Analysis\n![image.png](https://assets.leetcode.com/users/images/2ba3ca9d-dcbb-4a59-b042-98e8dba381ef_1699356651.288471.png)\n\n\n---\n# \uD83D\uDCA1Approach 2: Using Dummy Node and Iteration\n---\n## \u2728Explanation\n\nThe problem statement requires us to add two numbers represented by two linked lists, where each node contains a single digit. We need to return the sum as a new linked list.\n\nThe third approach involves using a dummy node to simplify the code. It also uses an iterative process to construct the result linked list.\n\nHere are the steps for this approach:\n\n1. Create a dummy node `dummy_head` to hold the result. Initialize it with a value of 0.\n\n2. Initialize two pointers, `p` and `q`, both pointing to `dummy_head`. These pointers will be used to construct the result linked list.\n\n3. Initialize a carry variable `carry` to 0. This will store the carry generated during addition.\n\n4. Loop through the input linked lists `l1` and `l2` until both are empty.\n\n5. Within the loop, add the values of the current nodes in `l1` and `l2`, along with the carry. Calculate the sum as `(l1->val + l2->val + carry)`. Also, update the carry as `(l1->val + l2->val + carry) / 10`.\n\n6. Create a new node with the value `(l1->val + l2->val + carry) % 10`, and set this value as the next node of `p`.\n\n7. Update `p` to point to the newly created node.\n\n8. Move the pointers `l1` and `l2` to their next nodes.\n\n9. After the loop, check if there is any remaining carry. If so, create a new node with the carry and attach it to the result.\n\n10. Finally, return `dummy_head->next`, which is the actual result.\n\n## \uD83D\uDCDDDry Run\n\nLet\'s dry run this approach with an example:\n\n- Input:\n  - `l1`: 2 -> 4 -> 3\n  - `l2`: 5 -> 6 -> 4\n\n- Initialize `dummy_head` with value 0.\n\n- Initialize pointers:\n  - `p` is at `dummy_head`\n  - `q` is at `dummy_head`\n  - `l1` points to 2\n  - `l2` points to 5\n\n- Begin the loop:\n  - Calculate the sum with carry: `(2 + 5) % 10 = 7`.\n  - Set `p->next` to a new node with the value 7.\n  - Update `carry` to `(2 + 5) / 10 = 0`.\n  - Move `p` to the new node (7).\n  - Move `q` to the new node (7).\n  - Move `l1` to 4 and `l2` to 6.\n\n- Continue the loop:\n  - Calculate the sum with carry: `(4 + 6) % 10 = 0`.\n  - Set `p->next` to a new node with the value 0.\n  - Update `carry` to `(4 + 6) / 10 = 1`.\n  - Move `p` to the new node (0).\n  - Move `q` to the new node (0).\n  - Move `l1` to 3 and `l2` to 4.\n\n- Continue the loop:\n  - Calculate the sum with carry: `(3 + 4 + 1) % 10 = 8`.\n  - Set `p->next` to a new node with the value 8.\n  - Update `carry` to `(3 + 4 + 1) / 10 = 0`.\n  - Move `p` to the new node (8).\n  - Move `q` to the new node (8).\n  - Move `l1` to null and `l2` to null.\n\n- Loop ends, but there\'s no remaining carry.\n\n- Return `dummy_head->next`, which is the actual result: 7 -> 0 -> 8.\n\n## \uD83D\uDD0DEdge Cases\n\nThis approach efficiently handles cases where the linked lists have different lengths or carry values. It ensures that the result is correct and accurately represents the sum of the numbers.\n\n## \uD83D\uDD78\uFE0FComplexity Analysis\n\n- Time Complexity: O(max(N, M)), where N and M are the lengths of `l1` and `l2`. The algorithm iterates through both linked lists once.\n- Space Complexity: O(max(N, M)), as we only use a few extra variables, such as `dummy_head`, `p`, `q`, and `carry`, to construct the result linked list.\n\n## \uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDCBBCodes\n\n\n```cpp []\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode* dummy_head = new ListNode(0);\n    ListNode* p = dummy_head;\n    ListNode* q = dummy_head;\n    int carry = 0;\n    \n    while (l1 || l2) {\n        int x = l1 ? l1->val : 0;\n        int y = l2 ? l2->val : 0;\n        \n        int _sum = x + y + carry;\n        carry = _sum / 10;\n        \n        p->next = new ListNode(_sum % 10);\n        p = p->next;\n        \n        if (l1) l1 = l1->next;\n        if (l2) l2 = l2->next;\n    }\n    \n    if (carry > 0) {\n        p->next = new ListNode(carry);\n    }\n    \n    ListNode* result = dummy_head->next;\n    delete dummy_head;\n    \n    return result;\n}\n};\n```\n\n```python []\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        p = dummy_head\n        q = dummy_head\n        carry = 0\n\n        while l1 or l2:\n            x = l1.val if l1 else 0\n            y = l2.val if l2 else 0\n\n            _sum = x + y + carry\n            carry = _sum // 10\n\n            p.next = ListNode(_sum % 10)\n            p = p.next\n\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n\n        if carry > 0:\n            p.next = ListNode(carry)\n\n        result = dummy_head.next\n        return result\n\n```\n\n```java []\npublic class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy_head = new ListNode(0);\n        ListNode p = dummy_head;\n        ListNode q = dummy_head;\n        int carry = 0;\n\n        while (l1 != null || l2 != null) {\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n\n            int _sum = x + y + carry;\n            carry = _sum / 10;\n\n            p.next = new ListNode(_sum % 10);\n            p = p.next;\n\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        if (carry > 0) {\n            p.next = new ListNode(carry);\n        }\n\n        ListNode result = dummy_head.next;\n        return result;\n    }\n}\n```\n\n```csharp []\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy_head = new ListNode(0);\n        ListNode p = dummy_head;\n        ListNode q = dummy_head;\n        int carry = 0;\n\n        while (l1 != null || l2 != null) {\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n\n            int _sum = x + y + carry;\n            carry = _sum / 10;\n\n            p.next = new ListNode(_sum % 10);\n            p = p.next;\n\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        if (carry > 0) {\n            p.next = new ListNode(carry);\n        }\n\n        ListNode result = dummy_head.next;\n        return result;\n    }\n}\n```\n\n```javascript []\n\nvar addTwoNumbers = function (l1, l2) {\n    let dummy_head = new ListNode(0);\n    let p = dummy_head;\n    let q = dummy_head;\n    let carry = 0;\n\n    while (l1 || l2) {\n        const x = l1 ? l1.val : 0;\n        const y = l2 ? l2.val : 0;\n\n        const _sum = x + y + carry;\n        carry = Math.floor(_sum / 10);\n\n        p.next = new ListNode(_sum % 10);\n        p = p.next;\n\n        if (l1) l1 = l1.next;\n        if (l2) l2 = l2.next;\n    }\n\n    if (carry > 0) {\n        p.next = new ListNode(carry);\n    }\n\n    const result = dummy_head.next;\n    return result;\n}\n\n```\n\n```ruby []\n\ndef add_two_numbers(l1, l2)\n    dummy_head = ListNode.new(0)\n    p = dummy_head\n    q = dummy_head\n    carry = 0\n\n    while l1 || l2\n        x = l1 ? l1.val : 0\n        y = l2 ? l2.val : 0\n\n        _sum = x + y + carry\n        carry = _sum / 10\n\n        p.next = ListNode.new(_sum % 10)\n        p = p.next\n\n        if l1\n            l1 = l1.next\n        end\n\n        if l2\n            l2 = l2.next\n        end\n    end\n\n    if carry > 0\n        p.next = ListNode.new(carry)\n    end\n\n    result = dummy_head.next\n    return result\nend\n```\n---\n## \uD83D\uDCCA Analysis\n| Language | Runtime | Memory |\n|----------|---------|--------|\n| C++      | 24 ms   | 71.5 MB |\n| Java     | 2 ms    | 39.8 MB |\n| Python   | 68 ms   | 14.3 MB |\n| C#       | 116 ms  | 26.3 MB |\n| JavaScript | 108 ms | 46.7 MB |\n\n---\n\n---\n\n# Consider UPVOTING\u2B06\uFE0F\n\n![image.png](https://assets.leetcode.com/users/images/853344be-bb84-422b-bdec-6ad5f07d0a7f_1696956449.7358863.png)\n\n\n# DROP YOUR SUGGESTIONS IN THE COMMENT\n\n## Keep Coding\uD83E\uDDD1\u200D\uD83D\uDCBB\n\n -- *MR.ROBOT SIGNING OFF*\n\n, status: null, voteStatus: 0, voteCount: 10, creationDate: 1699356681, isHidden: null, author: {username: LakshayBrejwal_1_0, isActive: true, nameColor: null, activeBadge: {displayName: Apr LeetCoding Challenge, icon: /static/images/badges/dcc-2022-4.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1693891977.png, reputation: 347}}}, searchMeta: null}, {id: 1784472, title: Python 3 -> Simple solution that was asked in real interview, commentCount: 0, topLevelCommentCount: 0, viewCount: 1092, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Iterator, slug: iterator}], post: {id: 3062607, content: **Suggestions to make it better are always welcomed.**\n\nDon\'t take this question lightly. This was one of the questions when I was interviewing actively.\n\nMy code at that time was optimal but very long compared to what I have now.\nDuring my interview, my solution had 3 while loops:\n1. while l1 and l2\n2. while l1\n3. while l2\n\nBut, in below solution, there\'s only 1 while loop:\n1. while l1 or l2\n\nHaving **and** vs **or** operator can make your code short or long. So, think thoroughly. Yes, we can make below code couple of lines shorter if I change the while loop as below:\n1. while l1 or l2 or carryOver\n\n```\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        carryOver = 0\n        result = ListNode(-1)\n        resultTail = result\n        \n        while l1 or l2:\n            total = 0\n            if l1: \n                total += l1.val\n                l1 = l1.next\n            if l2: \n                total += l2.val\n                l2 = l2.next\n            \n            total += carryOver\n            carryOver, remainder = divmod(total, 10)\n            resultTail.next = ListNode(remainder)\n            resultTail = resultTail.next\n            \n        if carryOver > 0:\n            resultTail.next = ListNode(carryOver)\n            \n        return result.next\n```\n\n**I hope that you\'ve found this useful.\nIn that case, please upvote. It only motivates me to write more such posts\uD83D\uDE03**, status: null, voteStatus: 0, voteCount: 10, creationDate: 1645317105, isHidden: null, author: {username: mybuddy29, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 3015}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 1997, solutions: [{id: 3649636, title: âœ…3 Method's || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥, commentCount: 61, topLevelCommentCount: 35, viewCount: 257760, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Hash Table, slug: hash-table}, {name: String, slug: string}], post: {id: 5586489, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe intuition behind the 3 solutions is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (`left` and `right`) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.\n\n# Approach 1 - Set\n<!-- Describe your approach to solving the problem. -->\n\n1. We use a set (`charSet`) to keep track of unique characters in the current substring.\n2. We maintain two pointers, `left` and `right`, to represent the boundaries of the current substring.\n3. The `maxLength` variable keeps track of the length of the longest substring encountered so far.\n4. We iterate through the string using the `right` pointer.\n5. If the current character is not in the set (`charSet`), it means we have a new unique character.\n6. We insert the character into the set and update the `maxLength` if necessary.\n7. If the character is already present in the set, it indicates a repeating character within the current substring.\n8. In this case, we move the `left` pointer forward, removing characters from the set until the repeating character is no longer present.\n9. We insert the current character into the set and continue the iteration.\n10. Finally, we return the `maxLength` as the length of the longest substring without repeating characters.\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_set<char> charSet;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charSet.count(s[right]) == 0) {\n                charSet.insert(s[right]);\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                while (charSet.count(s[right])) {\n                    charSet.erase(s[left]);\n                    left++;\n                }\n                charSet.insert(s[right]);\n            }\n        }\n        \n        return maxLength;\n    }\n};\n```\n```Java []\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int maxLength = 0;\n        Set<Character> charSet = new HashSet<>();\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (!charSet.contains(s.charAt(right))) {\n                charSet.add(s.charAt(right));\n                maxLength = Math.max(maxLength, right - left + 1);\n            } else {\n                while (charSet.contains(s.charAt(right))) {\n                    charSet.remove(s.charAt(left));\n                    left++;\n                }\n                charSet.add(s.charAt(right));\n            }\n        }\n        \n        return maxLength;\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        maxLength = 0\n        charSet = set()\n        left = 0\n        \n        for right in range(n):\n            if s[right] not in charSet:\n                charSet.add(s[right])\n                maxLength = max(maxLength, right - left + 1)\n            else:\n                while s[right] in charSet:\n                    charSet.remove(s[left])\n                    left += 1\n                charSet.add(s[right])\n        \n        return maxLength\n\n```\n\n# Approach 2 - Unordered Map\n1. We improve upon the first solution by using an unordered map (`charMap`) instead of a set.\n2. The map stores characters as keys and their indices as values.\n3. We still maintain the `left` and `right` pointers and the `maxLength` variable.\n4. We iterate through the string using the `right` pointer.\n5. If the current character is not in the map or its index is less than `left`, it means it is a new unique character.\n6 We update the `charMap` with the character\'s index and update the `maxLength` if necessary.\n7. If the character is repeating within the current substring, we move the `left` pointer to the next position after the last occurrence of the character.\n8. We update the index of the current character in the `charMap` and continue the iteration.\n9. At the end, we return the `maxLength` as the length of the longest substring without repeating characters.\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_map<char, int> charMap;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charMap.count(s[right]) == 0 || charMap[s[right]] < left) {\n                charMap[s[right]] = right;\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                left = charMap[s[right]] + 1;\n                charMap[s[right]] = right;\n            }\n        }\n        \n        return maxLength;\n    }\n};\n```\n```Java []\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int maxLength = 0;\n        Map<Character, Integer> charMap = new HashMap<>();\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (!charMap.containsKey(s.charAt(right)) || charMap.get(s.charAt(right)) < left) {\n                charMap.put(s.charAt(right), right);\n                maxLength = Math.max(maxLength, right - left + 1);\n            } else {\n                left = charMap.get(s.charAt(right)) + 1;\n                charMap.put(s.charAt(right), right);\n            }\n        }\n        \n        return maxLength;\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        maxLength = 0\n        charMap = {}\n        left = 0\n        \n        for right in range(n):\n            if s[right] not in charMap or charMap[s[right]] < left:\n                charMap[s[right]] = right\n                maxLength = max(maxLength, right - left + 1)\n            else:\n                left = charMap[s[right]] + 1\n                charMap[s[right]] = right\n        \n        return maxLength\n\n```\n\n# Approach 3 - Integer Array\n1. This solution uses an integer array `charIndex` to store the indices of characters.\n2. We eliminate the need for an unordered map by utilizing the array.\n3. The `maxLength`, `left`, and `right` pointers are still present.\n4. We iterate through the string using the `right` pointer.\n5. We check if the current character has occurred within the current substring by comparing its index in `charIndex` with `left`.\n6. If the character has occurred, we move the `left` pointer to the next position after the last occurrence of the character.\n7. We update the index of the current character in `charIndex`.\n8. At each step, we update the `maxLength` by calculating the length of the current substring.\n9. We continue the iteration until reaching the end of the string.\n10. Finally, we return the `maxLength` as the length of the longest substring without repeating characters.\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        vector<int> charIndex(128, -1);\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charIndex[s[right]] >= left) {\n                left = charIndex[s[right]] + 1;\n            }\n            charIndex[s[right]] = right;\n            maxLength = max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n};\n```\n```Java []\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int maxLength = 0;\n        int[] charIndex = new int[128];\n        Arrays.fill(charIndex, -1);\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charIndex[s.charAt(right)] >= left) {\n                left = charIndex[s.charAt(right)] + 1;\n            }\n            charIndex[s.charAt(right)] = right;\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        maxLength = 0\n        charIndex = [-1] * 128\n        left = 0\n        \n        for right in range(n):\n            if charIndex[ord(s[right])] >= left:\n                left = charIndex[ord(s[right])] + 1\n            charIndex[ord(s[right])] = right\n            maxLength = max(maxLength, right - left + 1)\n        \n        return maxLength\n\n```\n\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/3831fd95-3bb1-44d1-bc1a-06b3b4317b56_1687028369.5286949.png)\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\n\n\n, status: null, voteStatus: 0, voteCount: 1168, creationDate: 1687028384, isHidden: null, author: {username: rahulvarma5297, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1690766901.png, reputation: 34032}}}, searchMeta: null}, {id: 347818, title: [Python3]: sliding window O(N) with explanation, commentCount: 67, topLevelCommentCount: 47, viewCount: 116890, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 663334, content: **Sliding window**\nWe use a dictionary to store the character as the key, the last appear index has been seen so far as value.\nseen[charactor] = index\n\n move the pointer when you met a repeated character in your window.\n\n\t  \n```\nindext    0    1    2    3   4   5   6   7\nstring    a    c    b    d   b   a   c   d\n          ^                  ^\n          |                  |\n\t\tleft               right\n\t\tseen = {a : 0, c : 1, b : 2, d: 3} \n\t\t# case 1: seen[b] = 2, current window  is s[0:4] , \n\t\t#        b is inside current window, seen[b] = 2 > left = 0. Move left pointer to seen[b] + 1 = 3\n\t\tseen = {a : 0, c : 1, b : 4, d: 3} \nindext    0    1    2    3   4   5   6   7\nstring    a    c    b    d   b   a   c   d\n\t\t\t\t\t\t ^   ^\n\t\t\t\t\t     |   |\n\t\t\t\t      left  right\t\t\nindext    0    1    2    3   4   5   6   7\nstring    a    c    b    d   b   a   c   d\n\t\t\t\t\t     ^       ^\n\t\t\t\t\t     |       |\n\t\t\t\t       left    right\t\t\n\t\t# case 2: seen[a] = 0,which means a not in current window s[3:5] , since seen[a] = 0 < left = 3 \n\t\t# we can keep moving right pointer.\n```\n\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        l = 0\n        output = 0\n        for r in range(len(s)):\n            """\n            If s[r] not in seen, we can keep increasing the window size by moving right pointer\n            """\n            if s[r] not in seen:\n                output = max(output,r-l+1)\n            """\n            There are two cases if s[r] in seen:\n            case1: s[r] is inside the current window, we need to change the window by moving left pointer to seen[s[r]] + 1.\n            case2: s[r] is not inside the current window, we can keep increase the window\n            """\n            else:\n                if seen[s[r]] < l:\n                    output = max(output,r-l+1)\n                else:\n                    l = seen[s[r]] + 1\n            seen[s[r]] = r\n        return output\n```\n* Time complexity :O(n). \n\tn is the length of the input string.\n\tIt will iterate n times to get the result.\n\n* Space complexity: O(m)\n\tm is the number of unique characters of the input. \n\tWe need a dictionary to store unique characters.\n\n, status: null, voteStatus: 0, voteCount: 834, creationDate: 1564559647, isHidden: null, author: {username: zhanweiting, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/weiting-zhan/avatar_1529194985.png, reputation: 3849}}}, searchMeta: null}, {id: 742926, title: Simple Explanation | Concise | Thinking Process & Example, commentCount: 18, topLevelCommentCount: 12, viewCount: 23817, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1367696, content: Lets start with the following example: \n\n**Assume you had no repeating characters** (In below example, just look at *first three* characters)\n\nWe take two pointers, `l` and `r`, both starting at `0`. At every iteration, we update the longest string with non-repeating characters found = `r-l+1` and just keep a note of which character we see at which index\n\n\n<img src="https://assets.leetcode.com/users/images/3e7b9848-1d57-42ed-9629-59f14cfcce89_1595114117.3901849.png" width=400/>\n\n\n```python\n    def lengthOfLongestSubstringSimpler(self, s):\n        seen = {}\n        left, right = 0, 0\n        longest = 1\n        while right < len(s):\n            longest = max(longest, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n        return longest\n```\n\nAfter 3 iterations, if you were keeping a map of when you last saw the character, you\'d have something like this:\n\n<img src="https://assets.leetcode.com/users/images/2f60312a-d377-4786-9449-4a95210f72e2_1595114189.5949714.png" width=300/>\n\nat this point, `longest = r-l+1 = 2 - 0 + 1 = 3`\n\nNow, lets face it - our string _does_ have repeating characters. We look at index 3, we\'re realizing we\'ve seen `a` before. So we now, we can\'t just calculate the value of `longest` like we were doing before. We need to make sure our left pointer, or `l`, is at least past the index where we last saw `a` , thus - we move `l ` to ` seen[right]+1`. We also update our map with last seen of `a` to `3`\n\n<img src="https://assets.leetcode.com/users/images/b7aaad14-993b-47e9-af01-441bbc5dfe20_1595114261.38747.png" width=300/>\n\nAnd this interplay goes on\n\n<img src="https://assets.leetcode.com/users/images/a22de24e-9e66-4e21-ab33-2ac06ce1d0cb_1595114354.4211376.png" width=300/>\n\n\n```python\n    def lengthOfLongestSubstring(self, s):\n        """\n        :type s: str\n        :rtype: int \n        """\n        if len(s) == 0:\n            return 0\n        seen = {}\n        left, right = 0, 0\n        longest = 1\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]]+1\n            longest = max(longest, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n        return longest\n```\n\nLife was good, until this test case came into our lives:\n`abba`\n\n<img src="https://assets.leetcode.com/users/images/cce6e442-6d18-4971-bcf2-d2c59ea11a51_1595115276.967406.png" width=200/>\n\nAnd we realised, after 4 iterations, our left pointer was to be moved `seen[s[right]]+1 = seen[a] + 1 = 1` - wait what, left was to move back ? That doesn\'t sound correct - that\'d give us longest to be 3 (bba) which is NOT CORRECT\n\nThus, we need to ensure that `l` always goes to the right of it, or just stays at its position\n\nIn other words;\n\n```python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        """\n        :type s: str\n        :rtype: int abcabcbb\n        """\n        if len(s) == 0:\n            return 0\n        seen = {}\n        left, right = 0, 0\n        longest = 1\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left,seen[s[right]]+1)\n            longest = max(longest, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n            print(left, right, longest)\n        return longest\n```\n\nThanks, and don\'t forget to upvote if it helped you !\n\n\n\n**BONUS** Trying to be a strong Java Developer ? Checkout this [awesome hands-on series](https://abhinandandubey.github.io/posts/tags/Advanced-Java-Series) with illustrations! \n, status: null, voteStatus: 0, voteCount: 358, creationDate: 1595115506, isHidden: null, author: {username: ivankatrump, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/_voyageur/avatar_1561652472.png, reputation: 1418}}}, searchMeta: null}, {id: 4840693, title: ã€Videoã€‘3 ways to solve this question - sliding window, set, hashing and the last position, commentCount: 6, topLevelCommentCount: 3, viewCount: 12921, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 7133538, content: # Solution Video\n\nhttps://youtu.be/n4zCTMh03_M\n\n### \u2B50\uFE0F\u2B50\uFE0F Don\'t forget to subscribe to my channel! \u2B50\uFE0F\u2B50\uFE0F\n\n**\u25A0 Subscribe URL**\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\nSubscribers: 3,982\nThank you for your support!\n\n---\n\n# Approach\nWe have two conditions to solve this question. The longest string should be\n\n---\n- Substring\n- Without repeating characters\n---\n\nYou just need to check that there are no repeated characters within a consecutive string of characters. To achieve this, you need to keep track of the characters currently forming the string. For this purpose, I considered three algorithms: one combining a sliding window and a set, and the second using a sliding window and a hash-based algorithm. The thrid is that the last position where each character was seen.\n\nI\'ll explain them one by one.\n\n# Solution 1 - Sliding Window & Set\n\nFirst of all, we create\n```\nleft = 0 \nmax_length = 0 (returned value)\nchar_set = set() \n```\n`left` is pointer of sliding window.\n`max_length` is a value we should return.\n`char_set` is to keep current characters forming the longest string with the two conditions above.\n\nWe will iterate through all characters one by one and create `right pointer` of sliding window with for loop.\n```\nfor right in range(len(s)):\n```\nLet\'s begin!\n```\nInput: s = "abcabcbb"\n```\n```\n"abcabcbb"\n r\n l\n\nl is left of sliding window\nr is right of sliding window\n```\nWe found `a`. Every time we check `char_set` if we have the same character or not. In this case, we don\'t have `a` in `char_set`, so add `a` to `char_set`.\n```\nchar_set = {a}\n```\nAfter that, we check `max length`.\n```\nmax_length = 0\ncurrent length = right - left + 1\n```\n##### Why +1?\n\nThat\'s because current length of string is `1` which is only `a`, so if we don\'t add `1`, we will calculate `0(right) - 0(left) = 0` which is wrong answer.\n\nThis happens because index number usually starts from `0` but actual count we do in daily life starts `1`. That\'s why we need to kind of convert an index number to a real number by adding `+1`.\n\nLet\'s go back to the main point.\n```\nmax_length = 1\n```\nNext, only right pointer move next. I\'ll speed up.\n```\n"abcabcbb"\n lr\n\nDo we have "b"? \u2192 No\nchar_set = {a, b}\n\nmax_length = 2 (right(1) - left(0) + 1)\n```\nNext, only right pointer move next.\n```\n"abcabcbb"\n l r\n\nDo we have "c"? \u2192 No\nchar_set = {a,b,c}\n\nmax_length = 3 (right(2) - left(0) + 1)\n```\nNext, only right pointer move next.\n```\n"abcabcbb"\n l  r\n\nDo we have "a"? \u2192 Yes\n```\nIn this case, we have duplicate number `a`, so we can\'t continue to expand the string. That\'s why it\'s time to move `left` to the next. And we have important point.\n\n---\n\n\u2B50\uFE0F Points\n\nWhen we move `left` to `index 1`, `a` at `index 0` will be out of bounds, so we should remove `a` from `char_set`, so that we can keep unique characters forming the current string.\n\nIn this case, we use `while` loop, I\'ll explain why later.\n\n---\n```\n"abcabcbb"\n l  r\n\n- Do we have "a"? \u2192 Yes, remove "a" in char_set\nchar_set = {b,c}\n\n- move left to the next\n"abcabcbb"\n  l r\n\n- There is no "a" in char_set, we stop while looping.\n- And add crreunt "a" to char_set\nchar_set = {b,c,a}\n\nmax_length = 3 (right(3) - left(1) + 1)\n```\nNext, only right pointer move next.\n```\n"abcabcbb"\n  l  r\n\n- Do we have "b"? \u2192 Yes, remove "b" in char_set\nchar_set = {c,a}\n\n- move left to the next\n"abcabcbb"\n   l r\n\n- There is no "b" in char_set, we stop while looping.\n- And add crreunt "b" to char_set\nchar_set = {c,a,b}\n\nmax_length = 3 (right(4) - left(2) + 1)\n```\nNext, only right pointer move next.\n```\n"abcabcbb"\n   l  r\n\n- Do we have "c"? \u2192 Yes, remove "c" in char_set\nchar_set = {a,b}\n\n- move left to the next\n"abcabcbb"\n    l r\n\n- There is no "c" in char_set, we stop while looping.\n- And add crreunt "c" to char_set\nchar_set = {a,b,c}\n\nmax_length = 3 (right(5) - left(3) + 1)\n```\nNext, only right pointer move next.\n```\n"abcabcbb"\n    l  r\n\n- Do we have "b"? \u2192 Yes, remove "a" in char_set\n```\nWait! Why do we have to remove `a` instead of `b`? That\'s because `b` is now duplicate character between `left` and `right`, so we have to remove chracters until we find `b` with `left` pointer.\n\n---\n\n\u2B50\uFE0F Points\nLet\'s look at the string deeply.\n```\n"abcb"\n l  r\n```\nIf we keep `a` in the string, we have to also keep the first `b` because `a` is outside of the first `b` in the string. If we want to remove the first `b`, we must remove `a` before we remove the first `b`. **This is substring.**\n\nIn the end,\n\n```\n"abcb"\n   lr\n```\nLet\'s look at the process.\n```\n"abcabcbb"\n    l  r\n\n- Do we have "b"? \u2192 Yes, remove "a" in char_set\nchar_set = {b,c}\n\n- Move left to the next\n"abcabcbb"\n     l r\n\n- Do we have "b"? \u2192 Yes, remove "b" in char_set\nchar_set = {c}\n\n- Move left to the next\n"abcabcbb"\n      lr\n\n- Do we have "b"? \u2192 No, now we stop while loop\n\n- Add current "b" to char_set\n- char_set = {c,b}\n\nmax_length = 3 > (right(6) - left(5) + 1)\n\n```\n\nI hope now you understand why we use while loop when remove charcters. **There is an case where we remove multiple characters.**\n\n---\n\nI stop rest of explanation because we will repeat the same process.\n\n```\nreturn 3\n```\nAs you can see, we keep `char_set` the same as the string between left and right when we add a current character to `char_set`. That\'s why we can check if current character is duplicate or not.\n\nEasy\uD83D\uDE06!\nLet\'s see solution codes and step by step algorithm!\n\n---\n\n\u2B50\uFE0F I recently created a video on how I\'ve been using LeetCode to learn.\n\nhttps://youtu.be/bU_dXCOWHls\n\n\n---\n\n# Complexity\n- Time complexity: $$O(n)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(1)$$\n\nConstraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.\n\n```python []\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left = max_length = 0\n        char_set = set()\n        \n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\n```\n```javascript []\nvar lengthOfLongestSubstring = function(s) {\n    let left = 0;\n    let maxLength = 0;\n    let charSet = new Set();\n\n    for (let right = 0; right < s.length; right++) {\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n\n        charSet.add(s[right]);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;    \n};\n```\n```java []\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int left = 0;\n        int maxLength = 0;\n        HashSet<Character> charSet = new HashSet<>();\n\n        for (int right = 0; right < s.length(); right++) {\n            while (charSet.contains(s.charAt(right))) {\n                charSet.remove(s.charAt(left));\n                left++;\n            }\n\n            charSet.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;       \n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int left = 0;\n        int maxLength = 0;\n        unordered_set<char> charSet;\n\n        for (int right = 0; right < s.length(); right++) {\n            while (charSet.find(s[right]) != charSet.end()) {\n                charSet.erase(s[left]);\n                left++;\n            }\n\n            charSet.insert(s[right]);\n            maxLength = max(maxLength, right - left + 1);\n        }\n\n        return maxLength;        \n    }\n};\n```\n## Step by step algorithm\n\n1. **Initialization:**\n\n```python\nleft = max_length = 0\nchar_set = set()\n```\n\n- `left`: Marks the start of the current substring.\n- `max_length`: Tracks the length of the longest substring without repeating characters. Initialized to 0.\n- `char_set`: Keeps track of unique characters encountered so far, initialized as an empty set.\n\n2. **Iterating over the string characters:**\n\n```python\nfor right in range(len(s)):\n```\n\n- `right`: Represents the end of the current substring. It moves from 0 to the end of the string.\n\n3. **Checking for repeating characters:**\n\n```python\nwhile s[right] in char_set:\n    char_set.remove(s[left])\n    left += 1\n```\n\n- This loop executes when the character at the \'right\' index is already in the `char_set`, meaning we have encountered a repeating character.\n- It removes characters from the `char_set` and adjusts the \'left\' pointer until the current character at \'right\' is no longer in the `char_set`. This effectively removes the characters from the substring that are causing the repetition.\n\n4. **Updating `char_set` and `max_length`:**\n\n```python\nchar_set.add(s[right])\nmax_length = max(max_length, right - left + 1)\n```\n\n- Adds the current character to `char_set` since it\'s unique now.\n- Updates `max_length` by taking the maximum between the current `max_length` and the length of the current substring (`right - left + 1`).\n\n5. **Returning `max_length`:**\n\n```python\nreturn max_length\n```\n\n- After iterating through the entire string, the function returns the maximum length of the substring without repeating characters.\n\n# Solution 2 - Sliding Window and Hashing\n\nIn solution 2, we use almost the same idea as solution 1 with Slinding Window and Hashing. In Python, we use `HashMap`.\n\nIn `HashMap`, we keep each character as a key and frequency of the characters as a value.\n\nEvery time we find a character, add `1 frequency` to `HashMap`. Since this question requires us to find the longest substring without repeating characters, so if we have more than `2 frequency` of the current character, we add `-1` to `HashMap` until we have `1 frequency` of the current character and move left pointer to the next at the same time.\n\nAfter that, this is the same as solution 1. Just compare `max length`\n\n```\nmax_length = max(max_length, right - left + 1)\n```\n\nEasy\uD83D\uDE04\uFF01\nLet\'s see solution codes and step by step algorithm!\n\n\n---\n\n# Complexity\n- Time complexity: $$O(n)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(1)$$\n\nConstraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.\n\n```python []\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n\n        max_length = left = 0\n        count = {}\n\n        for right, c in enumerate(s):\n            count[c] = 1 + count.get(c, 0)\n            while count[c] > 1:\n                count[s[left]] -= 1\n                left += 1\n        \n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n```\n```javascript []\nvar lengthOfLongestSubstring = function(s) {\n    let maxLength = 0;\n    let left = 0;\n    let count = {};\n\n    for (let right = 0; right < s.length; right++) {\n        let c = s[right];\n        count[c] = (count[c] || 0) + 1;\n        \n        while (count[c] > 1) {\n            count[s[left]] -= 1;\n            left++;\n        }\n        \n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;    \n};\n```\n```java []\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int maxLength = 0;\n        int left = 0;\n        Map<Character, Integer> count = new HashMap<>();\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n            \n            while (count.get(c) > 1) {\n                char leftChar = s.charAt(left);\n                count.put(leftChar, count.get(leftChar) - 1);\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;       \n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int maxLength = 0;\n        int left = 0;\n        unordered_map<char, int> count;\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s[right];\n            count[c] = count[c] + 1;\n            \n            while (count[c] > 1) {\n                char leftChar = s[left];\n                count[leftChar] = count[leftChar] - 1;\n                left++;\n            }\n            \n            maxLength = max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;        \n    }\n};\n```\n\n## Step by step algorithm\n\n1. **Initialization:**\n\n```python\nmax_length = left = 0\ncount = {}\n```\n\n- `max_length`: Represents the length of the longest substring without repeating characters found so far. Initialized to 0.\n- `left`: Marks the start index of the current substring.\n- `count`: A dictionary used to store the count of characters encountered in the current substring.\n\n2. **Iterating Over the String:**\n\n```python\nfor right, c in enumerate(s):\n```\n\n- `right`: Represents the end index of the current substring. It is updated using `enumerate(s)`, which returns both the index and the character at that index in the string.\n- `c`: Represents the character at the current index.\n\n3. **Updating the Character Count:**\n\n```python\ncount[c] = 1 + count.get(c, 0)\n```\n\n- This line updates the count of the current character `c` in the `count` dictionary.\n- If `c` is not present in the dictionary, it initializes its count to 1. Otherwise, it increments its count by 1.\n\n4. **Adjusting the Left Pointer:**\n\n```python\nwhile count[c] > 1:\n    count[s[left]] -= 1\n    left += 1\n```\n\n- This while loop adjusts the `left` pointer as long as there are repeating characters in the current substring.\n- It decreases the count of the character at index `left` and increments `left` by 1 until there are no repeating characters.\n\n5. **Updating the Maximum Length:**\n\n```python\nmax_length = max(max_length, right - left + 1)\n```\n\n- This line updates the maximum length (`max_length`) of the substring without repeating characters.\n- It calculates the length of the current substring (`right - left + 1`) and compares it with the current maximum length (`max_length`). If the current substring is longer, it updates `max_length`.\n\n6. **Returning the Result:**\n\n```python\nreturn max_length\n```\n\n- After iterating through the entire string, the function returns the maximum length of the substring without repeating characters.\n\nIn summary, this algorithm efficiently finds the length of the longest substring without repeating characters using two pointers (`left` and `right`) and a dictionary (`count`) to keep track of character counts. It iterates through the string once, making it a linear time complexity algorithm.\n\n# Solution 3 - the last position where each character was seen\n\nIn the solution 3, we also iterate through all characters one by one. That is `right` pointer.\n\nWe update `left` pointer with `HashMap`. In `HashMap`, we keep each character as a key and the last position where each character was seen\u3000as a value.\n\nDo you remember this example in solution 1?\n\n```\n"abcb"\n l  r\n```\nLet\'s call HashMap `last_seen`.\n\nIn this case, `last_seen` should have this\n```\nlast_seen = {a:0, b:1, c:2}\n\nlast position of a is 0\nlast position of b is 1\nlast position of c is 2\n\ncurrent max length shold be 3 (= abc)\n```\nNow we find the second `b` at index `3`. As I explain in solution 1, we have to remove characters until we have unique characters between `left` and `right`.\n\n`left` pointer is at index `0` and the last position where `b` was seen is index `1`, so that\'s why we should update `left` pointer with `1`.\n\nOne more important thing is that if we update `left` with `1`, we have `bcb` as a string which is including duplicate characters.\n\nThat\'s why we should update `left` pointer with `the last position + 1`.\n\n```\nleft = last_seen[character(= b)] + 1\n= 2\n```\nThen compare max length\n```\nmax_length = max(max_length, right - left + 1)\n```\n\nEasy\uD83D\uDE04!\nLet\'s see solution codes and step by step algorithm!\n\n---\n\n# Complexity\n- Time complexity: $$O(n)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(1)$$\n\nConstraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.\n\n\n```python []\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_length = 0\n        left = 0\n        last_seen = {}\n\n        for right, c in enumerate(s):\n            if c in last_seen and last_seen[c] >= left:\n                left = last_seen[c] + 1\n            \n            max_length = max(max_length, right - left + 1)\n            last_seen[c] = right\n\n        return max_length\n```\n```javascript []\nvar lengthOfLongestSubstring = function(s) {\n    let maxLength = 0;\n    let left = 0;\n    let lastSeen = {};\n\n    for (let right = 0; right < s.length; right++) {\n        let c = s.charAt(right);\n        if (c in lastSeen && lastSeen[c] >= left) {\n            left = lastSeen[c] + 1;\n        }\n        maxLength = Math.max(maxLength, right - left + 1);\n        lastSeen[c] = right;\n    }\n\n    return maxLength;     \n};\n```\n```java []\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int maxLength = 0;\n        int left = 0;\n        Map<Character, Integer> lastSeen = new HashMap<>();\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            if (lastSeen.containsKey(c) && lastSeen.get(c) >= left) {\n                left = lastSeen.get(c) + 1;\n            }\n            maxLength = Math.max(maxLength, right - left + 1);\n            lastSeen.put(c, right);\n        }\n\n        return maxLength;       \n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int maxLength = 0;\n        int left = 0;\n        unordered_map<char, int> lastSeen;\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s[right];\n            if (lastSeen.find(c) != lastSeen.end() && lastSeen[c] >= left) {\n                left = lastSeen[c] + 1;\n            }\n            maxLength = max(maxLength, right - left + 1);\n            lastSeen[c] = right;\n        }\n\n        return maxLength;        \n    }\n};\n```\n\n## Step by step algorithm\n\n1. **Initialization:**\n\n```python\nmax_length = 0\nleft = 0\nlast_seen = {}\n```\n\n- `max_length`: Keeps track of the length of the longest substring without repeating characters.\n- `left`: Marks the start index of the current substring.\n- `last_seen`: A dictionary to store the last seen index of each character in the string.\n\n2. **Iterating Over the String:**\n\n```python\nfor right, c in enumerate(s):\n```\n\n- `right`: Represents the current index of the character `c` being processed.\n- `c`: Represents the current character being processed.\n\n3. **Checking for Repeating Characters:**\n\n```python\nif c in last_seen and last_seen[c] >= left:\n    left = last_seen[c] + 1\n```\n\n- If the character `c` is present in `last_seen` and its last seen index is greater than or equal to `left` (the start index of the current substring), it means that `c` is repeating within the current substring.\n- In such a case, we update `left` to the index next to the last occurrence of `c`.\n\n4. **Updating `max_length`:**\n\n```python\nmax_length = max(max_length, right - left + 1)\n```\n\n- Update `max_length` with the maximum value between its current value and the length of the current substring (`right - left + 1`).\n- `right - left + 1` represents the length of the current substring without repeating characters.\n\n5. **Updating `last_seen`:**\n\n```python\nlast_seen[c] = right\n```\n\n- Update the `last_seen` dictionary with the index `right` where the character `c` was last seen.\n\n6. **Returning the Result:**\n\n```python\nreturn max_length\n```\n\n- After iterating through the entire string, return the maximum length of the substring without repeating characters.\n\n---\n\nThank you for reading my post. Please upvote it and don\'t forget to subscribe to my channel!\n\n\u2B50\uFE0F Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\n\u2B50\uFE0F Twitter\nhttps://twitter.com/CodingNinjaAZ, status: null, voteStatus: 0, voteCount: 77, creationDate: 1709873757, isHidden: null, author: {username: niits, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1698738357.png, reputation: 7282}}}, searchMeta: null}, {id: 2132954, title: âœ… [Python] Simple Solution w/ Explanation | Brute-Force + Sliding Window, commentCount: 8, topLevelCommentCount: 5, viewCount: 4812, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Two Pointers, slug: two-pointers}, {name: Sliding Window, slug: sliding-window}], post: {id: 3566171, content: We are given a string `s`. We need to find the length of the **longest substring** without repeating characters.\n___\n___\n\u2705 **Solution I - Brute-Force [Accepted]**\n\nStarting with each index, we can check all substrings till we find a repeating character.\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res = 0\n        seen = set()\n        for start_idx in range(len(s)):\n            seen.clear()\n            end_idx = start_idx\n            while end_idx < len(s):\n                if s[end_idx] in seen:\n                    break\n                seen.add(s[end_idx])\n                end_idx += 1\n            res = max(res, end_idx - start_idx)\n        return res\n```\n\n- **Time Complexity:** `O(n\xB2)`\n- **Space Complexity:** `O(1)`\n___\n\u2705 **Solution II - Sliding Window [Accepted]**\n\nIn the above solution, we are doing many redundant operations. After finding a repeating character, we break the inner loop and again check for all substrings from the next index.\nThe following example will make it clear what I mean by redundant operations:\n\n```text\ns = "redundant"\nLet start_idx = 0\nWhen end_idx becomes 5, it sees that "d" had already come before.\nSo, should we start again with index 1?\nNo, because all substrings starting with "e" and later (till "d" or the character which was repeated) will have less length than that of "redun".\nWe can start from "u"\n```\n\nWe can create a sliding window: `[start_idx: end_idx]` where `end_idx` will move forward continuously and `start_idx` will change only if the character at `end_idx` is already present within this window. To know whether this character is already present, we need to store information about the index of characters.\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        prev = [-1] * 128\n        res, start_idx = 0, 0\n        for end_idx, char in enumerate(s):\n            if prev[ord(char)] >= start_idx:\n                start_idx = prev[ord(char)] + 1\n            prev[ord(char)] = end_idx\n            res = max(res, end_idx - start_idx + 1)\n            \n        return res\n```\n\n- **Time Complexity:** `O(n)`\n- **Space Complexity:** `O(1)`\n\n___\n___\nIf you like the solution, please **upvote** \uD83D\uDD3C\nFor any questions, or discussions, comment below. \uD83D\uDC47\uFE0F\n, status: null, voteStatus: 0, voteCount: 30, creationDate: 1654826897, isHidden: null, author: {username: r0gue_shinobi, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1702433980.png, reputation: 1207}}}, searchMeta: null}, {id: 3024764, title: âœ… Python - Sliding Window approach || 99.17% faster âœ…, commentCount: 15, topLevelCommentCount: 6, viewCount: 15601, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Sliding Window, slug: sliding-window}], post: {id: 4777858, content: ## Please upvote if you like the solution\n\n\n# Complexity\n- Time complexity:\n$$O(n^2)$$\n\n\n- Space complexity:\n$$O(k)$$ -> where k is the size of the result string\n\n\n\n# Code\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # Base Case\n        if len(s) == 1: return 1\n\n\n        count, s_result = 0, \'\'\n\n        for i in s:\n            if i not in s_result:\n                s_result += i\n            else:\n                s_result = s_result[s_result.index(i)+1:] + i\n\n            if len(s_result) > count:\n                count = len(s_result)\n        \n        return count\n\n            \n\n            \n\n            \n\n        \n\n```, status: null, voteStatus: 0, voteCount: 28, creationDate: 1673268225, isHidden: null, author: {username: pi2labs, isActive: true, nameColor: null, activeBadge: {displayName: Level 1, icon: https://assets.leetcode.com/static_assets/others/%E5%85%A5%E9%97%A8.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1668948515.png, reputation: 28}}}, searchMeta: null}, {id: 4019130, title: Simple Python3 Solution using Sliding window || Beats 99% || ðŸ’»ðŸ§‘â€ðŸ’»ðŸ¤–, commentCount: 3, topLevelCommentCount: 2, viewCount: 3077, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 6071913, content: \n\n# Code\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l=len(s)\n        if l==0:\n            return 0\n        dicts={}\n        max_len=0\n        start=0\n        for i in range(l):\n            if s[i] in dicts and start<=dicts[s[i]]:\n                start = dicts[s[i]]+1\n            else:\n                max_len=max(max_len,i-start+1)\n            dicts[s[i]]=i\n        return max_len\n        \n```\n![7abc56.jpg](https://assets.leetcode.com/users/images/b0e5a9a2-a2a2-452d-9a1b-33d9fbab7296_1694192336.7716062.jpeg)\n, status: null, voteStatus: 0, voteCount: 26, creationDate: 1694192369, isHidden: null, author: {username: Abhishek2708, isActive: true, nameColor: null, activeBadge: {displayName: Sep LeetCoding Challenge, icon: /static/images/badges/dcc-2023-9.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1691473956.png, reputation: 98}}}, searchMeta: null}, {id: 2132791, title: Python Easy 2 approaches âœ…, commentCount: 3, topLevelCommentCount: 2, viewCount: 3668, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 3565951, content: 1. ## **Sliding Window - Counter**\n\nThis approach uses `counter` variable to track number of characters in a sliding window. Whenever we encounter a state where the window becomes invalid due to number of characters(count of any character > 1), we would update the left bound of the new valid window.\n\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        counter = defaultdict(int)        # track counts of each character\n        l=0\n        max_length=0\n        for r, c in enumerate(s):\n            counter[c]+=1            \n            if counter[c] > 1:                \n                while l<r and counter[c]>1: # iterate until window is valid\n                    counter[s[l]]-=1\n                    l+=1\n            max_length=max(max_length, r-l+1)\n        return max_length\n```\n**Time  - O(2n)** - Iterates both `l` and `r` once through the input `s`.\n**Space - O(n)**\n\n---\n\n2. ## **Sliding Window - Last Seen**\n\nIf we observe the previous approach, we would notice we don\'t need to track the counts of each character in a sliding window. We just need to track the last seen of a character. This will help us figure out whether a character exists in the current sliding window.\n\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        last_seen = {}\n        l=0\n        max_length=0\n        for r in range(len(s)):\n            if s[r] in last_seen:\n                l=max(last_seen[s[r]], l)\n            \n            last_seen[s[r]]=r+1\n            max_length=max(max_length, r-l+1)\n        return max_length\n                    \n```\n\n**Time  - O(n)** - Iterates both `l` and `r` once through the input `s`.\n**Space - O(n)**\n\n\n---\n\n***Please upvote if you find it useful***, status: null, voteStatus: 0, voteCount: 24, creationDate: 1654820960, isHidden: null, author: {username: constantine786, isActive: true, nameColor: null, activeBadge: {displayName: Jun LeetCoding Challenge, icon: /static/images/badges/dcc-2022-6.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1649842449.png, reputation: 2503}}}, searchMeta: null}, {id: 2799840, title: Python | Easy Solutionâœ…, commentCount: 6, topLevelCommentCount: 3, viewCount: 10470, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Hash Table, slug: hash-table}, {name: Sliding Window, slug: sliding-window}], post: {id: 4481818, content: \n# Code\u2705\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        output = 0\n        count = {}\n        pos = -1\n        for index, letter in enumerate(s):\n            if letter in count and count[letter] > pos:\n                pos = count[letter]\n            count[letter] = index \n            output = max(output,index-pos)\n        return output\n```, status: null, voteStatus: 0, voteCount: 23, creationDate: 1668081339, isHidden: null, author: {username: gmanayath, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1671114329.png, reputation: 928}}}, searchMeta: null}, {id: 1005991, title: Python. Cool & easy solution. O(n) time. O(1) space., commentCount: 6, topLevelCommentCount: 5, viewCount: 3380, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1820687, content: \tclass Solution:\n\t\tdef lengthOfLongestSubstring(self, s: str) -> int:\n\t\t\tcharacters = set()\n\t\t\tleft = right = ans = 0\n\t\t\tlength = len(s)\n\t\t\t\n\t\t\twhile right < length:\n\t\t\t\tif s[right] in characters:\n\t\t\t\t\tcharacters.remove(s[left])\n\t\t\t\t\tleft += 1\n\t\t\t\telse:\n\t\t\t\t\tcharacters.add(s[right])\n\t\t\t\t\tright += 1\n\t\t\t\t\tans = max(ans, right - left)\n\t\t\t\n\t\t\treturn ans, status: null, voteStatus: 0, voteCount: 23, creationDate: 1610009928, isHidden: null, author: {username: m-d-f, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 1207}}}, searchMeta: null}, {id: 1526581, title: Simplest way (with explanation) [97% faster], commentCount: 4, topLevelCommentCount: 4, viewCount: 1669, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2648788, content: ```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \n        string = s\n        \n        max_length = 0      # we set max_length to 0 because string may be empty.\n        seen_character = \'\' # a empty string to store the character that we have already seen.\n        \n        for letter in string:   # we are checking every letter/character in string...\n            if letter not in seen_character:\n                seen_character += letter      # if letter not in there then we add to it.\n                \n            else:\n                ## now if the letter is already in seen_character then we get the index of that letter by using seen_character.index() and then we slice the string from that index+1 to last, so that the the first seen letter will be removed.\n                # for example - \'abcabbd\'     # here after \'abc\' , again "a" was there so we get the index of first "a" and slice the string then be get string = "bc" .\n                seen_character = seen_character[seen_character.index(letter) + 1:] + letter\n                # and then we add the letter "a" to the last. so the string will become "bca"\n                \n            max_length = max(max_length, len(seen_character))   # here we use a function max() that everytime return the maximum value between two number. it sets max_length each time the loop runs.\n        return max_length     # finally return the maximum length.\n        \n    #by - Tony Stark\n```, status: null, voteStatus: 0, voteCount: 21, creationDate: 1634489766, isHidden: null, author: {username: tony_stark_47, isActive: true, nameColor: null, activeBadge: {displayName: Mar LeetCoding Challenge, icon: /static/images/badges/dcc-2024-3.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1691230617.png, reputation: 27}}}, searchMeta: null}, {id: 3615217, title: Easy well explained python solution (faster than 98%), O(n) time complexity, commentCount: 2, topLevelCommentCount: 2, viewCount: 8541, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: String, slug: string}], post: {id: 5540184, content: # Intuition\nwe use a **starting point** while iterating over the given string and every time we find a repeated character we calculate the length of the substring between the starting point and the current point - 1.\nevery time we find a repetition we set the starting point to the character next to the last occurrence.\n\n**Ex :** consider the string **`abcdae`**\n\nthe starting point will be $$0$$ initially, we keep iterating until we find the second **`a`**. we calculate then the length of the substring **`abcd`** and then set the starting point to the character next to the first **`a`**, which is **`b`**.\nthen, we will keep iterating until the end since there are no more repetitions and the answer will be $$5$$ (the length of **`bcdae`**).\n\n# Approach\nwe will need $$2$$ variables: \n1. $$`longest`$$ to **save the length of the longest substring found**\n2. $$`offset`$$ for **the starting point**.\n\nwe will also need to save the encountered characters to check repetition, a dictionary will be ideal for this case as it doesn\'t allow repetition. for that we will use an extra variable \n- $$`indexes`$$: to save characters and their indexes, **characters** will be **keys** and **indexes** will be **values**.\n\nwe start then: for every character: \n1. we get its index from indexes dictionary.\n2. if the index wasn\'t null `(meaning that it was encountered before)`, we check if its index is **greater or equal to the offset** `(meaning that its in the current substring)`.\nif so :\n    - we calculate the length of the substring : $$i\\,(current\\: position) - offset$$\n    - we set the offset to the next character of the last occurrence : $$index\\,(last\\:occurrence) + 1$$\n    - if the length of this substring is greater than the length of the current longest substring, we update it\n3. we update the index of the last occurrence of the current character (or add it if this is its first occurrence).\n\nFinally, we return the **maximum** between $$`longest`$$ and **the length of the last substring** `(which is equal to the difference between the length of the string and offset)`as it contains **no repeated characters** and its length is **never compared** to $$`longest`$$ because **we get out of the loop**.\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n# Code\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        longest = 0\n        indexes = {}\n        offset = 0\n        for i in range(len(s)):\n            char = s[i]\n            index = indexes.get(char)\n            if index is not None and index >= offset:\n                length = i - offset\n                offset = index + 1\n                if length > longest:\n                    longest = length\n            indexes[char] = i\n        return max(longest, (len(s) - offset))\n```, status: null, voteStatus: 0, voteCount: 12, creationDate: 1686254609, isHidden: null, author: {username: itsMaherrr, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1656090261.png, reputation: 18}}}, searchMeta: null}, {id: 2383487, title: [Fastest Solution Explained][0ms][100%] O(n)time complexity O(n)space complexity, commentCount: 1, topLevelCommentCount: 1, viewCount: 4094, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: JavaScript, slug: javascript}, {name: Swift, slug: swift}, {name: Kotlin, slug: kotlin}, {name: PHP, slug: php}], post: {id: 3913874, content: \n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\n***Take care brother, peace, love!***\n\n```\n```\n\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\n* *** Java ***\n\n```\n\npublic int lengthOfLongestSubstring(String s) {\n    int i = 0, j = 0, max = 0;\n    Set<Character> set = new HashSet<>();\n    \n    while (j < s.length()) {\n        if (!set.contains(s.charAt(j))) {\n            set.add(s.charAt(j++));\n            max = Math.max(max, set.size());\n        } else {\n            set.remove(s.charAt(i++));\n        }\n    }\n    \n    return max;\n}\n\n```\nThe idea is use a hash set to track the longest substring without repeating characters so far, use a fast pointer j to see if character j is in the hash set or not, if not, great, add it to the hash set, move j forward and update the max length, otherwise, delete from the head by using a slow pointer i until we can put character j to the hash set.\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\n* *** Python ***\n\n```\nSliding window\nWe use a dictionary to store the character as the key, the last appear index has been seen so far as value.\nseen[charactor] = index\n\nmove the pointer when you met a repeated character in your window.\n```\n\n```\n\nindext    0    1    2    3   4   5   6   7\nstring    a    c    b    d   b   a   c   d\n          ^                  ^\n          |                  |\n\t\tleft               right\n\t\tseen = {a : 0, c : 1, b : 2, d: 3} \n\t\t# case 1: seen[b] = 2, current window  is s[0:4] , \n\t\t#        b is inside current window, seen[b] = 2 > left = 0. Move left pointer to seen[b] + 1 = 3\n\t\tseen = {a : 0, c : 1, b : 4, d: 3} \nindext    0    1    2    3   4   5   6   7\nstring    a    c    b    d   b   a   c   d\n\t\t\t\t\t\t ^   ^\n\t\t\t\t\t     |   |\n\t\t\t\t      left  right\t\t\nindext    0    1    2    3   4   5   6   7\nstring    a    c    b    d   b   a   c   d\n\t\t\t\t\t     ^       ^\n\t\t\t\t\t     |       |\n\t\t\t\t       left    right\t\t\n\t\t# case 2: seen[a] = 0,which means a not in current window s[3:5] , since seen[a] = 0 < left = 3 \n\t\t# we can keep moving right pointer.\n\n```\n\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        l = 0\n        output = 0\n        for r in range(len(s)):\n            """\n            If s[r] not in seen, we can keep increasing the window size by moving right pointer\n            """\n            if s[r] not in seen:\n                output = max(output,r-l+1)\n            """\n            There are two cases if s[r] in seen:\n            case1: s[r] is inside the current window, we need to change the window by moving left pointer to seen[s[r]] + 1.\n            case2: s[r] is not inside the current window, we can keep increase the window\n            """\n            else:\n                if seen[s[r]] < l:\n                    output = max(output,r-l+1)\n                else:\n                    l = seen[s[r]] + 1\n            seen[s[r]] = r\n        return output\n```\n* Time complexity :O(n).\nn is the length of the input string.\nIt will iterate n times to get the result.\n\n* Space complexity: O(m)\nm is the number of unique characters of the input.\nWe need a dictionary to store unique characters.\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\n* *** C++ ***\n\n\n```\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n        //SLIDING WINDOW  - TIME COMPLEXITY O(2n)\n        //                  SPACE COMPLEXITY O(m)   //size of array\n        \n        int store[256]={0}; //array to store the occurences of all the characters\n        int l=0;    //left pointer\n        int r=0;    //right pointer\n        int ans=0;  //initializing the required length as 0\n        \n        while(r<s.length())     //iterate over the string till the right pointer reaches the end of the string \n        {\n            store[s[r]]++;      //increment the count of the character present in the right pointer \n            \n            while(store[s[r]]>1)    //if the occurence become more than 1 means the char is repeated\n            { \n                store[s[l]]--;   //reduce the occurence of temp as it might be present ahead also in the string\n                l++;         //contraction of the present window till the occurence of the \'t\' char becomes 1\n            }\n            \n            ans = max(ans,r-l+1);    //As the index starts from 0 , ans will be (right pointer-left pointer + 1)\n            r++;        // now will increment the right pointer \n        }\n        return ans;\n    }\n};\n\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\n* *** JavaScript ***\n\n\n```\n\nfunction lengthOfLongestSubstring(s) {\n    const map = {};\n    var left = 0;\n    \n    return s.split(\'\').reduce((max, v, i) => {\n        left = map[v] >= left ? map[v] + 1 : left;\n        map[v] = i;\n        return Math.max(max, i - left + 1);\n    }, 0);\n}\n\n```\n\n```\nTime Complexity = O(N)\nSpace Complexity = O(N)\n```\n\n```\nvar lengthOfLongestSubstring = function(s) {\n    // keeps track of the most recent index of each letter.\n    const seen = new Map();\n    // keeps track of the starting index of the current substring.\n    let start = 0;\n    // keeps track of the maximum substring length.\n    let maxLen = 0;\n    \n    for(let i = 0; i < s.length; i++) {\n        // if the current char was seen, move the start to (1 + the last index of this char)\n        // max prevents moving backward, \'start\' can only move forward\n        if(seen.has(s[i])) start = Math.max(seen.get(s[i]) + 1, start)\n        seen.set(s[i], i);\n        // maximum of the current substring length and maxLen\n        maxLen = Math.max(i - start + 1, maxLen);\n    } \n    \n    return maxLen;  \n};\n```\n\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\n* *** Kotlin ***\n\n\n```\n\nfun lengthOfLongestSubstring(s: String): Int {\n    var maxLength = 0\n    val queue = LinkedList<Char>()\n    for (i in s.indices) {\n        if (queue.isNotEmpty()) {\n            when {\n                queue.first == s[i] -> queue.poll()\n                queue.last == s[i] -> queue.clear()\n                queue.contains(s[i]) -> {\n                    while (queue.isNotEmpty()) {\n                        if (queue.poll() == s[i]) break\n                    }\n                }\n            }\n        }\n\n        maxLength = max(maxLength, queue.size+1)\n        queue.offer(s[i])\n    }\n\n    return maxLength\n}\n```\n\n```\nimport kotlin.math.*\n\nclass Solution {\n    private val hashMap = mutableMapOf<Char, Int>()\n    private var longest = Pair<Int, Int>(0, 1)\n    \n    fun lengthOfLongestSubstring(s: String): Int {\n        if (s.length == 0) {\n            return 0\n        }\n        \n        var start = 0\n        \n        for (i in 0 until s.length) {\n            val letter = s[i]\n            if (hashMap.containsKey(letter)) {\n                // start = max(start, hashMap[letter]!! + 1)\n                // why use max() ? "abba": if we take not max, then when visiting second \'a\' ->\n                // we\'ll take b, but don\'t need it as it\'ll include duplicate\n                start = hashMap[letter]!! + 1\n                // +1 as we don\'t need current that has duplication, but next letter after it\n            }\n            val (firstIdx: Int, secondIdx: Int) = longest\n            \n            if (secondIdx - firstIdx < i - start + 1) {\n                longest = Pair<Int, Int>(start, i+1)\n                // +1 is to include current last letter as otherwise it will be excluding\n            }\n            hashMap.put(letter, i)\n        }\n        val (firstIdx: Int, secondIdx: Int) = longest\n        \n        return secondIdx - firstIdx\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\n* *** Swift ***\n\n\n```\n\nclass Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        guard !s.isEmpty else { return 0 }\n        var len = 0, chars = [Character]()\n        for c in s {\n            if let idx = chars.firstIndex(of: c) {\n                chars.removeSubrange(0...idx)\n            }\n            chars.append(c)\n            len = max(len, chars.count)\n        }\n        return len\n    }\n}\n\n```\n* O(N)\n```\nclass Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        var longest = 0, startIndex = 0\n        var charMap: [Character: Int] = [:]\n\n        for (index, char) in s.enumerated() {\n            if let foundIndex = charMap[char] {\n                startIndex = max(foundIndex+1, startIndex)\n            }\n            longest = max(longest, index - startIndex + 1)\n            charMap[char] = index\n        }\n        return longest\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\n* *** PHP ***\n\n\n```\n\nclass Solution {\n\n/**\n * @param String $s\n * @return Integer\n */\nfunction lengthOfLongestSubstring($s) {\n\t$start = 0;    //current starting position of search\n    $length = 0; //current max length of substring\n    for($i = 0; $i < strlen($s); $i++){\n        $char = $s[$i];\n        if(isset($arr[$char]) && $arr[$char] >= $start){\n            $start = $arr[$char] + 1;\n        } elseif($i - $start === $length) {\n            $length++;\n        }\n        $arr[$char] = $i;\n    }\n    return $length;\n}\n}\n\n```\n\n```\nclass Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLongestSubstring($s) \n    {\n        if (strlen($s) === 0) return 0;\n        if (strlen($s) === 1) return 1;\n        \n        $chars = str_split($s);\n        \n        $i = $j = $max = 0;\n        $seen = [];\n        \n        while ($i < count($chars))\n        {\n            $c = $chars[$i];\n           \n            while (array_key_exists($c, $seen))\n            {\n                unset($seen[$chars[$j]]);\n        \t\t$j++;\n            }\n            \n            $seen[$chars[$i]] = true;\n            \n            $max = max($i - $j + 1, $max);\n            $i++;\n        }\n        return $max;\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\n* *** C ***\n\n\n```\n\nint lengthOfLongestSubstring(char * s){\n    /*letter_map is to keep track if we saw this character in this substring*/\n    int letter_map[128] = {0}, res = 0;\n    char* start = s, *end = s;\n    \n    while (*end) {\n        /* If we reached a letter we saw already - check max length and start a new substring*/\n        if (letter_map[*end]) {\n            res = (end - start > res) ? end - start : res;\n            while (*start != *end) {\n                letter_map[*start] = 0;\n                start++;\n            }\n            start++;\n            end++;\n        }\n        else {\n            letter_map[*end] = 1;\n            end++;\n        }  \n    }\n    return end-start > res ? end-start : res;\n}\n\n```\n\n```\n```\n\n```\n```\n\n***"Open your eyes. Expect us." - \uD835\uDCD0\uD835\uDCF7\uD835\uDCF8\uD835\uDCF7\uD835\uDD02\uD835\uDCF6\uD835\uDCF8\uD835\uDCFE\uD835\uDCFC***\n, status: null, voteStatus: 0, voteCount: 11, creationDate: 1659711368, isHidden: null, author: {username: darian-catalin-cucer, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1680878634.png, reputation: 2245}}}, searchMeta: null}, {id: 2338675, title: â­C#,Java,Python3, JavaScript Solutions (easy), commentCount: 0, topLevelCommentCount: 0, viewCount: 3350, pinned: false, isFavorite: false, solutionTags: [{name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 3852134, content: See Code and Explanation :  **\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-3-longest-substring-without-repeating-characters-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-3-longest-substring-without-repeating-characters-solution-and-explanation-en/)\u2B50**\n\n**Examples : C#**\n```\npublic class Solution {\n    public int LengthOfLongestSubstring(string s) {\n        \n        if(string.IsNullOrEmpty(s))\n        {\n            return 0;\n        }\n\n        HashSet<char> hSet = new HashSet<char>();\n        int max = 0;\n        int i = 0;\n        int j = 0;\n        \n        while(i<s.Length)\n        {\n            if(!hSet.Contains(s[i]))\n            {\n                hSet.Add(s[i]);\n                i++;\n                \n            }\n            else\n            {\n                max = Math.Max(max,hSet.Count);\n                hSet.Remove(s[j]);\n                j++;\n            }\n        }\n        max = Math.Max(max,hSet.Count);\n        return max;\n        \n    }\n}\n```\n\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\n\n\uD83E\uDDE1See more problems solutions - **[Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\n\nThanks!, status: null, voteStatus: 0, voteCount: 11, creationDate: 1658881437, isHidden: null, author: {username: zyrastory, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1649596945.png, reputation: 773}}}, searchMeta: null}, {id: 1074783, title: Python Interview Thought Process: O(2^n) -> O(n), commentCount: 1, topLevelCommentCount: 1, viewCount: 1674, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Sliding Window, slug: sliding-window}], post: {id: 1933453, content: * First, I thought we could try every substring via recursion \n\t* Check if each substring is "valid"\n\t* If valid, update our "best" result\n\t* This is `O(2^n)`, definitely not good enough\n\n\n* Second, why not "expand" a window from each character?\n\t* We loop over each character and call a function to "expand" a window\n\t* We try to increment the window by one to the right, if we ecounter a duplicate value, we stop\n\t* This is better, but still `O(n^2)`\n\n\n* Lastly, similar to previous idea, we can have a sliding window using a queue and a set\n\t* We just pop from the queue if we encounter a duplicate value\n\t\t* (we keep popping until queue is empty or we see the duplicate value)\n\t* Finally, we have `O(n)`\n\n---\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n                        \n        queue = collections.deque([])        \n        window = set()\n        result = 0\n        \n        for c in s:            \n            if c in window:\n                while queue:\n                    prev = queue.popleft()\n                    window.remove(prev)\n                    if prev == c:\n                        break\n                            \n            queue.append(c)\n            window.add(c)\n            result = max(result, len(window))\n            \n        return result\n```\n---, status: null, voteStatus: 0, voteCount: 11, creationDate: 1613842611, isHidden: null, author: {username: dev-josh, isActive: true, nameColor: null, activeBadge: {displayName: Annual Medal 2021, icon: https://assets.leetcode.com/static_assets/others/annual-badge-2021-front.png}, profile: {userAvatar: https://assets.leetcode.com/users/dev-josh/avatar_1612114362.png, reputation: 705}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 1875, solutions: [{id: 4070500, title: âœ…99%ðŸ”¥||âœ…Journey From Brute Force to Most ðŸ”¥Optimized âœ…Three Approaches||ðŸ”¥Easy to understand, commentCount: 65, topLevelCommentCount: 29, viewCount: 107146, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Two Pointers, slug: two-pointers}, {name: Binary Search, slug: binary-search}, {name: Sorting, slug: sorting}], post: {id: 6140276, content: # Problem Understanding:\nIn simpler terms, you need to **find the middle value of the combined**, sorted array formed by merging nums1 and nums2. If the combined **array has an even number** of elements, you should return the average of the two middle values. **If it has an odd number of elements, you should return the middle value itself.**\n<!-- Describe your first thoughts on how to solve this problem. -->\n# Hint:\n```Hint1 []\nThink of a brute force approach.\n```\n```Hint2 []\nDo you think how two pointer will help us?\n```\n```Hint3 []\nCan you observe the fact that the given arrays are sorted?\n```\n**I would recommend you, don\'t jump directly on solution.**\n# Approach 1: Merge and Sort\n- **Create a new array** with a size equal to the total number of elements in both input arrays.\n- **Insert elements** from both input arrays into the new array.\n- **Sort the new array.**\n- **Find and return the median of the sorted array.**\n\n**Time Complexity**\n- In the worst case TC is **O((n + m) * log(n + m))**.\n\n**Space Complexity**\n - **O(n + m)**, where \u2018n\u2019 and \u2018m\u2019 are the sizes of the arrays.\n# Approach 2: Two-Pointer Method\n\n- **Initialize two pointers**, i and j, both initially set to 0.\n- **Move the pointer** that corresponds to the **smaller value forward at each step.**\n- Continue moving the pointers **until you have processed half of the total number of elements.**\n- Calculate and **return the median** based on the values pointed to by i and j.\n\n\n**Time Complexity**\n- **O(n + m)**, where \u2018n\u2019 & \u2018m\u2019 are the sizes of the two arrays.\n\n**Space Complexity**\n - **O(1)**.\n\n# Approach 3: Binary Search\n\n- **Use binary search to partition the smaller of the two input arrays into two parts.**\n- Find the partition of the **larger array such that the sum of elements on the left side of the partition in both arrays is half of the total elements.**\n- Check if this partition **is valid by verifying** if the largest number on the left side is smaller than the smallest number on the right side.\n- **If the partition is valid,** calculate and return the median.\n\n**Time Complexity**\n- **O(logm/logn)**\n\n**Space Complexity**\n - **O(1)**\n\n---\n\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\uD83D\uDE0A\uD83D\uDE0A\n\n---\n\n\n<!-- Describe your approach to solving the problem. -->\n# Code Brute Force- Merge and Sort\n```C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Get the sizes of both input arrays.\n        int n = nums1.size();\n        int m = nums2.size();\n\n        // Merge the arrays into a single sorted array.\n        vector<int> merged;\n        for (int i = 0; i < n; i++) {\n            merged.push_back(nums1[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            merged.push_back(nums2[i]);\n        }\n\n        // Sort the merged array.\n        sort(merged.begin(), merged.end());\n\n        // Calculate the total number of elements in the merged array.\n        int total = merged.size();\n\n        if (total % 2 == 1) {\n            // If the total number of elements is odd, return the middle element as the median.\n            return static_cast<double>(merged[total / 2]);\n        } else {\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\n            int middle1 = merged[total / 2 - 1];\n            int middle2 = merged[total / 2];\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\n        }\n    }\n};\n\n```\n```Java []\nimport java.util.Arrays;\n\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // Get the sizes of both input arrays.\n        int n = nums1.length;\n        int m = nums2.length;\n\n        // Merge the arrays into a single sorted array.\n        int[] merged = new int[n + m];\n        int k = 0;\n        for (int i = 0; i < n; i++) {\n            merged[k++] = nums1[i];\n        }\n        for (int i = 0; i < m; i++) {\n            merged[k++] = nums2[i];\n        }\n\n        // Sort the merged array.\n        Arrays.sort(merged);\n\n        // Calculate the total number of elements in the merged array.\n        int total = merged.length;\n\n        if (total % 2 == 1) {\n            // If the total number of elements is odd, return the middle element as the median.\n            return (double) merged[total / 2];\n        } else {\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\n            int middle1 = merged[total / 2 - 1];\n            int middle2 = merged[total / 2];\n            return ((double) middle1 + (double) middle2) / 2.0;\n        }\n    }\n}\n\n```\n```python3 []\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # Merge the arrays into a single sorted array.\n        merged = nums1 + nums2\n\n        # Sort the merged array.\n        merged.sort()\n\n        # Calculate the total number of elements in the merged array.\n        total = len(merged)\n\n        if total % 2 == 1:\n            # If the total number of elements is odd, return the middle element as the median.\n            return float(merged[total // 2])\n        else:\n            # If the total number of elements is even, calculate the average of the two middle elements as the median.\n            middle1 = merged[total // 2 - 1]\n            middle2 = merged[total // 2]\n            return (float(middle1) + float(middle2)) / 2.0\n\n```\n\n\n# Code for Two-Pointer Method\n```C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        int m = nums2.size();\n        int i = 0, j = 0, m1 = 0, m2 = 0;\n\n        // Find median.\n        for (int count = 0; count <= (n + m) / 2; count++) {\n            m2 = m1;\n            if (i != n && j != m) {\n                if (nums1[i] > nums2[j]) {\n                    m1 = nums2[j++];\n                } else {\n                    m1 = nums1[i++];\n                }\n            } else if (i < n) {\n                m1 = nums1[i++];\n            } else {\n                m1 = nums2[j++];\n            }\n        }\n\n        // Check if the sum of n and m is odd.\n        if ((n + m) % 2 == 1) {\n            return static_cast<double>(m1);\n        } else {\n            double ans = static_cast<double>(m1) + static_cast<double>(m2);\n            return ans / 2.0;\n        }\n    }\n};\n\n```\n```Java []\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int i = 0, j = 0, m1 = 0, m2 = 0;\n\n        // Find median.\n        for (int count = 0; count <= (n + m) / 2; count++) {\n            m2 = m1;\n            if (i != n && j != m) {\n                if (nums1[i] > nums2[j]) {\n                    m1 = nums2[j++];\n                } else {\n                    m1 = nums1[i++];\n                }\n            } else if (i < n) {\n                m1 = nums1[i++];\n            } else {\n                m1 = nums2[j++];\n            }\n        }\n\n        // Check if the sum of n and m is odd.\n        if ((n + m) % 2 == 1) {\n            return (double) m1;\n        } else {\n            double ans = (double) m1 + (double) m2;\n            return ans / 2.0;\n        }\n    }\n}\n\n```\n```python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        n = len(nums1)\n        m = len(nums2)\n        i = 0\n        j = 0\n        m1 = 0\n        m2 = 0\n\n        # Find median.\n        for count in range(0, (n + m) // 2 + 1):\n            m2 = m1\n            if i < n and j < m:\n                if nums1[i] > nums2[j]:\n                    m1 = nums2[j]\n                    j += 1\n                else:\n                    m1 = nums1[i]\n                    i += 1\n            elif i < n:\n                m1 = nums1[i]\n                i += 1\n            else:\n                m1 = nums2[j]\n                j += 1\n\n        # Check if the sum of n and m is odd.\n        if (n + m) % 2 == 1:\n            return float(m1)\n        else:\n            ans = float(m1) + float(m2)\n            return ans / 2.0\n\n```\n\n\n#  Code for Binary Search\n```C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\n        int n1 = nums1.size(), n2 = nums2.size();\n        \n        // Ensure nums1 is the smaller array for simplicity\n        if (n1 > n2)\n            return findMedianSortedArrays(nums2, nums1);\n        \n        int n = n1 + n2;\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\n        int low = 0, high = n1;\n        \n        while (low <= high) {\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\n            int mid2 = left - mid1; // Calculate mid index for nums2\n            \n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\n            \n            // Determine values of l1, l2, r1, and r2\n            if (mid1 < n1)\n                r1 = nums1[mid1];\n            if (mid2 < n2)\n                r2 = nums2[mid2];\n            if (mid1 - 1 >= 0)\n                l1 = nums1[mid1 - 1];\n            if (mid2 - 1 >= 0)\n                l2 = nums2[mid2 - 1];\n            \n            if (l1 <= r2 && l2 <= r1) {\n                // The partition is correct, we found the median\n                if (n % 2 == 1)\n                    return max(l1, l2);\n                else\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\n            }\n            else if (l1 > r2) {\n                // Move towards the left side of nums1\n                high = mid1 - 1;\n            }\n            else {\n                // Move towards the right side of nums1\n                low = mid1 + 1;\n            }\n        }\n        \n        return 0; // If the code reaches here, the input arrays were not sorted.\n    }\n};\n\n\n```\n```Java []\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1 = nums1.length, n2 = nums2.length;\n        \n        // Ensure nums1 is the smaller array for simplicity\n        if (n1 > n2)\n            return findMedianSortedArrays(nums2, nums1);\n        \n        int n = n1 + n2;\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\n        int low = 0, high = n1;\n        \n        while (low <= high) {\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\n            int mid2 = left - mid1; // Calculate mid index for nums2\n            \n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE, r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\n            \n            // Determine values of l1, l2, r1, and r2\n            if (mid1 < n1)\n                r1 = nums1[mid1];\n            if (mid2 < n2)\n                r2 = nums2[mid2];\n            if (mid1 - 1 >= 0)\n                l1 = nums1[mid1 - 1];\n            if (mid2 - 1 >= 0)\n                l2 = nums2[mid2 - 1];\n            \n            if (l1 <= r2 && l2 <= r1) {\n                // The partition is correct, we found the median\n                if (n % 2 == 1)\n                    return Math.max(l1, l2);\n                else\n                    return ((double)(Math.max(l1, l2) + Math.min(r1, r2))) / 2.0;\n            }\n            else if (l1 > r2) {\n                // Move towards the left side of nums1\n                high = mid1 - 1;\n            }\n            else {\n                // Move towards the right side of nums1\n                low = mid1 + 1;\n            }\n        }\n        \n        return 0; // If the code reaches here, the input arrays were not sorted.\n    }\n}\n\n```\n```python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        n1 = len(nums1)\n        n2 = len(nums2)\n        \n        # Ensure nums1 is the smaller array for simplicity\n        if n1 > n2:\n            return self.findMedianSortedArrays(nums2, nums1)\n        \n        n = n1 + n2\n        left = (n1 + n2 + 1) // 2 # Calculate the left partition size\n        low = 0\n        high = n1\n        \n        while low <= high:\n            mid1 = (low + high) // 2 # Calculate mid index for nums1\n            mid2 = left - mid1 # Calculate mid index for nums2\n            \n            l1 = float(\'-inf\')\n            l2 = float(\'-inf\')\n            r1 = float(\'inf\')\n            r2 = float(\'inf\')\n            \n            # Determine values of l1, l2, r1, and r2\n            if mid1 < n1:\n                r1 = nums1[mid1]\n            if mid2 < n2:\n                r2 = nums2[mid2]\n            if mid1 - 1 >= 0:\n                l1 = nums1[mid1 - 1]\n            if mid2 - 1 >= 0:\n                l2 = nums2[mid2 - 1]\n            \n            if l1 <= r2 and l2 <= r1:\n                # The partition is correct, we found the median\n                if n % 2 == 1:\n                    return max(l1, l2)\n                else:\n                    return (max(l1, l2) + min(r1, r2)) / 2.0\n            elif l1 > r2:\n                # Move towards the left side of nums1\n                high = mid1 - 1\n            else:\n                # Move towards the right side of nums1\n                low = mid1 + 1\n        \n        return 0 # If the code reaches here, the input arrays were not sorted.\n\n```\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\uD83D\uDE0A\uD83D\uDE0A\n![upvotememe.png](https://assets.leetcode.com/users/images/b5e325fa-1e56-45a4-9f5b-decc2bc50fc9_1695262468.8060796.png)\n\n\n, status: null, voteStatus: 0, voteCount: 1585, creationDate: 1695260906, isHidden: null, author: {username: singh_sidhant, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1703164891.png, reputation: 4370}}}, searchMeta: null}, {id: 4070371, title: âœ… 94.96% Binary Search & Two Pointers, commentCount: 13, topLevelCommentCount: 10, viewCount: 21040, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}, {name: Go, slug: golang}, {name: Rust, slug: rust}, {name: PHP, slug: php}, {name: Two Pointers, slug: two-pointers}, {name: Binary Search, slug: binary-search}], post: {id: 6140102, content: # Comprehensive Guide to Solving "Median of Two Sorted Arrays"\n\n## Introduction & Problem Statement\n\n"Median of Two Sorted Arrays" is a classic problem that tests one\'s algorithmic depth and understanding of binary search and two-pointer techniques. The challenge is to find the median of two sorted arrays, `nums1` and `nums2`, with potentially different sizes. The objective is to solve it in logarithmic time complexity in terms of the minimum size of the two arrays.\n\n## Key Concepts and Constraints\n\n### What Makes This Problem Unique?\n\n1. **Array Constraints**:  \n    - The length of `nums1` (denoted as $$ m $$) can range from 0 to 1000.\n    - The length of `nums2` (denoted as $$ n $$) can also vary between 0 and 1000.\n    - The combined size (i.e., $$ m + n $$) of both arrays can go up to 2000.\n  \n2. **Element Constraints**:\n    - Each element in both `nums1` and `nums2` can be any integer from -$$ 10^6 $$ to $$ 10^6 $$.\n\n3. **Runtime Complexity**:  \n    The primary challenge is to achieve a runtime of $$ O(\\log(\\min(m, n))) $$. This constraint rules out naive solutions that might merge and then find the median.\n\n### Solution Strategies:\n\n1. **Two Pointers Approach**:  \n    This technique involves iterating through both arrays using two pointers. By comparing the elements at the current pointers, we can merge the two arrays. Once merged, finding the median is straightforward.\n\n2. **Binary Search Approach**:  \n    Leveraging the properties of sorted arrays, we can apply a binary search on the smaller array, effectively partitioning both arrays. This method ensures we find the median without explicitly merging the arrays, adhering to the desired logarithmic time complexity.\n\n---\n\n## Live Coding Binary Search & Explain \nhttps://youtu.be/9LZcuEBjD9o?si=5A6xTTLfH0HW0kal\n\n## Strategy to Solve the Problem:\n\n## Two Pointers Merging Technique\n\nThe core idea here is to merge the two sorted arrays, nums1 and nums2, using a two-pointer approach. After merging, the median of the combined array can be found directly based on its length.\n\n## Key Data Structures:\n\n- `merged`: An array to store the merged result of `nums1` and `nums2`.\n- `i` and `j`: Two pointers to traverse `nums1` and `nums2` respectively.\n\n## Enhanced Breakdown:\n\n1. **Initialize Pointers**:\n   - Set `i` and `j` to 0. These pointers will help traverse `nums1` and `nums2`.\n\n2. **Merging using Two Pointers**:\n   - Merge elements of `nums1` and `nums2` in sorted order using two pointers. If an element in `nums1` is smaller, append it to `merged` and move the `i` pointer. Otherwise, append the element from `nums2` and move the `j` pointer.\n\n3. **Handle Remaining Elements**:\n   - If there are any remaining elements in `nums1` or `nums2`, append them directly to `merged`.\n\n4. **Calculate Median**:\n   - Based on the length of `merged`, compute the median. If the length is even, the median is the average of the two middle elements. Otherwise, it\'s the middle element.\n\n## Complexity Analysis:\n\n**Time Complexity**: \n- The merging process traverses both arrays once, resulting in a time complexity of $$ O(m + n) $$, where $$ m $$ and $$ n $$ are the lengths of `nums1` and `nums2` respectively.\n\n**Space Complexity**: \n- The algorithm creates a merged array of length $$ m + n $$, leading to a space complexity of $$ O(m + n) $$.\n\n\n## Code Two Pointers\n``` Python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        merged = []\n        i, j = 0, 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n                \n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n            \n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        mid = len(merged) // 2\n        if len(merged) % 2 == 0:\n            return (merged[mid-1] + merged[mid]) / 2\n        else:\n            return merged[mid]\n\n```\n``` Go []\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    merged := make([]int, 0, len(nums1)+len(nums2))\n    i, j := 0, 0\n\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] < nums2[j] {\n            merged = append(merged, nums1[i])\n            i++\n        } else {\n            merged = append(merged, nums2[j])\n            j++\n        }\n    }\n\n    for i < len(nums1) {\n        merged = append(merged, nums1[i])\n        i++\n    }\n    for j < len(nums2) {\n        merged = append(merged, nums2[j])\n        j++\n    }\n\n    mid := len(merged) / 2\n    if len(merged)%2 == 0 {\n        return (float64(merged[mid-1]) + float64(merged[mid])) / 2.0\n    } else {\n        return float64(merged[mid])\n    }\n}\n```\n``` Rust []\nimpl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        let mut merged: Vec<i32> = Vec::new();\n        let (mut i, mut j) = (0, 0);\n        \n        while i < nums1.len() && j < nums2.len() {\n            if nums1[i] < nums2[j] {\n                merged.push(nums1[i]);\n                i += 1;\n            } else {\n                merged.push(nums2[j]);\n                j += 1;\n            }\n        }\n        \n        while i < nums1.len() {\n            merged.push(nums1[i]);\n            i += 1;\n        }\n        while j < nums2.len() {\n            merged.push(nums2[j]);\n            j += 1;\n        }\n        \n        let mid = merged.len() / 2;\n        if merged.len() % 2 == 0 {\n            return (merged[mid-1] + merged[mid]) as f64 / 2.0;\n        } else {\n            return merged[mid] as f64;\n        }\n    }\n}\n```\n``` C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> merged;\n        int i = 0, j = 0;\n        \n        while (i < nums1.size() && j < nums2.size()) {\n            if (nums1[i] < nums2[j]) {\n                merged.push_back(nums1[i++]);\n            } else {\n                merged.push_back(nums2[j++]);\n            }\n        }\n        \n        while (i < nums1.size()) merged.push_back(nums1[i++]);\n        while (j < nums2.size()) merged.push_back(nums2[j++]);\n        \n        int mid = merged.size() / 2;\n        if (merged.size() % 2 == 0) {\n            return (merged[mid-1] + merged[mid]) / 2.0;\n        } else {\n            return merged[mid];\n        }\n    }\n};\n```\n``` Java []\npublic class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        List<Integer> merged = new ArrayList<>();\n        int i = 0, j = 0;\n        \n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] < nums2[j]) {\n                merged.add(nums1[i++]);\n            } else {\n                merged.add(nums2[j++]);\n            }\n        }\n        \n        while (i < nums1.length) merged.add(nums1[i++]);\n        while (j < nums2.length) merged.add(nums2[j++]);\n        \n        int mid = merged.size() / 2;\n        if (merged.size() % 2 == 0) {\n            return (merged.get(mid-1) + merged.get(mid)) / 2.0;\n        } else {\n            return merged.get(mid);\n        }\n    }\n}\n```\n``` C# []\npublic class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        List<int> merged = new List<int>();\n        int i = 0, j = 0;\n        \n        while (i < nums1.Length && j < nums2.Length) {\n            if (nums1[i] < nums2[j]) {\n                merged.Add(nums1[i++]);\n            } else {\n                merged.Add(nums2[j++]);\n            }\n        }\n        \n        while (i < nums1.Length) merged.Add(nums1[i++]);\n        while (j < nums2.Length) merged.Add(nums2[j++]);\n        \n        int mid = merged.Count / 2;\n        if (merged.Count % 2 == 0) {\n            return (merged[mid-1] + merged[mid]) / 2.0;\n        } else {\n            return merged[mid];\n        }\n    }\n}\n```\n``` JavaScript []\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    let merged = [];\n    let i = 0, j = 0;\n\n    while (i < nums1.length && j < nums2.length) {\n        if (nums1[i] < nums2[j]) {\n            merged.push(nums1[i++]);\n        } else {\n            merged.push(nums2[j++]);\n        }\n    }\n\n    while (i < nums1.length) merged.push(nums1[i++]);\n    while (j < nums2.length) merged.push(nums2[j++]);\n\n    let mid = Math.floor(merged.length / 2);\n    if (merged.length % 2 === 0) {\n        return (merged[mid-1] + merged[mid]) / 2;\n    } else {\n        return merged[mid];\n    }\n};\n```\n``` PHP []\nclass Solution {\n\n    function findMedianSortedArrays($nums1, $nums2) {\n        $merged = array();\n        $i = $j = 0;\n\n        while ($i < count($nums1) && $j < count($nums2)) {\n            if ($nums1[$i] < $nums2[$j]) {\n                array_push($merged, $nums1[$i++]);\n            } else {\n                array_push($merged, $nums2[$j++]);\n            }\n        }\n\n        while ($i < count($nums1)) array_push($merged, $nums1[$i++]);\n        while ($j < count($nums2)) array_push($merged, $nums2[$j++]);\n\n        $mid = intdiv(count($merged), 2);\n        if (count($merged) % 2 == 0) {\n            return ($merged[$mid-1] + $merged[$mid]) / 2;\n        } else {\n            return $merged[$mid];\n        }\n    }\n}\n```\n\n---\n\n## Binary Search with Partitioning\n\nThe problem can be elegantly solved using binary search by partitioning the two arrays such that elements on the left are smaller or equal to elements on the right.\n\n## Key Data Structures:\n\n- `partitionX` and `partitionY`: To store the partition indices for `nums1` and `nums2` respectively.\n- `maxX`, `minX`, `maxY`, `minY`: To store the values around the partition in both arrays.\n\n## Enhanced Breakdown:\n\n1. **Initialize and Swap Arrays if Needed**:\n   - Swap `nums1` and `nums2` if `nums1` is larger. This ensures we always binary search the smaller array, optimizing the time complexity.\n\n2. **Binary Search Setup**:\n   - Initialize `low` to 0 and `high` to the size of the smaller array.\n  \n3. **Start Binary Search Loop**:\n   - The loop continues until `low` is not greater than `high`.\n   - Calculate `partitionX` and `partitionY` based on `low` and `high`.\n\n4. **Calculate Partition Values**:\n   - Compute `maxX`, `minX`, `maxY`, `minY` based on the partitions.\n  \n5. **Check for Correct Partition**:\n   - If `maxX <= minY` and `maxY <= minX`, we have found the correct partition.\n   - Calculate and return the median based on the values around the partition.\n\n6. **Adjust Binary Search Bounds**:\n   - If `maxX > minY`, adjust `high` to `partitionX - 1`.\n   - Otherwise, adjust `low` to `partitionX + 1`.\n\n## Complexity Analysis:\n\n**Time Complexity**: \n- The algorithm performs a binary search on the smaller array, leading to a time complexity of $$ O(\\log(\\min(m, n))) $$.\n\n**Space Complexity**: \n- The algorithm uses only a constant amount of extra space, thus having a space complexity of $$ O(1) $$.\n\n# Code Binary Search\n``` Python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        low, high = 0, m\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (m + n + 1) // 2 - partitionX\n            \n            maxX = float(\'-inf\') if partitionX == 0 else nums1[partitionX - 1]\n            maxY = float(\'-inf\') if partitionY == 0 else nums2[partitionY - 1]\n            minX = float(\'inf\') if partitionX == m else nums1[partitionX]\n            minY = float(\'inf\') if partitionY == n else nums2[partitionY]\n            \n            if maxX <= minY and maxY <= minX:\n                if (m + n) % 2 == 0:\n                    return (max(maxX, maxY) + min(minX, minY)) / 2\n                else:\n                    return max(maxX, maxY)\n            elif maxX > minY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n```\n``` Go []\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n\tif len(nums1) > len(nums2) {\n\t\tnums1, nums2 = nums2, nums1\n\t}\n\n\tm, n := len(nums1), len(nums2)\n\tlow, high := 0, m\n\n\tfor low <= high {\n\t\tpartitionX := (low + high) / 2\n\t\tpartitionY := (m + n + 1) / 2 - partitionX\n\n\t\tmaxX := math.MinInt64\n\t\tif partitionX > 0 {\n\t\t\tmaxX = nums1[partitionX-1]\n\t\t}\n\n\t\tminX := math.MaxInt64\n\t\tif partitionX < m {\n\t\t\tminX = nums1[partitionX]\n\t\t}\n\n\t\tmaxY := math.MinInt64\n\t\tif partitionY > 0 {\n\t\t\tmaxY = nums2[partitionY-1]\n\t\t}\n\n\t\tminY := math.MaxInt64\n\t\tif partitionY < n {\n\t\t\tminY = nums2[partitionY]\n\t\t}\n\n\t\tif maxX <= minY && maxY <= minX {\n\t\t\tif (m+n)%2 == 0 {\n\t\t\t\treturn (float64(max(maxX, maxY)) + float64(min(minX, minY))) / 2.0\n\t\t\t}\n\t\t\treturn float64(max(maxX, maxY))\n\t\t} else if maxX > minY {\n\t\t\thigh = partitionX - 1\n\t\t} else {\n\t\t\tlow = partitionX + 1\n\t\t}\n\t}\n\n\treturn 0.0\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n``` Rust []\nimpl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        let (mut nums1, mut nums2) = if nums1.len() > nums2.len() {\n            (nums2, nums1)\n        } else {\n            (nums1, nums2)\n        };\n        \n        let (m, n) = (nums1.len(), nums2.len());\n        let (mut low, mut high) = (0, m);\n        \n        while low <= high {\n            let partition_x = (low + high) / 2;\n            let partition_y = (m + n + 1) / 2 - partition_x;\n            \n            let max_x = if partition_x == 0 { i32::MIN } else { nums1[partition_x - 1] };\n            let min_x = if partition_x == m { i32::MAX } else { nums1[partition_x] };\n            \n            let max_y = if partition_y == 0 { i32::MIN } else { nums2[partition_y - 1] };\n            let min_y = if partition_y == n { i32::MAX } else { nums2[partition_y] };\n            \n            if max_x <= min_y && max_y <= min_x {\n                if (m + n) % 2 == 0 {\n                    return (max_x.max(max_y) + min_x.min(min_y)) as f64 / 2.0;\n                } else {\n                    return max_x.max(max_y) as f64;\n                }\n            } else if max_x > min_y {\n                high = partition_x - 1;\n            } else {\n                low = partition_x + 1;\n            }\n        }\n        \n        0.0\n    }\n}\n```\n``` C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            swap(nums1, nums2);\n        }\n        \n        int m = nums1.size();\n        int n = nums2.size();\n        int low = 0, high = m;\n        \n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (m + n + 1) / 2 - partitionX;\n            \n            int maxX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n            int maxY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n            \n            int minX = (partitionX == m) ? INT_MAX : nums1[partitionX];\n            int minY = (partitionY == n) ? INT_MAX : nums2[partitionY];\n            \n            if (maxX <= minY && maxY <= minX) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxX, maxY) + min(minX, minY)) / 2.0;\n                } else {\n                    return max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        \n        throw invalid_argument("Input arrays are not sorted.");\n    }\n};\n```\n``` Java []\npublic class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            int[] temp = nums1;\n            nums1 = nums2;\n            nums2 = temp;\n        }\n        \n        int m = nums1.length;\n        int n = nums2.length;\n        int low = 0, high = m;\n        \n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (m + n + 1) / 2 - partitionX;\n            \n            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            \n            int minX = (partitionX == m) ? Integer.MAX_VALUE : nums1[partitionX];\n            int minY = (partitionY == n) ? Integer.MAX_VALUE : nums2[partitionY];\n            \n            if (maxX <= minY && maxY <= minX) {\n                if ((m + n) % 2 == 0) {\n                    return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2.0;\n                } else {\n                    return Math.max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        \n        throw new IllegalArgumentException("Input arrays are not sorted.");\n    }\n}\n```\n``` C# []\npublic class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.Length > nums2.Length) {\n            int[] temp = nums1;\n            nums1 = nums2;\n            nums2 = temp;\n        }\n        \n        int m = nums1.Length;\n        int n = nums2.Length;\n        int low = 0, high = m;\n        \n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (m + n + 1) / 2 - partitionX;\n            \n            int maxX = (partitionX == 0) ? int.MinValue : nums1[partitionX - 1];\n            int maxY = (partitionY == 0) ? int.MinValue : nums2[partitionY - 1];\n            \n            int minX = (partitionX == m) ? int.MaxValue : nums1[partitionX];\n            int minY = (partitionY == n) ? int.MaxValue : nums2[partitionY];\n            \n            if (maxX <= minY && maxY <= minX) {\n                if ((m + n) % 2 == 0) {\n                    return (Math.Max(maxX, maxY) + Math.Min(minX, minY)) / 2.0;\n                } else {\n                    return Math.Max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        \n        throw new ArgumentException("Input arrays are not sorted.");\n    }\n}\n```\n``` JavaScript []\nvar findMedianSortedArrays = function(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        [nums1, nums2] = [nums2, nums1];\n    }\n    \n    const m = nums1.length;\n    const n = nums2.length;\n    let low = 0, high = m;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((m + n + 1) / 2) - partitionX;\n        \n        const maxX = (partitionX === 0) ? Number.MIN_SAFE_INTEGER : nums1[partitionX - 1];\n        const maxY = (partitionY === 0) ? Number.MIN_SAFE_INTEGER : nums2[partitionY - 1];\n        \n        const minX = (partitionX === m) ? Number.MAX_SAFE_INTEGER : nums1[partitionX];\n        const minY = (partitionY === n) ? Number.MAX_SAFE_INTEGER : nums2[partitionY];\n        \n        if (maxX <= minY && maxY <= minX) {\n            if ((m + n) % 2 === 0) {\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n    \n    throw new Error("Input arrays are not sorted.");\n};\n```\n``` PHP []\nclass Solution {\n    function findMedianSortedArrays($nums1, $nums2) {\n        if (count($nums1) > count($nums2)) {\n            list($nums1, $nums2) = [$nums2, $nums1];\n        }\n        \n        $m = count($nums1);\n        $n = count($nums2);\n        $low = 0; $high = $m;\n        \n        while ($low <= $high) {\n            $partitionX = intdiv($low + $high, 2);\n            $partitionY = intdiv($m + $n + 1, 2) - $partitionX;\n            \n            $maxX = ($partitionX == 0) ? PHP_INT_MIN : $nums1[$partitionX - 1];\n            $maxY = ($partitionY == 0) ? PHP_INT_MIN : $nums2[$partitionY - 1];\n            \n            $minX = ($partitionX == $m) ? PHP_INT_MAX : $nums1[$partitionX];\n            $minY = ($partitionY == $n) ? PHP_INT_MAX : $nums2[$partitionY];\n            \n            if ($maxX <= $minY && $maxY <= $minX) {\n                if (($m + $n) % 2 == 0) {\n                    return (max($maxX, $maxY) + min($minX, $minY)) / 2.0;\n                } else {\n                    return max($maxX, $maxY);\n                }\n            } elseif ($maxX > $minY) {\n                $high = $partitionX - 1;\n            } else {\n                $low = $partitionX + 1;\n            }\n        }\n        \n        throw new Exception("Input arrays are not sorted.");\n    }\n}\n```\n\n## Performance\n\n| Language  | Execution Time (ms) | Memory Usage (MB) |\n|-----------|---------------------|--------------------|\n| Rust      | 0                   | 2                  |\n| Java      | 1                   | 44.5               |\n| Go        | 9                   | 5.1                |\n| C++       | 16                  | 89.6               |\n| PHP       | 28                  | 18.9               |\n| Python3   | 80                  | 16.5               |\n| JavaScript| 85                  | 46.6               |\n| Python3 (Two Pointers)  | 93                  | 16.5               |\n| C#        | 98                  | 52.1               |\n\n![v45.png](https://assets.leetcode.com/users/images/966f2e2c-e145-4ea8-b135-e7091043284c_1695295269.6517363.png)\n\n\n## Live Coding in Rust - 0 ms \nhttps://youtu.be/i7qROr8VOuA?si=sjYuouuMThe8BUAM\n\n## Conclusion\n\nBoth strategies have their own unique benefits. While the two-pointers approach offers simplicity and clarity, the binary search approach showcases efficiency and mastery over the properties of sorted arrays. Choosing between them depends on the specific constraints and requirements of a given scenario., status: null, voteStatus: 0, voteCount: 92, creationDate: 1695255106, isHidden: null, author: {username: vanAmsen, isActive: true, nameColor: null, activeBadge: {displayName: Sep LeetCoding Challenge, icon: /static/images/badges/dcc-2023-9.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1684156727.png, reputation: 10614}}}, searchMeta: null}, {id: 4070884, title: My thought process - O(log(min(N, M))) time, O(1) space - Python, JavaScript, Java, C++, commentCount: 2, topLevelCommentCount: 2, viewCount: 2680, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 6140776, content: # Intuition\nWelcome to my article! This starts with `What is median?`. Understanding `median` is a key to solve this quesiton.\n\n---\n\n# Solution Video\n\nToday, I\'m going on business trip. This article is written in a train. lol\nIf I have a time tonight, I will create a solution video for this question.\n\nInstead of the video, I added more comments to the codes.\n\n### \u2B50\uFE0F\u2B50\uFE0F Don\'t forget to subscribe to my channel! \u2B50\uFE0F\u2B50\uFE0F\n\n**\u25A0 Subscribe URL**\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\nSubscribers: 2,423\nMy initial goal is 10,000\nThank you for your support!\n\n---\n\n# Approach\n\n## My thought process - How I think about a solution\n\n### What is `median`?\n\nFirst and foremost, we must understand what `median` is. Without this understanding, we cannot write a program.\n\n`The median is one of the measures of central tendency for data or a set, representing the value that is at the middle position.`\n\n-  In the case of an even-sized data set\n\nHowever, in the case of an even-sized data set, the arithmetic mean of the two middle values is taken.\n\nFor example, in a data set consisting of the ages of 6 individuals: `1, 2, 3, 5, 9, 11`, the median is `4 years old` (taking two middle values `3 + 5` and divide by `2`)\n\n- In the case of an odd-sized data set\n\nIn the case of an odd-sized data set, for example, in a data set consisting of the ages of 5 individuals: `10, 32, 96, 100, 105` years old, the median is `96 years old`, which is the value at the 3rd position from both the top and the bottom. If there are 2 more children aged `0`, making a total of 7 individuals `0, 0, 10, 32, 96, 100, 105`, the median becomes `32 years old`.\n\n### My first thought\nNow, I hope you understand what `median` is. Simply, when we convert `median` to program, we can write it like this.\n\nThis is Python code.\n```\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Merge the two sorted arrays\n        merged = sorted(nums1 + nums2)\n        length = len(merged)\n        \n        # Check if the total length is even or odd\n        if length % 2 == 0:\n            # If even, return the average of the two middle elements\n            return (merged[length // 2 - 1] + merged[length // 2]) / 2\n        else:\n            # If odd, return the middle element\n            return merged[length // 2]\n```\nIt\'s very simple right? In fact, this program passed all cases and execution time is not bad. Beats 68% when I ran the code. If we can use this code for this question. this is acutually easy problem.\n\nThat is my first thought.\n\n### We have a constraint\n\nBut we have a constrant about time complexity. Description says "The overall run time complexity should be `O(log(m+n))`", so we can\'t use my simple solution for this question, even if the simple solution passed all cases.\n\nWe need to find another solution.\n\nLet\'s focus on time complexity of the constraint. Time complexity of `O(log(m+n))` is a constraint, on the other hand, it should be a hint to solve the question. If you know time complexity well, you can guess a solution from `O(log(something))`.\n\nThat is time complexity of `binary search`. That\'s why I stated to focus on a binary search-based solution to find the median of two arrays.\n\nThat is my thoguht process to reach `binary search-based solution`.\n\n---\n\n# Solution\n\n### Algorithm overview:\n1. Ensure that nums1 is the smaller array.\n2. Calculate the lengths of the input arrays nums1 and nums2.\n3. Set the initial range for binary search on nums1 using the variables left and right.\n\n### Detailed Explanation:\n1. Check and swap nums1 and nums2 if nums1 is longer than nums2 to ensure nums1 is the smaller array.\n2. Calculate the lengths of nums1 and nums2 and store them in len1 and len2.\n3. Initialize the binary search range using left (0) and right (length of nums1).\n4. Enter a while loop that continues as long as the left pointer is less than or equal to the right pointer.\n5. Inside the loop:\n   a. Calculate the partition points for nums1 and nums2 based on the binary search.\n   b. Determine the maximum elements on the left side (max_left) and minimum elements on the right side (min_right) for both arrays.\n   c. Check if the current partition is correct by comparing max_left and min_right.\n   d. If the partition is correct:\n      - If the total length is even, return the average of max_left and min_right.\n      - If the total length is odd, return max_left.\n   e. If the partition is not correct, adjust the binary search range based on the comparison of max_left1 and min_right2.\n\nThis algorithm efficiently finds the median of two sorted arrays using a binary search approach to adjust the partition points and determine the correct position for the median.\n\n\n---\n\n\n# Complexity\n- Time complexity: O(log(min(N, M)))\nThe while loop performs binary search, and each iteration divides the search range in half. Thus, the time complexity is O(log(min(N, M))), where `N` is the length of nums1 and `M` is the length of nums2.\n\n- Space complexity: O(1)\nThe algorithm uses a constant amount of extra space for variables like `left`, `right`, `partition1`, `partition2`, `max_left1`, `max_left2`, `max_left`, `min_right1`, `min_right2`, and `min_right`. Therefore, the space complexity is O(1), indicating constant space usage irrespective of the input size.\n\n\n```python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        # Get the lengths of the two arrays\n        len1, len2 = len(nums1), len(nums2)\n        \n        # Set the range for binary search on nums1\n        left, right = 0, len1\n        \n        while left <= right:\n            # Partition nums1 and nums2\n            partition1 = (left + right) // 2\n            partition2 = (len1 + len2 + 1) // 2 - partition1\n            \n            # Find the maximum elements on the left of the partition\n            max_left1 = nums1[partition1-1] if partition1 > 0 else float(\'-inf\')\n            max_left2 = nums2[partition2-1] if partition2 > 0 else float(\'-inf\')\n            max_left = max(max_left1, max_left2)\n            \n            # Find the minimum elements on the right of the partition\n            min_right1 = nums1[partition1] if partition1 < len1 else float(\'inf\')\n            min_right2 = nums2[partition2] if partition2 < len2 else float(\'inf\')\n            min_right = min(min_right1, min_right2)\n            \n            # Check if the partition is correct\n            if max_left <= min_right:\n                # If the total length is even, return the average of the two middle elements\n                if (len1 + len2) % 2 == 0:\n                    return (max_left + min_right) / 2\n                # If the total length is odd, return the middle element\n                else:\n                    return max_left\n            elif max_left1 > min_right2:\n                right = partition1 - 1\n            else:\n                left = partition1 + 1\n```\n```javascript []\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    // Ensure nums1 is the smaller array\n    if (nums1.length > nums2.length) {\n        [nums1, nums2] = [nums2, nums1];\n    }\n\n    // Get the lengths of the two arrays\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n\n    // Set the range for binary search on nums1\n    let left = 0;\n    let right = len1;\n\n    while (left <= right) {\n        // Partition nums1 and nums2\n        const partition1 = Math.floor((left + right) / 2);\n        const partition2 = Math.floor((len1 + len2 + 1) / 2) - partition1;\n\n        // Find the maximum elements on the left of the partition\n        const maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : Number.NEGATIVE_INFINITY;\n        const maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : Number.NEGATIVE_INFINITY;\n        const maxLeft = Math.max(maxLeft1, maxLeft2);\n\n        // Find the minimum elements on the right of the partition\n        const minRight1 = partition1 < len1 ? nums1[partition1] : Number.POSITIVE_INFINITY;\n        const minRight2 = partition2 < len2 ? nums2[partition2] : Number.POSITIVE_INFINITY;\n        const minRight = Math.min(minRight1, minRight2);\n\n        // Check if the partition is correct\n        if (maxLeft <= minRight) {\n            // If the total length is even, return the average of the two middle elements\n            if ((len1 + len2) % 2 === 0) {\n                return (maxLeft + minRight) / 2;\n            }\n            // If the total length is odd, return the middle element\n            else {\n                return maxLeft;\n            }\n        } else if (maxLeft1 > minRight2) {\n            right = partition1 - 1;\n        } else {\n            left = partition1 + 1;\n        }\n    }    \n};\n```\n```java []\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // Ensure nums1 is the smaller array\n        if (nums1.length > nums2.length) {\n            int[] temp = nums1;\n            nums1 = nums2;\n            nums2 = temp;\n        }\n\n        // Get the lengths of the two arrays\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n\n        // Set the range for binary search on nums1\n        int left = 0;\n        int right = len1;\n\n        while (left <= right) {\n            // Partition nums1 and nums2\n            int partition1 = (left + right) / 2;\n            int partition2 = (len1 + len2 + 1) / 2 - partition1;\n\n            // Find the maximum elements on the left of the partition\n            int maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : Integer.MIN_VALUE;\n            int maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : Integer.MIN_VALUE;\n            int maxLeft = Math.max(maxLeft1, maxLeft2);\n\n            // Find the minimum elements on the right of the partition\n            int minRight1 = partition1 < len1 ? nums1[partition1] : Integer.MAX_VALUE;\n            int minRight2 = partition2 < len2 ? nums2[partition2] : Integer.MAX_VALUE;\n            int minRight = Math.min(minRight1, minRight2);\n\n            // Check if the partition is correct\n            if (maxLeft <= minRight) {\n                // If the total length is even, return the average of the two middle elements\n                if ((len1 + len2) % 2 == 0) {\n                    return (maxLeft + minRight) / 2.0;\n                }\n                // If the total length is odd, return the middle element\n                else {\n                    return maxLeft;\n                }\n            } else if (maxLeft1 > minRight2) {\n                right = partition1 - 1;\n            } else {\n                left = partition1 + 1;\n            }\n        }\n\n        return 0.0; // This should not be reached, just to satisfy Java\'s return requirements\n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Ensure nums1 is the smaller array\n        if (nums1.size() > nums2.size()) {\n            nums1.swap(nums2);\n        }\n\n        // Get the lengths of the two arrays\n        int len1 = nums1.size();\n        int len2 = nums2.size();\n\n        // Set the range for binary search on nums1\n        int left = 0;\n        int right = len1;\n\n        while (left <= right) {\n            // Partition nums1 and nums2\n            int partition1 = (left + right) / 2;\n            int partition2 = (len1 + len2 + 1) / 2 - partition1;\n\n            // Find the maximum elements on the left of the partition\n            int maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : INT_MIN;\n            int maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : INT_MIN;\n            int maxLeft = max(maxLeft1, maxLeft2);\n\n            // Find the minimum elements on the right of the partition\n            int minRight1 = partition1 < len1 ? nums1[partition1] : INT_MAX;\n            int minRight2 = partition2 < len2 ? nums2[partition2] : INT_MAX;\n            int minRight = min(minRight1, minRight2);\n\n            // Check if the partition is correct\n            if (maxLeft <= minRight) {\n                // If the total length is even, return the average of the two middle elements\n                if ((len1 + len2) % 2 == 0) {\n                    return (maxLeft + minRight) / 2.0;\n                }\n                // If the total length is odd, return the middle element\n                else {\n                    return maxLeft;\n                }\n            } else if (maxLeft1 > minRight2) {\n                right = partition1 - 1;\n            } else {\n                left = partition1 + 1;\n            }\n        }\n\n        return 0.0; // This should not be reached, just to satisfy C++\'s return requirements        \n    }\n};\n```\n\n---\n\n\nThank you for reading such a long article.\n\n\u2B50\uFE0F If you learn something from the article, please upvote it and don\'t forget to subscribe to my channel!\n\nMy next post for daily coding challenge on Sep 22, 2023\nhttps://leetcode.com/problems/is-subsequence/solutions/4074388/video-how-i-think-about-a-solution-ot-time-o1-space-python-javascript-java-c/\n, status: null, voteStatus: 0, voteCount: 38, creationDate: 1695271065, isHidden: null, author: {username: niits, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1698738357.png, reputation: 7282}}}, searchMeta: null}, {id: 949705, title: Python3 two pointer >96,21% runtime [commented], commentCount: 10, topLevelCommentCount: 6, viewCount: 10887, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Two Pointers, slug: two-pointers}], post: {id: 1726622, content: ```\nRuntime: 80 ms, faster than 96.21% of Python3 online submissions for Median of Two Sorted Arrays.\nMemory Usage: 14.5 MB, less than 41.24% of Python3 online submissions for Median of Two Sorted Arrays.\n```\n\nI took a rather easy approach. First generate a sorted list of the two input lists combined, then find the middle one (or middle two, and take the average of those). But you don\'t need to sort all of it, you just need to sort until you hit the middle.\n\n```\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n\t    # Get the lengths of both lists\n        l1,l2 = len(nums1), len(nums2)\n\t\t# Determine the middle\n        middle = (l1 + l2) / 2\n\t\t\n\t\t# EDGE CASE:\n\t\t# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of\n\t\t# that list is greater than the length of l2, otherwise return nums2[1]\n\t\tif middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])\n\n\t\t# Initialize 2 pointers\n        x =  y = 0\n\t\t# Initialize 2 values to store the previous and current value (in case of an even\n\t\t# amount of values, we need to average 2 values)\n        cur = prev = 0\n\t\t# Determine the amount of loops we need. If the middle is even, loop that amount + 1:\n\t\t# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1\n\t\t#            ^  ^ \n\t\t#            |  +-- cur\n\t\t#            +----- prev\n \t\t# If the middle is odd, loop that amount + 0.5\n\t\t# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5\n\t\t#            ^\n        #            +--- cur\n        loops = middle+1 if middle % 1 == 0 else middle+0.5\n\n\t\t# Walk forward the amount of loops\n        for _ in range(int(loops)):\n            # Store the value of cur in prev\n\t\t\tprev = cur\n\t\t\t# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))\n            if x == l1:\n\t\t\t    # Store nums2[y] in cur, \'cause we hit the end of nums1\n                cur =  nums2[y]\n\t\t\t\t# Move the y pointer one ahead\n                y += 1\n\t\t    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))\n            elif y == l2:\n\t\t\t    # Store nums1[x] in cur, \'cause we hit the end of nums2\n                cur =  nums1[x]\n\t\t\t\t# Move the x pointer one ahead\n                x += 1\n\t\t    # If the value in nums1 is bigger than the value in nums2\n            elif nums1[x] > nums2[y]:\n\t\t\t    # Store nums2[y] in cur, because it\'s the lowest value\n                cur =  nums2[y]\n\t\t\t\t# Move the y pointer one ahead\n                y += 1\n\t\t\t# If the value in nums2 is bigger than the value in nums1\n            else:\n\t\t\t\t# Store nums1[x] in, because it\'s the lowest value\n                cur =  nums1[x]\n\t\t\t\t# Move the x pointer one ahead\n                x += 1\n        \n\t\t# If middle is even\n        if middle % 1 == 0.0:\n\t\t\t# Return the average of the cur + prev values (which will return a float)\n            return (cur+prev)/2\n\t\t# If middle is odd\n        else:\n\t\t\t# Return the cur value, as a float\n            return float(cur)\n```\n\nIt might not be the most dense way to write it, but it\'s fairly readable, IMHO., status: null, voteStatus: 0, voteCount: 38, creationDate: 1606396048, isHidden: null, author: {username: tomhagen, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/tomhagen/avatar_1586624388.png, reputation: 47}}}, searchMeta: null}, {id: 1592457, title: Python O(m + n) time, O(1) space, commentCount: 4, topLevelCommentCount: 4, viewCount: 5139, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2754562, content: ```\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        mid = (m + n) // 2 + 1\n        prev2 = prev1 = None\n        i = j = 0\n\n        for _ in range(mid):\n            prev2 = prev1\n            if j == n or (i != m and nums1[i] <= nums2[j]):\n                prev1 = nums1[i]\n                i += 1\n            else:\n                prev1 = nums2[j]\n                j += 1\n        \n        return prev1 if (m + n) % 2 else (prev1 + prev2) / 2, status: null, voteStatus: 0, voteCount: 29, creationDate: 1637648387, isHidden: null, author: {username: derek-y, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg100.png}, profile: {userAvatar: https://assets.leetcode.com/users/derekyoungman65/avatar_1632234502.png, reputation: 384}}}, searchMeta: null}, {id: 3284038, title: Simplest Python solution with simplest explanation log(m+n), commentCount: 7, topLevelCommentCount: 4, viewCount: 19049, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Binary Tree, slug: binary-tree}], post: {id: 5116446, content: First we decompose this problem into simpler subproblems:\n1. Find a given index `idx` in a sorted `a+b` array. Let `len(a)=m`, `len(b)=n`, `l=m+n`. Having solution to this problem we can easily compute median as we just need to find: \na) `idx=l // 2` when `l` is odd as this is median index in odd length array \n\te.g. `[1,2,3], l = 3, idx = l//2 = 1`\nb) `idx=l//2` and `idx=l//2-1` when `l` is even as these are median indices in this case \n\t\te.g. `[1,2,3,4], l = 4, idx1 = l//2 = 2, idx2 = l//2-1 = 1`\n\t\n\t\tdef findMedianSortedArrays(self, a, b):\n\n\t\t\tl = len(a) + len(b)\n\n\t\t\tif l % 2:\n\t\t\t\treturn self.get_median(a, b, l // 2)\n\t\t\telse:\n\t\t\t\treturn (self.get_median(a, b, l // 2) + self.get_median(a, b, l // 2 - 1))  / 2\n\t\t\n2. Find recursively value at `idx` in `a+b` by cutting off part of `a` or `b` where `idx` is surely not present. \na) We take two indices `ai = len(a)//2` in array `a` and `bi = len(b)//2` in array `b`. They roughly cut both arrays in half which will lead to `log(m+n)` time complexity. Denoting `ma = a[ai]` and `mb = b[bi]` the two arrays look like:\n\n\t\ta=[????? ma *****]\n\t\tb=[........ mb ######]\n\n\t  where `?`,  `.`, `*` and `#` just visualize elements we do not know. \n\t b) We know the values `ma` and `mb`. Not to consider many sub-scenarios we make it so that `ma <= mb` i.e. \n\n\t\t if ma > mb:\n\t\t\tma, mb = mb, ma\n\t\t\tai, bi = bi, ai\n\t\t\ta, b = b, a\n\n\t Thanks to this simplification we will always be able to either cut off beginning of array `a` or end of array `b` as will be explained below.\n\t \n\tc) Now the rough visualization of combined array is:\n\t\n\t\ta+b=[&&&&&& ma &&&& mb &&&&&&]\n\t\t\t\n\tWhere `&` is composed of  `?`,  `.`, `*` and `#` in some way. How exactly we cannot say but we can at least place them with respect to `ma` and `mb`: \n\t\n\t\ta+b=[.??.?.?.?? ma **.*.**.. mb ##*##**#*#]\n\t\t\n\tNotice that we have three parts here: `.??.?.?.??`, `**.*.**..` and `##*##**#*#`.\n\t\n\td) Now what can be the maximum possible index of `ma` in `a+b` array? This is if all `.` were to the left of `ma` i.e.\n\t\n\t\ta+b=[.??.?.?.?? ma ***** mb ##*##**#*#]\n\t\n\tthen `len(?????) = len(a)//2`,   `len(......) = len(b)//2` so\n\t`max_idx_ma = len(a) // 2 + len(b) // 2`\n\t\n\te) Now if `max_idx_ma < idx` then we know that index we are looking for is surely not located among `?????? ma` i.e. left part of array `a` because it is located in \n\t`***** mb ##*##**#*#` part of array a+b. So we can just cut this part off and repeat the reasoning in `2.` on `a[ai+1:]`, `b`, `idx - (len(??????) + 1) = idx - (len(a)//2 + 1)` (`+1` because we also throw out `ma`).\n\t\n\tf) Else we know that `max_idx_ma >= idx`. In other words in `a+b` array\n\t\n\t\ta+b=[.??.?.?.?? ma ***** mb ##*##**#*#]\n\t\n\t `idx` is located in `.??.?.?.?? ma` part. Whatever the length of `*****` because `ma` and `mb` are two different elements in a sorted array `a+b` and `ma <= mb`:\n\t \n\t\tmax_idx_ma  < min_idx_mb\n\t \n\t and\n\t \n\t\tidx <= max_idx_ma  < min_idx_mb\n\t \n\t which means that we can throw away `mb ######` part of `b` array in this case and consider new problem on `a`, `b[:bi]`, `idx`. \n\t \nRemarks:\n1. Without simplification in `1.` we need to be looking for two indices and considering total lenght of the array which greatly complicates solution. \n2. Without simplification in `2. b)` we would need to consider 4 subcases depending on relative values of `ma` and `mb`.\n3. A very important point is that we throw out `ma` or `mb` every time we cut off. This way we make sure that we always throw out at leas one element making it possible to reach the point where either `a` is empty or `b` is empty.\n\nTime complexity:\n\nWe always cut off half of `a` or half of `b`. Therefore it will take `O(log(m) + log(n))` to cut to zero.\n\n\tO(log(m) + log(n)) <= O(log(max(m, n)) + log(max(m, n))) = O(log(max(m, n))) <= O(log(m+n))\n\nFull code:\n\t\n\t\tclass Solution:     \n\t\t\tdef findMedianSortedArrays(self, a, b):\n\n\t\t\t\tl = len(a) + len(b)\n\n\t\t\t\tif l % 2:\n\t\t\t\t\treturn self.get_median(a, b, l // 2)\n\t\t\t\telse:\n\t\t\t\t\treturn (self.get_median(a, b, l // 2) + self.get_median(a, b, l // 2 - 1))  / 2\n\n\t\t\tdef get_median(self, a, b, idx):\n\n\t\t\t\tif not a:\n\t\t\t\t\treturn b[idx]\n\t\t\t\tif not b:\n\t\t\t\t\treturn a[idx]\n\n\t\t\t\tai = len(a) // 2\n\t\t\t\tbi = len(b) // 2\n\t\t\t\tma = a[ai]\n\t\t\t\tmb = b[bi]\n\n\t\t\t\tif ma > mb:\n\t\t\t\t\tma, mb = mb, ma\n\t\t\t\t\tai, bi = bi, ai\n\t\t\t\t\ta, b = b, a\n\n\t\t\t\tmax_idx_ma = len(a) // 2 + len(b) // 2\n\n\t\t\t\tif max_idx_ma < idx:\n\t\t\t\t\tmed = self.get_median(a[ai+1:], b, idx - (len(a)//2+1))\n\t\t\t\telse:\n\t\t\t\t\t# max_idx_ma < min_idx_mb (because they are different numbers) \n\t\t\t\t\t# => idx <= max_idx_ma <  min_idx_mb => idx < min_idx_mb\n\t\t\t\t\tmed = self.get_median(a, b[:bi], idx)\n\n\t\t\t\treturn med, status: null, voteStatus: 0, voteCount: 26, creationDate: 1678535715, isHidden: null, author: {username: Revist, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 27}}}, searchMeta: null}, {id: 4070428, title: ðŸš€100% || Two Solutions || Two Pointers & Divide And Conquer || Commented CodeðŸš€, commentCount: 6, topLevelCommentCount: 4, viewCount: 3556, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: Two Pointers, slug: two-pointers}, {name: Divide and Conquer, slug: divide-and-conquer}], post: {id: 6140185, content: # Problem Description\nGiven two sorted arrays, `nums1` and `nums2`, each of sizes `M` and `N` respectively. The **goal** is to find the **median** of the **combined** array formed by merging `nums1` and `nums2`.\n\nThe **task** is to design an algorithm with an overall run time complexity of `O(log(min(m, n)))` to calculate the median of the combined sorted array.\n\n**The median** of an array is the **middle** element when the array is **sorted**. If the combined array has an even number of elements, the median is the **average** of the two middle elements.\n\n![image.png](https://assets.leetcode.com/users/images/3a8f6ac2-ad54-4fb4-a020-b5df18b6dbb4_1695259239.098474.png)\n\n\n\n---\n\n\n# Intuition\nHello There\uD83D\uDE00\nLet\'s take a look on our today\'s interesting problem\uD83D\uDE80\n\nIn our today\'s problem we have, two **sorted** arrays and a **median** to find but the **median** is for the array that **results** from **merging** both of the arrays.\nSounds like a **neat** problem.\uD83E\uDD29\n\n## Two Pointers\nThe **first** solution that would pop in mind is Why don\'t we **merge** the two arrays.\uD83E\uDD14\nWe can do this in **linear** time since the two arrays are **sorted** then we will have `2` pointer each of them on a **different** array from the other and put the **smaller** number in the **available** position in our **new** array.\n![image.png](https://assets.leetcode.com/users/images/10266f12-45f6-41a0-87b6-7d8bbdd9e343_1695261379.3813884.png)\n\nThe **tricky** part here that this solution has **complexity** of `O(m + n)` and still get **accepted** although the problem said it wants an algorithm with `O(log(min(m, n)))`\uD83E\uDD2F\nBut I had `100%` solution in **Java** with **Two Pointers** solution exactly like the next solution that I will discuss.\n\n\n\n## Divide And Conquer\n\n**Divide and Conquer** in a great technique in the world of computer science.\uD83D\uDE80\nIt **shares** something important with **dynamic programming** that both of them **break** the problem into smaller **subproblems**.\nThe **diffrenece** between the two approaches that the subproblems are **independent** in divide and conquer but in dynamic programming there is some **overlapping** between the subproblems.\uD83E\uDD2F\n\n- The **essence** of this solution that two things :\n    - **drop** the part of the two arrays that we are sure that our median **won\'t be in it**.\n    - **choose** the median when one array has **no elements** in it.\n\nlet\'s look at the **base case**, when we have one array is **empty**\nif you have two arrays `a` , `b` and I told you to get the median of their merge like that:\n```\n-> a = [1, 4, 10]\n-> b = []\n\n-> index median of a + b = 1\n-> median of a + b = 4\n``` \nWe can note here that since `b` is empty then the median is in a with the same **index** we are searching for.\uD83E\uDD2F\n\nLet\'s look at another example:\n```\n-> a = [1, 4, 10]\n-> b = [2, 4, 7, 15]\n-> index median of a + b = 3\n-> mid of a = 1\n-> mid of b = 2\n```\n```\nnew a and b to search in:\n-> a = [1, 4, 10]\n-> b = [2, 4]\n-> index median of a + b = 3\n-> mid of a = 1\n-> mid of b = 1\n```\n```\nnew a and b to search in\n-> a = [10]\n-> b = [2, 4]\n-> index median of a + b = 1\n-> mid of a = 0\n-> mid of b = 1\n```\n```\nnew a and b to search in\n-> a = []\n-> b = [2, 4]\n-> index median of a + b = 1\n```\nWow, we can see now we reached our **base** case that a is **empty** then the solution is the `1` **index** of our new array of b which is `4`.\n\nWe can see in the last example that we applied divide and conquer by **dropping** the **half** of the array that we are sure that our median won\'t be inside it then recursively search in our new arrays until we reach our base case.\uD83D\uDE80\n\nAnd this is the solution for our today problem I hope that you understood it\uD83D\uDE80\uD83D\uDE80\n\n\n---\n# Approach\n## 1. Two Pointers\n1. **Create** a new array `mergedArray` with a size equal to the **sum** of the sizes of `nums1` and `nums2`.\n2. **Initialize** two pointers `idxNums1` and `idxNums2` to `0`, representing the indices for `nums1` and `nums2`.\n3. **Iterate** through mergedArray from `0` to its `size`.\n    - **Compare** the elements pointed by `idxNums1` in `nums1` and `idxNums2` in `nums2`.\n    - Place the **smaller** element in `mergedArray` and **increment** the respective pointer (`idxNums1` or `idxNums2`).\n4. Check if the **size** of `mergedArray` is **odd** or **even**.\n    - If **odd**, return the **middle** element of `mergedArray`.\n    - If **even**, return the **average** of the two middle elements in `mergedArray`.\n\n## Complexity\n- **Time complexity:** $$O(N + M)$$ \nSince we are iterating over the big array which has size of `N + M`.\n- **Space complexity:** $$O(N + M)$$\nSince we are storing the new merged array with size of `N + M`.\n\n\n---\n\n## 2. Divide And Conquer\n1. **findKthElement** Function.\n    - Handle **base cases** where one of the arrays is **exhausted**.\n        - Return the kth element from the remaining array accordingly.\n    - **Calculate** mid indices for both arrays to divide and conquer.\n    - Based on mid elements, decide which **portion** of the arrays to **discard** and recurse accordingly.\n2. **findMedianSortedArrays** Function.\n    - Calculate the **total size** of the merged arrays.   \n    - If the total size is **odd**, return the kth element where `k = total_size // 2`.\n    - If the total size is **even**, find the `kth and (kth - 1)` elements and return their **average**.\n\n## Complexity\n- **Time complexity:** $$O(log(min(M, N)))$$ \nThe **logarithmic** term is because we are using **Divide And Conquer** then each call we divide the size of the two arrays into half.\nThe **minimum** term since the base case is when the size of one of the arrays is `0` and the array which will be faster to reach `0` is the smaller array which is `min(M, N)`\nSo total complexity is `O(log(min(M, N)))` .\n- **Space complexity:** $$O(1)$$\nSince we are only store constant number of variables then complexity is `O(1)`.\n\n\n\n---\n\n\n\n# Code\n## 1. Two Pointers\n```C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Merge the sorted arrays into a single array\n        vector<int> mergedArray(nums1.size() + nums2.size());\n        \n        int idxNums1 = 0; // Index for nums1\n        int idxNums2 = 0; // Index for nums2\n        \n        // Merge the arrays while maintaining the sorted order\n        for(int i = 0; i < mergedArray.size(); i++) {\n            if (idxNums2 != nums2.size() && (idxNums1 == nums1.size() || nums2[idxNums2] < nums1[idxNums1])) {\n                mergedArray[i] = nums2[idxNums2++];\n            } else {\n                mergedArray[i] = nums1[idxNums1++];\n            }\n        }\n        \n        // Calculate the median of the merged array\n        if (mergedArray.size() % 2 == 1) {\n            return mergedArray[mergedArray.size() / 2];\n        } else {\n            return ((mergedArray[mergedArray.size() / 2]) + (mergedArray[mergedArray.size() / 2 - 1])) / 2.0;\n        }\n    }\n};\n```\n```Java []\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // Merge the sorted arrays into a single array\n        int[] mergedArray = new int[nums1.length + nums2.length];\n\n        int idxNums1 = 0; // Index for nums1\n        int idxNums2 = 0; // Index for nums2\n\n        // Merge the arrays while maintaining the sorted order\n        for (int i = 0; i < mergedArray.length; i++) {\n            if (idxNums2 < nums2.length && (idxNums1 == nums1.length || nums2[idxNums2] < nums1[idxNums1])) {\n                mergedArray[i] = nums2[idxNums2++];\n            } else {\n                mergedArray[i] = nums1[idxNums1++];\n            }\n        }\n\n        // Calculate the median of the merged array\n        if (mergedArray.length % 2 == 1) {\n            return mergedArray[mergedArray.length / 2];\n        } else {\n            return (mergedArray[mergedArray.length / 2] + mergedArray[mergedArray.length / 2 - 1]) / 2.0;\n        }\n    }\n}\n```\n```Python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2) -> float:\n        merged_array = [0] * (len(nums1) + len(nums2))\n        idx_nums1 = 0  # Index for nums1\n        idx_nums2 = 0  # Index for nums2\n\n        # Merge the arrays while maintaining the sorted order\n        for i in range(len(merged_array)):\n            if idx_nums2 < len(nums2) and (idx_nums1 == len(nums1) or nums2[idx_nums2] < nums1[idx_nums1]):\n                merged_array[i] = nums2[idx_nums2]\n                idx_nums2 += 1\n            else:\n                merged_array[i] = nums1[idx_nums1]\n                idx_nums1 += 1\n\n        # Calculate the median of the merged array\n        if len(merged_array) % 2 == 1:\n            return merged_array[len(merged_array) // 2]\n        else:\n            return (merged_array[len(merged_array) // 2] + merged_array[len(merged_array) // 2 - 1]) / 2.0\n```\n\n## 2. Divide And Conquer\n```C++ []\nclass Solution {\npublic:\n    // Helper function to find the kth element in merged sorted arrays\n    double findKthElement(int k, vector<int>& nums1, vector<int>& nums2, int start1, int end1, int start2, int end2) {\n        // Base cases when one array is exhausted\n        if (start1 >= end1)\n            return nums2[start2 + k];\n        if (start2 >= end2)\n            return nums1[start1 + k];\n\n        // Calculate mid indices\n        int mid1 = (end1 - start1) / 2;\n        int mid2 = (end2 - start2) / 2;\n\n        // Compare mid elements and recurse accordingly\n        if (mid1 + mid2 < k) {\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\n                // Discard elements before mid2 and search in the remaining array\n                return findKthElement(k - mid2 - 1, nums1, nums2, start1, end1, start2 + mid2 + 1, end2);\n            else\n                // Discard elements before mid1 and search in the remaining array\n                return findKthElement(k - mid1 - 1, nums1, nums2, start1 + mid1 + 1, end1, start2, end2);\n        } else {\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\n                // Discard elements after mid1 and search in the remaining array\n                return findKthElement(k, nums1, nums2, start1, start1 + mid1, start2, end2);\n            else\n                // Discard elements after mid2 and search in the remaining array\n                return findKthElement(k, nums1, nums2, start1, end1, start2, start2 + mid2);\n        }\n    }\n\n    // Function to find the median of merged sorted arrays\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int size1 = nums1.size();\n        int size2 = nums2.size();\n        int totalSize = size1 + size2;\n\n        // Check if the total size is odd or even and find the median accordingly\n        if (totalSize % 2 == 1)\n            // For odd total size, median is the kth element where k = total_size // 2\n            return findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\n        else {\n            // For even total size, median is the average of kth and (kth - 1) elements\n            int num1 = findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\n            int num2 = findKthElement(totalSize / 2 - 1, nums1, nums2, 0, size1, 0, size2);\n\n            return (num1 + num2) / 2.0;\n        }\n    }\n};\n```\n```Java []\nclass Solution {\n    // Helper function to find the kth element in merged sorted arrays\n    private double findKthElement(int k, int[] nums1, int[] nums2, int start1, int end1, int start2, int end2) {\n        // Base cases when one array is exhausted\n        if (start1 >= end1)\n            return nums2[start2 + k];\n        if (start2 >= end2)\n            return nums1[start1 + k];\n\n        // Calculate mid indices\n        int mid1 = (end1 - start1) / 2;\n        int mid2 = (end2 - start2) / 2;\n\n        // Compare mid elements and recurse accordingly\n        if (mid1 + mid2 < k) {\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\n                // Discard elements before mid2 and search in the remaining array\n                return findKthElement(k - mid2 - 1, nums1, nums2, start1, end1, start2 + mid2 + 1, end2);\n            else\n                // Discard elements before mid1 and search in the remaining array\n                return findKthElement(k - mid1 - 1, nums1, nums2, start1 + mid1 + 1, end1, start2, end2);\n        } else {\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\n                // Discard elements after mid1 and search in the remaining array\n                return findKthElement(k, nums1, nums2, start1, start1 + mid1, start2, end2);\n            else\n                // Discard elements after mid2 and search in the remaining array\n                return findKthElement(k, nums1, nums2, start1, end1, start2, start2 + mid2);\n        }\n    }\n\n    // Function to find the median of merged sorted arrays\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int size1 = nums1.length;\n        int size2 = nums2.length;\n        int totalSize = size1 + size2;\n\n        // Check if the total size is odd or even and find the median accordingly\n        if (totalSize % 2 == 1)\n            // For odd total size, median is the kth element where k = total_size // 2\n            return findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\n        else {\n            // For even total size, median is the average of kth and (kth - 1) elements\n            double num1 = findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\n            double num2 = findKthElement(totalSize / 2 - 1, nums1, nums2, 0, size1, 0, size2);\n\n            return (num1 + num2) / 2.0;\n        }\n    }\n}\n```\n```Python []\nclass Solution:\n    def find_kth_element(self, k, nums1, nums2):\n        # Base cases when one array is exhausted\n        if not nums1:\n            return nums2[k]\n        if not nums2:\n            return nums1[k]\n\n        mid1 = len(nums1) // 2  # Midpoint of nums1\n        mid2 = len(nums2) // 2  # Midpoint of nums2\n\n        if mid1 + mid2 < k:\n            if nums1[mid1] > nums2[mid2]:\n                # Discard elements before mid2 and search in the remaining array\n                return self.find_kth_element(k - mid2 - 1, nums1, nums2[mid2 + 1:])\n            else:\n                # Discard elements before mid1 and search in the remaining array\n                return self.find_kth_element(k - mid1 - 1, nums1[mid1 + 1:], nums2)\n        else:\n            if nums1[mid1] > nums2[mid2]:\n                # Discard elements after mid1 and search in the remaining array\n                return self.find_kth_element(k, nums1[:mid1], nums2)\n            else:\n                # Discard elements after mid2 and search in the remaining array\n                return self.find_kth_element(k, nums1, nums2[:mid2])\n\n    def findMedianSortedArrays(self, nums1, nums2):\n        total_size = len(nums1) + len(nums2)\n\n        if total_size % 2 == 1:\n            # For odd total size, median is the kth element where k = total_size // 2\n            return self.find_kth_element(total_size // 2, nums1, nums2)\n        else:\n            # For even total size, median is the average of kth and (kth - 1) elements\n            k1 = total_size // 2\n            k2 = total_size // 2 - 1\n            num1 = self.find_kth_element(k1, nums1, nums2)\n            num2 = self.find_kth_element(k2, nums1, nums2)\n            return (num1 + num2) / 2.0\n```\n\n \n![leet_sol.jpg](https://assets.leetcode.com/users/images/bfec69ea-4eef-49b6-9926-a982eb9a28b8_1695257729.395488.jpeg)\n\n, status: null, voteStatus: 0, voteCount: 23, creationDate: 1695258481, isHidden: null, author: {username: MohamedMamdouh20, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1694009290.png, reputation: 3455}}}, searchMeta: null}, {id: 1174195, title: C++/Python O(log(m+n)) solution, commentCount: 2, topLevelCommentCount: 1, viewCount: 8134, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: Divide and Conquer, slug: divide-and-conquer}, {name: Binary Tree, slug: binary-tree}], post: {id: 2093769, content: Good question. Took me a while with bit of a hint to solve this question.\nHere I\'ve considered the median in my list for checking the conditions.\nNote- When la + lb == target what it actually means is that no. of elements in a and b inlcuding median is greater than tar as la and lb are indexes not count of elements. Hence its recursion is same as under the condition la + lb > tar.\n1. C++\n```\nclass Solution {\npublic:\n    double median(vector<int>& a, vector<int>& b, int s1, int e1, int s2, int e2, int tar){\n        int la, lb, ma, mb, m = max(e1 - s1 + 1,0), n = max(e2 - s2 + 1,0), ans;\n        if(!m)\n            return b[s2 + tar];\n        if(!n)\n            return a[s1 + tar];\n        \n        la = m/2;\n        lb = n/2;\n        ma = a[s1 + la];\n        mb = b[s2 + lb];\n        \n        if (la + lb >= tar){\n            if (ma > mb)\n                ans = median(a,b,s1,s1 + la - 1,s2,e2,tar);\n            else\n                ans = median(a,b,s1,e1,s2,s2 + lb - 1,tar);\n        }\n        else{\n            if (ma > mb)\n                ans = median(a,b,s1,e1,s2 + lb + 1,e2,tar - lb - 1);\n            else\n                ans = median(a,b,s1 + la + 1,e1,s2,e2,tar - la - 1);\n        }\n        return ans;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n\n        if (!m)\n            return n & 1 ? nums2[n / 2] : (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;\n        if (!n)\n            return m & 1 ? nums1[m / 2] : (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;\n        \n        if ((m + n) & 1)\n            return median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2);\n        \n        return (median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2 - 1) + median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2))/2.0;\n    }\n};\n```\n2. Python\n```\nclass Solution:\n    def findkth(self, a: List[int], b: List[int], target) -> int:\n        # print("a: {}, b:{}".format(a, b))\n        n, m = len(a), len(b)\n        if n <= 0:\n            return b[target - 1]\n        if m <= 0:\n            return a[target - 1]\n        med_a, med_b = n // 2 + 1, m // 2 + 1\n        ma, mb = a[n // 2], b[m // 2]\n        \n        if med_a + med_b > target:\n            if ma > mb:\n                return self.findkth(a[:med_a - 1], b, target)\n            else:\n                return self.findkth(a, b[:med_b - 1], target)\n        else:\n            if ma > mb:\n                return self.findkth(a, b[med_b:], target - med_b)\n            else:\n                return self.findkth(a[med_a:], b, target - med_a)\n        \n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        n, m = len(nums1), len(nums2)\n        if n == 0 :\n            if m % 2 == 0:\n                return (nums2[m // 2 - 1] + nums2[m // 2]) / 2\n            else:\n                return nums2[m // 2]\n        if m == 0 :\n            if n % 2 == 0:\n                return (nums1[n // 2 - 1] + nums1[n // 2]) / 2\n            else:\n                return nums1[n // 2]\n        if (m + n) % 2 == 0:\n            return (self.findkth(nums1, nums2, (m + n) // 2) + self.findkth(nums1, nums2, (m + n) // 2 + 1)) / 2\n        return self.findkth(nums1, nums2, (m + n) // 2 + 1)\n```\n**PS : Please upvote if you like the solution.**, status: null, voteStatus: 0, voteCount: 23, creationDate: 1619264286, isHidden: null, author: {username: SaketCodeScribe, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1695957889.png, reputation: 182}}}, searchMeta: null}, {id: 2838406, title: 2 Python easy Solution âœ”ï¸ with video explanation, commentCount: 2, topLevelCommentCount: 1, viewCount: 3895, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 4534450, content: [https://youtu.be/rJFXBLxAwrw]()\n# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n\n# Complexity\n- Time complexity: O(lg n)\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: 0(1)\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if (len(nums1) > len(nums2)):\n            return self.findMedianSortedArrays(nums2, nums1)\n\n        start = 0\n        end = len(nums1)\n\n        X = len(nums1)\n        Y = len(nums2)\n\n        while start <= end:\n            division1 = (start + end) // 2 # mid\n            division2 = (X + Y + 1) // 2 - division1\n\n            # left of the median of List 1\n            if (division1 == 0):\n                X1 = float(\'-inf\')\n            else:\n                X1 = nums1[division1 - 1]\n\n            #right of the median of List 1\n            if (division1 == len(nums1)):\n                X2 = float(\'inf\')\n            else:\n                X2 = nums1[division1]\n\n            # left of the median of List 2\n            if (division2 == 0):\n                Y1 = float(\'-inf\')\n            else:\n                Y1 = nums2[division2 - 1]\n            \n            # right of the median of List 2\n            if (division2 == len(nums2)):\n                Y2 = float(\'inf\')\n            else:\n                Y2 = nums2[division2]\n\n            # check if we found the correct division\n\n            if (X1 <= Y2 and Y1 <= X2):\n                # check if the length of the sum of both lists are even or odd\n                if (X + Y) % 2 == 0:\n                    median = ((max(X1, Y1) + min(X2, Y2)) / 2)\n                    return median\n                else:\n                    #odd\n                    median = max(X1, Y1)\n                    return median\n            elif Y1 > X2:\n                start = division1 + 1\n            else:\n                end = division1 - 1\n\n\n\n\n\n\n\n\n\n\n\n```, status: null, voteStatus: 0, voteCount: 18, creationDate: 1669100477, isHidden: null, author: {username: CoderrrMan, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1669150350.png, reputation: 6225}}}, searchMeta: null}, {id: 3922746, title: Most optimal solution using binary search with explanation, commentCount: 6, topLevelCommentCount: 3, viewCount: 5052, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: Binary Search, slug: binary-search}, {name: Divide and Conquer, slug: divide-and-conquer}], post: {id: 5944106, content: \n\n# Approach\n- **Choosing the Smaller Array:** To optimize the time complexity, the solution starts by choosing the smaller of the two input arrays (nums1 and nums2) for the binary search operation. This helps in reducing the time complexity of the solution.\n\n- **Calculating the Partition Point:** The total number of elements in the combined array is n = n1 + n2. The index left where the partition between the left and right halves of the combined arrays should occur is calculated as (n1 + n2 + 1) / 2. This choice of left is crucial, as it helps in finding the median efficiently, both for odd and even total elements.\n\n- **Binary Search in Smaller Array:** A binary search is performed in the smaller array (nums1) to find the correct partition point (mid1) that satisfies the median condition. The corresponding partition point in the larger array (nums2) is calculated as mid2 = left - mid1.\n\n- **Setting Up Boundaries:** Four variables are used to store the elements immediately to the left (l1, l2) and to the right (r1, r2) of the calculated partition points in both arrays. These values are initialized to extreme values (INT_MIN and INT_MAX in C++, or negative and positive infinity in Python) to handle edge cases.\n\n- **Checking Median Condition:** The conditions l1 <= r2 and l2 <= r1 are checked to ensure that the median condition is met. These conditions ensure that the left half of the combined arrays contains elements smaller than or equal to the right half, which is the requirement for calculating the median.\n\n- **Calculating Median**: If the median condition is met, the median is calculated. If the total number of elements is odd, the median is the maximum of the left elements (l1 and l2). If the total number of elements is even, the median is the average of the maximum of the left elements and the minimum of the right elements (r1 and r2).\n\n- **Adjusting Binary Search Range:** If the median condition is not met, the binary search range is adjusted. If l1 is greater than r2, it means the partition point mid1 is too far to the right, so the search range is adjusted to the left half. Otherwise, the search range is adjusted to the right half.\n\n- **Convergence and Return:** The binary search continues until low is less than or equal to high. Once the binary search converges, the function returns the calculated median.\n\n# Complexity\n- Time complexity:\nO(log(min(n1, n2))) \n\n- Space complexity:\nO(1)\n\n```C++ []\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\n        int n1 = nums1.size(), n2 = nums2.size();\n        if (n1 > n2)\n            return findMedianSortedArrays(nums2, nums1);\n        int n = n1 + n2;\n        int left = (n1 + n2 + 1) / 2;\n        int low = 0, high = n1;\n        while (low <= high) {\n            int mid1 = (low + high) >> 1;\n            int mid2 = left - mid1;\n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\n            if (mid1 < n1)\n                r1 = nums1[mid1];\n            if (mid2 < n2)\n                r2 = nums2[mid2];\n            if (mid1 - 1 >= 0)\n                l1 = nums1[mid1 - 1];\n            if (mid2 - 1 >= 0)\n                l2 = nums2[mid2 - 1];\n            if (l1 <= r2 && l2 <= r1) {\n                if (n % 2 == 1)\n                    return max(l1, l2);\n                else\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\n            }\n            else if (l1 > r2)\n                high = mid1 - 1;\n            else\n                low = mid1 + 1;\n        }\n        return 0;\n    }\n};\n```\n```JAVA []\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1 = nums1.length, n2 = nums2.length;\n        if (n1 > n2)\n            return findMedianSortedArrays(nums2, nums1);\n        int n = n1 + n2;\n        int left = (n1 + n2 + 1) / 2;\n        int low = 0, high = n1;\n        while (low <= high) {\n            int mid1 = (low + high) / 2;\n            int mid2 = left - mid1;\n            int l1 = (mid1 > 0) ? nums1[mid1 - 1] : Integer.MIN_VALUE;\n            int l2 = (mid2 > 0) ? nums2[mid2 - 1] : Integer.MIN_VALUE;\n            int r1 = (mid1 < n1) ? nums1[mid1] : Integer.MAX_VALUE;\n            int r2 = (mid2 < n2) ? nums2[mid2] : Integer.MAX_VALUE;\n            \n            if (l1 <= r2 && l2 <= r1) {\n                if (n % 2 == 1)\n                    return Math.max(l1, l2);\n                else\n                    return (double) (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;\n            } else if (l1 > r2)\n                high = mid1 - 1;\n            else\n                low = mid1 + 1;\n        }\n        return 0.0;\n    }\n}\n\n```\n```Python []\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        n1, n2 = len(nums1), len(nums2)\n        if n1 > n2:\n            return self.findMedianSortedArrays(nums2, nums1)\n        n = n1 + n2\n        left = (n1 + n2 + 1) // 2\n        low, high = 0, n1\n        \n        while low <= high:\n            mid1 = (low + high) // 2\n            mid2 = left - mid1\n            \n            l1 = float(\'-inf\') if mid1 == 0 else nums1[mid1 - 1]\n            l2 = float(\'-inf\') if mid2 == 0 else nums2[mid2 - 1]\n            r1 = float(\'inf\') if mid1 == n1 else nums1[mid1]\n            r2 = float(\'inf\') if mid2 == n2 else nums2[mid2]\n            \n            if l1 <= r2 and l2 <= r1:\n                if n % 2 == 1:\n                    return max(l1, l2)\n                else:\n                    return (max(l1, l2) + min(r1, r2)) / 2.0\n            elif l1 > r2:\n                high = mid1 - 1\n            else:\n                low = mid1 + 1\n        return 0.0\n\n```\n, status: null, voteStatus: 0, voteCount: 15, creationDate: 1692281612, isHidden: null, author: {username: priyanshu11_, isActive: true, nameColor: null, activeBadge: {displayName: Mar LeetCoding Challenge, icon: /static/images/badges/dcc-2023-3.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1707155654.png, reputation: 548}}}, searchMeta: null}, {id: 2597142, title: [Python3] O(log(n)) Solution, commentCount: 1, topLevelCommentCount: 1, viewCount: 2930, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: Binary Tree, slug: binary-tree}], post: {id: 4210373, content: ```\n# -------------------- Method 1 --------- NOT Optimised O(N) Time----------------\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        n1 = len(nums1); n2 = len(nums2)\n        mid = (n1 + n2) // 2  \n        i = 0; j = 0\n        val, preVal = 0, 0\n        \n        for k in range(mid+1):\n            if i < n1 and j < n2:\n                if nums1[i] <= nums2[j]:\n                    val = nums1[i]  \n                    i += 1\n                else:\n                    val = nums2[j]\n                    j += 1\n            elif i < n1:\n                val = nums1[i]\n                i += 1\n            else:\n                val = nums2[j]\n                j += 1\n            \n            if k == mid - 1:\n                preVal = val\n        \n        if (n1+n2) % 2 == 0:\n            return (val + preVal) / 2\n        return float(val)\n    \n# Timw: O(N)\n# Space: O(1)\n\n\n\n# -------------------- Method 2 --------- Optimised O(log(N)) Time----------------\n\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        n1 = len(nums1);   n2 = len(nums2) \n        if n1 > n2: return self.findMedianSortedArrays(nums2, nums1) # WE SHALL DO BINARY SEARCH ON THE SMALLER ARRAY, NUMS1\n        \n        INT_MIN, INT_MAX = -2**64, 2**64  # SETUP INT_MIN AND INT_MAX FOR EMPTY LEFT / RIGHT PARTITION\n        low = 0;   high = n1  # pointers for BINARY SEARCH ON THE SMALLER ARRAY NUMS1\n        \n        while low <= high:\n            \n            # GET THE PARITIONS POINTS OF BOTH ARRAYS\n            cut1 = (low + high) // 2          # partition of nums1\n            cut2 = (n1 + n2 + 1) // 2 - cut1  # partition of nums2\n            \n            # GET THE 4 BOUNDARY NUMBERS\n            left1 = nums1[cut1-1] if cut1 > 0 else INT_MIN   # left1 is the left partition of cut1\n            right1 = nums1[cut1] if cut1 < n1 else INT_MAX   # right1 is the right partition of cut1\n            \n            left2 = nums2[cut2-1] if cut2 > 0 else INT_MIN   # left2 is the left partition of cut2\n            right2 = nums2[cut2] if cut2 < n2 else INT_MAX   # right2 is the right partition of cut2\n            \n            # CORRECT PARTITION FOUND\n            if left1 <= right2 and left2 <= right1:  # Got the Answer => Median\n                if (n1 + n2) % 2 == 0:\n                    return (max(left1, left2) + min(right1, right2)) / 2\n                else:\n                    return max(left1, left2)\n            \n            # MOVE cut1 (mid of binary search) LEFTWARDS\n            elif left1 > right2:\n                high = cut1 - 1\n                \n            # MOVE cut1 (mid of binary search) RIGHTWARDS   \n            else:\n                low = cut1 + 1\n        \n        return 0.0  # For both empty arrays\n    \n\'\'\'\nTime Complexity: O(log(n1))  \nSpace Complexity: O(1)\n\'\'\'\n\n\n```, status: null, voteStatus: 0, voteCount: 13, creationDate: 1663593336, isHidden: null, author: {username: SamirPaulb, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1703107702.png, reputation: 532}}}, searchMeta: null}, {id: 2672475, title: Python O( Log( Min(m, n) ) ) Solution with full working explanation, commentCount: 4, topLevelCommentCount: 2, viewCount: 6667, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 4310811, content: # Optimal \n```\nclass Solution:  # Time: O(log(min(m, n))) and Space: O(n)\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(A) > len(B):    # for our solution we are assuming that B will be bigger than A, if it\'s not given than make it\n            A, B = B, A\n\n        l, r = 0, len(A) - 1   # we also assume that A is exactly half of B\n\n        while True:            # when any return statement is executed it will stop\n            i = (l + r) // 2   # A[mid]\n\n            # B[mid] = total//2(divide by 2 will get us mid B ) - A[mid](if we sub A from total, B\'s left) -\n            # 2(to make it align with starting index 0 of A & B, else it will go out of bounds)\n            j = half - i - 2\n\n            Aleft = A[i] if i >= 0 else float("-infinity")  # if index i is in negative than assign -infinity to Aleft\n            Aright = A[i + 1] if (i + 1) < len(A) else float("infinity")  # if index i+1 is greater than the size of A assign infinity to Aright\n            Bleft = B[j] if j >= 0 else float("-infinity")  # if index j is in negative than assign -infinity to Bleft\n            Bright = B[j + 1] if (j + 1) < len(B) else float("infinity")  # if index j+1 is greater than the size of B assign infinity to Bright\n\n            # A = [1, 2, 3(left), 4(right), 5] and B = [1, 2, 3(left), 4(right), 5, 6, 7, 8]  # B = 6 - 2 - 2 = 2(i.e 0,1,2)\n            if Aleft <= Bright and Bleft <= Aright:  # 3 <= 4 and 3 <= 4\n                if total % 2:                                         # odd: min(4, 4)\n                    return min(Aright, Bright) \n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2  # even: max(3, 3) + min(4, 4)  / 2\n            elif Aleft > Bright:  # A = [1, 2, 3(left), 4(right), 5, 6] and B = [1, 2(left), 3(right), 4, 5]\n                r = i - 1         # r = 3 - 1 = 2(i.e. index 0,1,2) --> A = [1, 2(L), 3(R), 4, 5, 6] and B = [1, 2, 3(L), 4(R), 5, 6]\n            else:                 # when Bleft > Aright, we will increase l so L becomes R, and R pointer is shifted to R+1 index\n                l = i + 1\n```\nFor example,\nLet **nums1 = [1, 3] & nums2 = [2]**\n1. A, B = [1, 3], [2]\n1. total = 3\n1. half = 3 // 2 = 1\n1. if len(A)=2 > len(B)=1 =  True: A, B = [2], [1, 3]\n1. l, r = 0, 1-1=0\n1. while True:\n* i = (0 + 0) // 2 = 0\n* j = 1 - 0 - 2 = -1\n* Aleft = if 0 >= 0 = True: A[0] = 2  \n* Aright = if (0 + 1) < len(A) = False --> else float("infinity") = infinity\n* Bleft = if -1 >= 0 = False --> else: float("-infinity") = -infinity\n* Bright = if (-1+1=0) < len(B)=2 = True: B[-1+1=0] = 1 \n* if 2 <= 1 and -infinity <= infinity =  False and True = False\n* elif 2 > 1 = True: r = 0 - 1 = -1\n\n7. while True:\n* i = (0 + -1) // 2 = -1\n* j = 1 - (-1) - 2 = 0\n* Aleft = if -1 >= 0 = False --> else: float("-infinity") = -infinity\n* Aright = if (-1 + 1)=0 < len(A)=1 = True: A[-1+1] = 2\n* Bleft = if 0 >= 0 = True: B[0] = 1\n* Bright = if 0+1=1 < len(B)=2 = True: B[0+1=1] = 3 \n* if -infinity <= 3 and 1 <= 2 =  True and True = True: \n  * if 3 % 2 = 1 = True --> return  min(2, 3) = **Returns 2**\n\n# Easy Non-Optimal \n```\nclass Solution:  # Time: O(NLogN) and Space: O(1)\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        nums1 = nums1 + nums2\n        nums1 = sorted(nums1)\n        n = len(nums1)\n        if n % 2 == 0:\n            return (nums1[n//2 - 1] + nums1[(n//2)])/2 \n        else:\n            n = math.ceil(n/2)\n            return nums1[n-1]\n```, status: null, voteStatus: 0, voteCount: 12, creationDate: 1665146985, isHidden: null, author: {username: DanishKhanbx, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1707141814.png, reputation: 124}}}, searchMeta: null}, {id: 1309837, title: Elegant Python Binary Search | O(log(min(m,n))), O(1), commentCount: 0, topLevelCommentCount: 0, viewCount: 2893, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Binary Tree, slug: binary-tree}], post: {id: 2307789, content: ```\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums2) < len(nums1): nums1, nums2 = nums2, nums1\n        m, n = len(nums1), len(nums2)  \n        \n        left, right = 0, m-1\n        while True:\n            pointer1 = left + (right-left) // 2\n            pointer2 = (m+n)//2 - pointer1 - 2\n            \n            left1 = nums1[pointer1] if pointer1 in range(m) else -math.inf\n            left2 = nums2[pointer2] if pointer2 in range(n) else -math.inf\n            right1 = nums1[pointer1+1] if pointer1+1 in range(m) else math.inf\n            right2 = nums2[pointer2+1] if pointer2+1 in range(n) else math.inf\n            \n            if left1 <= right2 and left2 <= right1:\n                if (m+n) % 2 == 0: return (max(left1, left2) + min(right1, right2)) / 2\n                else: return min(right1, right2)\n                \n            elif left1 > right2: right = pointer1 - 1\n            else: left = pointer1 + 1\n```, status: null, voteStatus: 0, voteCount: 10, creationDate: 1625167834, isHidden: null, author: {username: soma28, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 153}}}, searchMeta: null}, {id: 2799909, title: Python | Easy Solutionâœ…, commentCount: 6, topLevelCommentCount: 5, viewCount: 7613, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}], post: {id: 4481912, content: \n# Code\u2705\n```\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        final = [] \n        i = 0\n        j = 0\n        while i<len(nums1) and j<len(nums2):\n            if nums1[i] <= nums2[j]:\n                final.append(nums1[i])\n                i += 1\n            else:\n                final.append(nums2[j])\n                j += 1\n        final = final + nums1[i:] + nums2[j:]\n        size = len(final)\n        return (final[size//2]) if size % 2 != 0 else (final[size//2 - 1] + final[(size//2)])/2 \n```, status: null, voteStatus: 0, voteCount: 9, creationDate: 1668083223, isHidden: null, author: {username: gmanayath, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1671114329.png, reputation: 928}}}, searchMeta: null}, {id: 362727, title: Python. O(Log(m+n)), commentCount: 2, topLevelCommentCount: 2, viewCount: 1761, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Binary Search, slug: binary-search}], post: {id: 690543, content: This solution is inspired from Tushar Roy\'s approach for finding the median on Youtube. \n\n```\ndef findMedianSortedArrays(self, arr1: List[int], arr2: List[int]) -> float:\n        x=len(arr1)\n        y=len(arr2)\n        if x>y:\n            return self.findMedianSortedArrays(arr2,arr1)\n        low=0\n        high=x\n        while(low<=high):\n            #print(low)\n            partitionX=int((low+high)/2)\n\n            partitionY=int(((x+y+1)//2 )-partitionX)\n            maxLeftX= float(\'-inf\') if partitionX==0 else arr1[partitionX-1]\n            minRightX=float(\'inf\') if partitionX==x else arr1[partitionX]\n            maxLeftY = float(\'-inf\') if partitionY == 0 else arr2[partitionY - 1]\n            minRightY =  float(\'inf\') if partitionY == y else arr2[partitionY]\n            if maxLeftX<=minRightY and maxLeftY<=minRightX:\n                if (x+y) %2 ==0:\n                    return (max(maxLeftX,maxLeftY) + min(minRightX,minRightY))/2\n                else:\n                    return max(maxLeftY,maxLeftX)\n            elif(maxLeftX>minRightY):\n                high=partitionX-1\n            else:\n                low=partitionX+1\n\n```, status: null, voteStatus: 0, voteCount: 9, creationDate: 1566277855, isHidden: null, author: {username: harshsaini697, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/harshsaini697/avatar_1521925806.png, reputation: 13}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 1016, solutions: [{id: 4212564, title: âœ… Beats 96.49% ðŸ”¥ || 5 Different Approaches ðŸ’¡ || Brute Force || EAC || DP || MA || Recursion ||, commentCount: 25, topLevelCommentCount: 23, viewCount: 109825, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Math, slug: math}, {name: Two Pointers, slug: two-pointers}, {name: String, slug: string}, {name: Dynamic Programming, slug: dynamic-programming}, {name: Recursion, slug: recursion}, {name: Memoization, slug: memoization}, {name: Sliding Window, slug: sliding-window}], post: {id: 6328017, content: ### It takes a lot of efforts to write such long explanatinon, so please UpVote \u2B06\uFE0F if this helps you.\n\n# Approach 1: Brute Force\n\n![image.png](https://assets.leetcode.com/users/images/78b06edf-2497-4fad-bc79-f94571e74384_1698375305.7151458.png)\n\n# Intuition :\n\n**The obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of n^2 such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3).**\n\n# Algorithm :\n1. Pick a starting index for the current substring which is every index from 0 to n-2.\n2. Now, pick the ending index for the current substring which is every index from i+1 to n-1.\n3. Check if the substring from ith index to jth index is a palindrome.\n4. If step 3 is true and length of substring is greater than maximum length so far, update maximum length and maximum substring. \n5. Print the maximum substring.\n\n# Complexity Analysis\n- Time complexity : ***O(n^3)***. Assume that n is the length of the input string, there are a total of C(n, 2) = n(n-1)/2 substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3).\n\n- Space complexity : ***O(1)***.\n\n# Code\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        Max_Len=1\n        Max_Str=s[0]\n        for i in range(len(s)-1):\n            for j in range(i+1,len(s)):\n                if j-i+1 > Max_Len and s[i:j+1] == s[i:j+1][::-1]:\n                    Max_Len = j-i+1\n                    Max_Str = s[i:j+1]\n\n        return Max_Str\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n        \n        int max_len = 1;\n        std::string max_str = s.substr(0, 1);\n        \n        for (int i = 0; i < s.length(); ++i) {\n            for (int j = i + max_len; j <= s.length(); ++j) {\n                if (j - i > max_len && isPalindrome(s.substr(i, j - i))) {\n                    max_len = j - i;\n                    max_str = s.substr(i, j - i);\n                }\n            }\n        }\n\n        return max_str;\n    }\n\nprivate:\n    bool isPalindrome(const std::string& str) {\n        int left = 0;\n        int right = str.length() - 1;\n        \n        while (left < right) {\n            if (str[left] != str[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        \n        return true;\n    }\n};\n```\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n\n        int maxLen = 1;\n        String maxStr = s.substring(0, 1);\n\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + maxLen; j <= s.length(); j++) {\n                if (j - i > maxLen && isPalindrome(s.substring(i, j))) {\n                    maxLen = j - i;\n                    maxStr = s.substring(i, j);\n                }\n            }\n        }\n\n        return maxStr;\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n}\n```\n# Approach 2: Expand Around Center\n![Screenshot 2023-10-27 at 8.15.36\u202FAM.png](https://assets.leetcode.com/users/images/b3567687-6ca1-4f04-826c-b00df71ed695_1698376320.3664618.png)\n\n# Intuition :\n\n**To enumerate all palindromic substrings of a given string, we first expand a given string at each possible starting position of a palindrome and also at each possible ending position of a palindrome and keep track of the length of the longest palindrome we found so far.**\n\n# Approach :\n1. We observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n - 1 such centers.\n2. You might be asking why there are 2n - 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as "abba") and its center are between the two \'b\'s.\'\n3. Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n^2).\n\n# Algorithm :\n1. At starting we have maz_str = s[0] and max_len = 1 as every single character is a palindrome.\n2. Now, we will iterate over the string and for every character we will expand around its center.\n3. For odd length palindrome, we will consider the current character as the center and expand around it.\n4. For even length palindrome, we will consider the current character and the next character as the center and expand around it.\n5. We will keep track of the maximum length and the maximum substring.\n6. Print the maximum substring.\n\n# Complexity Analysis\n- Time complexity : ***O(n^2)***. Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n^2).\n\n- Space complexity : ***O(1)***.\n\n# Code\n\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n\n        def expand_from_center(left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        max_str = s[0]\n\n        for i in range(len(s) - 1):\n            odd = expand_from_center(i, i)\n            even = expand_from_center(i, i + 1)\n\n            if len(odd) > len(max_str):\n                max_str = odd\n            if len(even) > len(max_str):\n                max_str = even\n\n        return max_str\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n\n        auto expand_from_center = [&](int left, int right) {\n            while (left >= 0 && right < s.length() && s[left] == s[right]) {\n                left--;\n                right++;\n            }\n            return s.substr(left + 1, right - left - 1);\n        };\n\n        std::string max_str = s.substr(0, 1);\n\n        for (int i = 0; i < s.length() - 1; i++) {\n            std::string odd = expand_from_center(i, i);\n            std::string even = expand_from_center(i, i + 1);\n\n            if (odd.length() > max_str.length()) {\n                max_str = odd;\n            }\n            if (even.length() > max_str.length()) {\n                max_str = even;\n            }\n        }\n\n        return max_str;\n    }\n};\n```\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n\n        String maxStr = s.substring(0, 1);\n\n        for (int i = 0; i < s.length() - 1; i++) {\n            String odd = expandFromCenter(s, i, i);\n            String even = expandFromCenter(s, i, i + 1);\n\n            if (odd.length() > maxStr.length()) {\n                maxStr = odd;\n            }\n            if (even.length() > maxStr.length()) {\n                maxStr = even;\n            }\n        }\n\n        return maxStr;\n    }\n\n    private String expandFromCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return s.substring(left + 1, right);\n    }\n}\n\n```\n# Approach 3: Dynamic Programming\n\n\n\n# Intuition :\n![image.png](https://assets.leetcode.com/users/images/5f0486ea-e4ea-4ca0-96e7-ecfa1d02b813_1698376736.630049.png)\n\n**To improve over the brute force solution, we first observe how we can avoid unnecessary re-computation while validating palindromes. Consider the case "ababa". If we already knew that "bab" is a palindrome, it is obvious that "ababa" must be a palindrome since the two left and right end letters are the same.**\n\n# Algorithm :\n1. We initialize a boolean table dp and mark all the values as false.\n2. We will use a variable max_len to keep track of the maximum length of the palindrome.\n3. We will iterate over the string and mark the diagonal elements as true as every single character is a palindrome.\n4. Now, we will iterate over the string and for every character we will expand around its center.\n5. For odd length palindrome, we will consider the current character as the center and expand around it.\n6. For even length palindrome, we will consider the current character and the next character as the center and expand around it.\n7. We will keep track of the maximum length and the maximum substring.\n8. Print the maximum substring.\n\n# Complexity Analysis\n- Time complexity : ***O(n^2)***. This gives us a runtime complexity of O(n^2).\n\n- Space complexity : ***O(n^2)***. It uses O(n^2) space to store the table.\n# Code\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        Max_Len=1\n        Max_Str=s[0]\n        dp = [[False for _ in range(len(s))] for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][i] = True\n            for j in range(i):\n                if s[j] == s[i] and (i-j <= 2 or dp[j+1][i-1]):\n                    dp[j][i] = True\n                    if i-j+1 > Max_Len:\n                        Max_Len = i-j+1\n                        Max_Str = s[j:i+1]\n        return Max_Str\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n        \n        int max_len = 1;\n        int start = 0;\n        int end = 0;\n        std::vector<std::vector<bool>> dp(s.length(), std::vector<bool>(s.length(), false));\n        \n        for (int i = 0; i < s.length(); ++i) {\n            dp[i][i] = true;\n            for (int j = 0; j < i; ++j) {\n                if (s[j] == s[i] && (i - j <= 2 || dp[j + 1][i - 1])) {\n                    dp[j][i] = true;\n                    if (i - j + 1 > max_len) {\n                        max_len = i - j + 1;\n                        start = j;\n                        end = i;\n                    }\n                }\n            }\n        }\n        \n        return s.substr(start, end - start + 1);\n    }\n};\n\n```\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n\n        int maxLen = 1;\n        int start = 0;\n        int end = 0;\n        boolean[][] dp = new boolean[s.length()][s.length()];\n\n        for (int i = 0; i < s.length(); ++i) {\n            dp[i][i] = true;\n            for (int j = 0; j < i; ++j) {\n                if (s.charAt(j) == s.charAt(i) && (i - j <= 2 || dp[j + 1][i - 1])) {\n                    dp[j][i] = true;\n                    if (i - j + 1 > maxLen) {\n                        maxLen = i - j + 1;\n                        start = j;\n                        end = i;\n                    }\n                }\n            }\n        }\n\n        return s.substring(start, end + 1);\n    }\n}\n\n```\n\n# Approach 4: Manacher\'s Algorithm\n![image.png](https://assets.leetcode.com/users/images/d1f87cd6-3624-45dc-98f9-d835021a1893_1698377008.9028504.png)\n\n# Intuition :\n\n**To avoid the unnecessary validation of palindromes, we can use Manacher\'s algorithm. The algorithm is explained brilliantly in this article. The idea is to use palindrome property to avoid unnecessary validations. We maintain a center and right boundary of a palindrome. We use previously calculated values to determine if we can expand around the center or not. If we can expand, we expand and update the center and right boundary. Otherwise, we move to the next character and repeat the process. We also maintain a variable max_len to keep track of the maximum length of the palindrome. We also maintain a variable max_str to keep track of the maximum substring.**\n\n# Algorithm :\n1. We initialize a boolean table dp and mark all the values as false.\n2. We will use a variable max_len to keep track of the maximum length of the palindrome.\n3. We will iterate over the string and mark the diagonal elements as true as every single character is a palindrome.\n4. Now, we will iterate over the string and for every character we will expand around its center.\n5. For odd length palindrome, we will consider the current character as the center and expand around it.\n6. For even length palindrome, we will consider the current character and the next character as the center and expand around it.\n7. We will keep track of the maximum length and the maximum substring.\n8. Print the maximum substring.\n\n# Complexity Analysis\n- Time complexity : ***O(n)***. Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n).\n\n- Space complexity : ***O(n)***. It uses O(n) space to store the table.\n\n# Code\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        Max_Len=1\n        Max_Str=s[0]\n        s = \'#\' + \'#\'.join(s) + \'#\'\n        dp = [0 for _ in range(len(s))]\n        center = 0\n        right = 0\n        for i in range(len(s)):\n            if i < right:\n                dp[i] = min(right-i, dp[2*center-i])\n            while i-dp[i]-1 >= 0 and i+dp[i]+1 < len(s) and s[i-dp[i]-1] == s[i+dp[i]+1]:\n                dp[i] += 1\n            if i+dp[i] > right:\n                center = i\n                right = i+dp[i]\n            if dp[i] > Max_Len:\n                Max_Len = dp[i]\n                Max_Str = s[i-dp[i]:i+dp[i]+1].replace(\'#\',\'\')\n        return Max_Str\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n        \n        int maxLen = 1;\n        std::string maxStr = s.substr(0, 1);\n        s = "#" + std::regex_replace(s, std::regex(""), "#") + "#";\n        std::vector<int> dp(s.length(), 0);\n        int center = 0;\n        int right = 0;\n        \n        for (int i = 0; i < s.length(); ++i) {\n            if (i < right) {\n                dp[i] = std::min(right - i, dp[2 * center - i]);\n            }\n            \n            while (i - dp[i] - 1 >= 0 && i + dp[i] + 1 < s.length() && s[i - dp[i] - 1] == s[i + dp[i] + 1]) {\n                dp[i]++;\n            }\n            \n            if (i + dp[i] > right) {\n                center = i;\n                right = i + dp[i];\n            }\n            \n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                maxStr = s.substr(i - dp[i], 2 * dp[i] + 1);\n                maxStr.erase(std::remove(maxStr.begin(), maxStr.end(), \'#\'), maxStr.end());\n            }\n        }\n        \n        return maxStr;\n    }\n};\n\n```\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n\n        int maxLen = 1;\n        String maxStr = s.substring(0, 1);\n        s = "#" + s.replaceAll("", "#") + "#";\n        int[] dp = new int[s.length()];\n        int center = 0;\n        int right = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (i < right) {\n                dp[i] = Math.min(right - i, dp[2 * center - i]);\n            }\n\n            while (i - dp[i] - 1 >= 0 && i + dp[i] + 1 < s.length() && s.charAt(i - dp[i] - 1) == s.charAt(i + dp[i] + 1)) {\n                dp[i]++;\n            }\n\n            if (i + dp[i] > right) {\n                center = i;\n                right = i + dp[i];\n            }\n\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                maxStr = s.substring(i - dp[i], i + dp[i] + 1).replaceAll("#", "");\n            }\n        }\n\n        return maxStr;\n    }\n}\n```\n\n# Approach 5: Recursive TLE(Time Limit Exceeded)\n\n# Intuition :\n\n**The obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of n^2 such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3). But in this approach we will use recursion to solve the problem. We will check if the string is a palindrome or not. If it is a palindrome, we will return the string. Otherwise, we will recursively call the function for the string excluding the first character and for the string excluding the last character. We will check the length of the returned strings and return the string with the maximum length.**\n\n# Algorithm :\n1. If the string is a palindrome, we will return the string.\n2. Otherwise, we will recursively call the function for the string excluding the first character and for the string excluding the last character.\n3. We will check the length of the returned strings and return the string with the maximum length.\n\n# Complexity Analysis   \n- Time complexity : ***O(n^3)***. Assume that n is the length of the input string, there are a total of C(n, 2) = n(n-1)/2 substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3).\n\n- Space complexity : ***O(n)***. The recursion stack may go up to n levels deep.\n# Code\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n\n        if s==s[::-1]: \n            return s\n        left = self.longestPalindrome(s[1:])\n        right = self.longestPalindrome(s[:-1])\n\n        if len(left)>len(right):\n            return left\n        else:\n            return right\n```\n``` C++ []\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        if (s == string(s.rbegin(), s.rend())) {\n            return s;\n        }\n\n        string left = longestPalindrome(s.substr(1));\n        string right = longestPalindrome(s.substr(0, s.size() - 1));\n\n        if (left.length() > right.length()) {\n            return left;\n        } else {\n            return right;\n        }\n    }\n};\n\n```\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        if (s.equals(new StringBuilder(s).reverse().toString())) {\n            return s;\n        }\n\n        String left = longestPalindrome(s.substring(1));\n        String right = longestPalindrome(s.substring(0, s.length() - 1));\n\n        if (left.length() > right.length()) {\n            return left;\n        } else {\n            return right;\n        }\n    }\n}\n```\n\n![image.png](https://assets.leetcode.com/users/images/31b96fa7-3627-4fbb-b824-0701483fd93e_1698377636.1044633.png)\n, status: null, voteStatus: 0, voteCount: 1134, creationDate: 1698377999, isHidden: null, author: {username: Gourav-2002, isActive: true, nameColor: null, activeBadge: {displayName: Nov LeetCoding Challenge, icon: /static/images/badges/dcc-2023-11.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1694533187.png, reputation: 2649}}}, searchMeta: null}, {id: 900639, title: Python Solution : with detailed explanation : using DP, commentCount: 64, topLevelCommentCount: 33, viewCount: 119900, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 1640572, content: ####  Approach (implemented Dp rules)\n* #####             Definition : the row and col in the dp table represent the slicing index on the string s  (inclusive)\n* #####                 example s = \'babad\'  -- > dp[2][3] = s[2:3] = ba\n#####             Steps : \n* #####             Fill the diagonal with True, b/c every single character by itself is palindrom \n* #####             Don\'t traverse in the bottom part of the diagonal \n\t* #####                 Becuase, that represent reverse slicing (which is not valid)\n#####             \n* #####             Iterate backward starting from the most right bottom cell to top (only on the right side of the digonal) \n\t* #####                 How ? \n\t\t* ##### \t\tStart itertating backward for the outer loop (i) and for the inner loop (j) iterate forward starting from the index of outer loop ) : see the code (the for loops) \n#####                 \n* #####                 - Pick character from the input string based on the at i and j position, If the characters matches : you need to check two conditions\n\t* #####                     1. If the length of the sub_string is just one (a letter matching is good to be a palindrom)\n\t* #####                     2. But if the length of the sub_string is > 1 \n\t\t* #####                         - You need to check if the inner sub_sting is also palindrom\n\t\t* #####                             - How ?\n\t\t\t* #####                                 - You go to the left bottom corner and check if it is True \n\t\t\t* #####                                     - Left bottom corrner represent the inner sub_string of the current_sub_string \n\t\t\t\t* #####                                         -Eg. if  dp[i][j]= cur_sub_string = \'ababa\' --> True because dp[i+1][j-1] is True\n\t\t\t\t* #####                                                  dp[i+1][j-1] = \'bab\' = True\n\t\t\t\t* #####                                          .Howerver if  dp[i][j]= cur_sub_string = \'abaca\'  --> False because  dp[i+1][j-1] is False\n\t\t\t\t* #####                                                  dp[i+1][j-1] = \'bac\' = False  --> not palindrom \n\t\t* #####                                                  \n\t\t* #####                         If dp[i+1][j-1] == True:\n\t\t\t* #####                             Ok that means the current sub_string is also palindrom                      \n\t\t* #####                             - Now compare the length of the current_palindrom sub_string with the prvious longest one and take the max\n* #####                 - Else : the characters don\'t match\n\t* #####                     Just pass\n* #####             - Finally return the maximum number in the dp\n* ##### If this solution/explanation helps you, don\'t forget to upvote as appreciation\n\n```\ndef longestPalindrome(self, s):\n        longest_palindrom = \'\'\n        dp = [[0]*len(s) for _ in range(len(s))]\n        #filling out the diagonal by 1\n        for i in range(len(s)):\n            dp[i][i] = True\n            longest_palindrom = s[i]\n\t\t\t\n        # filling the dp table\n        for i in range(len(s)-1,-1,-1):\n\t\t\t\t# j starts from the i location : to only work on the upper side of the diagonal \n            for j in range(i+1,len(s)):  \n                if s[i] == s[j]:  #if the chars mathces\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\n                    if j-i ==1 or dp[i+1][j-1] is True:\n                        dp[i][j] = True\n                        # we also need to keep track of the maximum palindrom sequence \n                        if len(longest_palindrom) < len(s[i:j+1]):\n                            longest_palindrom = s[i:j+1]\n                \n        return longest_palindrom\n```, status: null, voteStatus: 0, voteCount: 740, creationDate: 1603051195, isHidden: null, author: {username: Abeni, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/abeni/avatar_1583246286.png, reputation: 2057}}}, searchMeta: null}, {id: 474664, title: Commented clean Python DP solution, commentCount: 24, topLevelCommentCount: 10, viewCount: 33267, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 900600, content: ```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n        n = len(s)\n        # Form a bottom-up dp 2d array\n        # dp[i][j] will be \'true\' if the string from index i to j is a palindrome. \n        dp = [[False] * n  for _ in range(n)]\n        \n        ans = \'\'\n        # every string with one character is a palindrome\n        for i in range(n):\n            dp[i][i] = True\n            ans = s[i]\n            \n        maxLen = 1\n        for start in range(n-1, -1, -1):\n            for end in range(start+1, n):             \n\t\t\t\t# palindrome condition\n                if s[start] == s[end]:\n                    # if it\'s a two char. string or if the remaining string is a palindrome too\n                    if end - start == 1 or dp[start+1][end-1]:\n                        dp[start][end] = True\n                        if maxLen < end - start + 1:\n                            maxLen = end - start + 1\n                            ans = s[start: end+ 1]\n        \n        return ans\n```\nIf this solution helps you, don\'t forget to upvote it., status: null, voteStatus: 0, voteCount: 207, creationDate: 1578523355, isHidden: null, author: {username: game123web, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 224}}}, searchMeta: null}, {id: 468326, title: Clean Python 3 Solution (Faster than 85% & Memory Usage Less Than 100%), commentCount: 14, topLevelCommentCount: 11, viewCount: 13252, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 889851, content: ```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        p = \'\'\n        for i in range(len(s)):\n            p1 = self.get_palindrome(s, i, i+1)\n            p2 = self.get_palindrome(s, i, i)\n            p = max([p, p1, p2], key=len)\n        return p\n    \n    def get_palindrome(self, s: str, l: int, r: int) -> str:\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return s[l+1:r]\n```, status: null, voteStatus: 0, voteCount: 85, creationDate: 1577994773, isHidden: null, author: {username: gizmoy, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/gizmoy/avatar_1587275427.png, reputation: 170}}}, searchMeta: null}, {id: 2156659, title: âœ…  Python Easy O(1) Space approach, commentCount: 16, topLevelCommentCount: 6, viewCount: 19753, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 3599711, content: The following solution is kinda brute force approach. We expand the string around a given index.\n> eg: input string : **ababd**\n\nLet\'s say we expand around position `2`. The longest pallindrome that we can from position `2` is `bab`. But if we expand from a single character position, we would always end up with an odd length pallindrome. To find an even length pallindrome, we need to expand around two positions.\n\n>eg: input string : **abaabd**\n\nLet\'s say we expand around position `2` and `3`.  The longest pallindrome that we can form from these positions  is `baab`. So we ended up with a longer pallindrome compared to the previous find.\n\nWe will use the above logic to find possible even and odd lengthed pallindromes from all positions in the string.\nBelow is my implementation for the same:\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n=len(s)\n        def expand_pallindrome(i,j):            \n            while 0<=i<=j<n and s[i]==s[j]:\n                i-=1\n                j+=1                            \n            return (i+1, j)\n        \n        res=(0,0)\n        for i in range(n):\n            b1 = expand_pallindrome(i,i)\n            b2 = expand_pallindrome(i,i+1)            \n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\n                    \n        return s[res[0]:res[1]]    \n```\n\nA more concise variation: \n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n=len(s)\n        def expand_center(i,j):            \n            while 0<=i<=j<n and s[i]==s[j]:\n                i-=1\n                j+=1                \n            \n            return (i+1, j)                \n        \n        res=max([expand_center(i,i+offset) for i in range(n) for offset in range(2)], key=lambda x: x[1]-x[0]+1)\n        \n        return s[res[0]:res[1]]\n```\n\n**Time - O(n * n)** where `n` is the length of the input string\n**Space - O(1)**\n\n---\n\n***Please upvote if you find it useful***, status: null, voteStatus: 0, voteCount: 66, creationDate: 1655339304, isHidden: null, author: {username: constantine786, isActive: true, nameColor: null, activeBadge: {displayName: Jun LeetCoding Challenge, icon: /static/images/badges/dcc-2022-6.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1649842449.png, reputation: 2503}}}, searchMeta: null}, {id: 4212441, title: ðŸ”¥Expand Around Center & ðŸ”¥100% Manacher's Algorithm | Java | C++ | Py | Js| C# | PHP, commentCount: 4, topLevelCommentCount: 4, viewCount: 10516, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}, {name: PHP, slug: php}, {name: String, slug: string}], post: {id: 6327852, content: # 1st Method :- Expand Around Center \uD83D\uDEA9\n## Intuition \uD83D\uDE80:\n\nThe intuition behind this code is to find the longest palindromic substring within a given input string `s`. A palindromic substring is a string that reads the same forwards and backward. To achieve this, the code explores the input string character by character, checking both odd and even-length palindromes by expanding around the center of each character and updating the longest palindrome found so far.\n\n## Approach \uD83D\uDE80:\n\n1. **Initialization**: \n   - Check if the input string `s` is empty. If it is, return an empty string because there can\'t be any palindromes in an empty string.\n   - Initialize a variable `longestPalindromeIndices` to store the indices of the longest palindrome found. Initially, it\'s set to [0, 0].\n\n2. **Main Loop**:\n   - Iterate through the characters of the input string `s` using a for loop.\n\n3. **Odd-Length Palindromes**:\n   - For each character at position `i`, check if there is a palindrome centered at that character. This is done by calling the `expandAroundCenter` function with `i` as both the start and end positions.\n   - If a longer palindrome is found than the current longest one, update `longestPalindromeIndices` with the new indices.\n\n4. **Even-Length Palindromes**:\n   - Check if there is a palindrome centered between the characters at positions `i` and `i + 1`. This is done by calling the `expandAroundCenter` function with `i` as the start position and `i + 1` as the end position.\n   - If a longer even-length palindrome is found, update `longestPalindromeIndices` with the new indices.\n\n5. **Continuation**:\n   - Continue this process for all characters in the input string. By the end of the loop, you will have identified the indices of the longest palindromic substring.\n\n6. **Result Extraction**:\n   - Finally, extract the longest palindromic substring from the input string `s` using the indices obtained in `longestPalindromeIndices`.\n   - Return this extracted substring as the result.\n\nThe key idea is to systematically explore the input string, checking both odd and even-length palindromes by expanding around the center of each character and maintaining the information about the longest palindrome found throughout the process. This approach ensures that you find the maximum length palindromic substring within the input string.\n## Complexity \uD83D\uDE81\n### \uD83C\uDFF9 Time complexity: O(N^2)\n\n1. The `expandAroundCenter` function has a time complexity of O(N), where N is the length of the input string `s`. This is because in the worst case, it can expand all the way to the ends of the string.\n2. The `longestPalindrome` function iterates through the characters of the string, and for each character, it may call `expandAroundCenter` once or twice (in the case of even-length palindromes). Therefore, the time complexity of the `longestPalindrome` function is O(N^2).\n\nSo, the overall time complexity of the code is O(N^2) due to the nested loops in the `longestPalindrome` function.\n\n### \uD83C\uDFF9 Space complexity: O(1)\n\nThe space complexity is primarily determined by the additional space used for variables and the recursive call stack.\n\n1. The `expandAroundCenter` function uses a constant amount of extra space, so its space complexity is O(1).\n2. The `longestPalindrome` function uses a few additional integer variables to store indices, but the space used by these variables is also constant, so its space complexity is O(1).\n3. The recursive calls in the `expandAroundCenter` function do not use significant additional space because they are tail-recursive. The stack space used by these calls is O(1).\n\nSo, the overall space complexity of the code is O(1).\n\n## Code \u2712\uFE0F\n``` Java []\nclass Solution {\n    public String longestPalindrome(String s) {\n        // Check if the input string is empty, return an empty string if so\n        if (s.isEmpty())\n            return "";\n\n        // Initialize variables to store the indices of the longest palindrome found\n        int[] longestPalindromeIndices = { 0, 0 };\n\n        // Loop through the characters in the input string\n        for (int i = 0; i < s.length(); ++i) {\n            // Find the indices of the longest palindrome centered at character i\n            int[] currentIndices = expandAroundCenter(s, i, i);\n\n            // Compare the length of the current palindrome with the longest found so far\n            if (currentIndices[1] - currentIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                // Update the longest palindrome indices if the current one is longer\n                longestPalindromeIndices = currentIndices;\n            }\n\n            // Check if there is a possibility of an even-length palindrome centered at\n            // character i and i+1\n            if (i + 1 < s.length() && s.charAt(i) == s.charAt(i + 1)) {\n                // Find the indices of the longest even-length palindrome centered at characters\n                // i and i+1\n                int[] evenIndices = expandAroundCenter(s, i, i + 1);\n\n                // Compare the length of the even-length palindrome with the longest found so\n                // far\n                if (evenIndices[1] - evenIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                    // Update the longest palindrome indices if the even-length one is longer\n                    longestPalindromeIndices = evenIndices;\n                }\n            }\n        }\n\n        // Extract and return the longest palindrome substring using the indices\n        return s.substring(longestPalindromeIndices[0], longestPalindromeIndices[1] + 1);\n    }\n\n    // Helper function to find and return the indices of the longest palindrome\n    // extended from s[i..j] (inclusive) by expanding around the center\n    private int[] expandAroundCenter(final String s, int i, int j) {\n        // Expand the palindrome by moving outward from the center while the characters\n        // match\n        while (i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n            i--; // Move the left index to the left\n            j++; // Move the right index to the right\n        }\n        // Return the indices of the longest palindrome found\n        return new int[] { i + 1, j - 1 };\n    }\n}\n\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        // Check if the input string is empty, return an empty string if so\n        if (s.empty())\n            return "";\n\n        // Initialize variables to store the indices of the longest palindrome found\n        std::vector<int> longestPalindromeIndices = {0, 0};\n\n        for (int i = 0; i < s.length(); ++i) {\n            // Find the indices of the longest palindrome centered at character i\n            std::vector<int> currentIndices = expandAroundCenter(s, i, i);\n\n            // Compare the length of the current palindrome with the longest found so far\n            if (currentIndices[1] - currentIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                longestPalindromeIndices = currentIndices;\n            }\n\n            // Check if there is a possibility of an even-length palindrome centered at\n            // character i and i+1\n            if (i + 1 < s.length() && s[i] == s[i + 1]) {\n                // Find the indices of the longest even-length palindrome centered at characters\n                // i and i+1\n                std::vector<int> evenIndices = expandAroundCenter(s, i, i + 1);\n\n                // Compare the length of the even-length palindrome with the longest found so far\n                if (evenIndices[1] - evenIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                    longestPalindromeIndices = evenIndices;\n                }\n            }\n        }\n\n        // Extract and return the longest palindrome substring using the indices\n        return s.substr(longestPalindromeIndices[0], longestPalindromeIndices[1] - longestPalindromeIndices[0] + 1);\n    }\n\nprivate:\n    // Helper function to find and return the indices of the longest palindrome\n    // extended from s[i..j] (inclusive) by expanding around the center\n    std::vector<int> expandAroundCenter(const std::string &s, int i, int j) {\n        while (i >= 0 && j < s.length() && s[i] == s[j]) {\n            --i;\n            ++j;\n        }\n        return {i + 1, j - 1};\n    }\n};\n\n```\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        # Check if the input string is empty, return an empty string if so\n        if not s:\n            return ""\n\n        # Initialize variables to store the indices of the longest palindrome found\n        longest_palindrome_indices = [0, 0]\n\n        def expand_around_center(s, i, j):\n            # Helper function to find and return the indices of the longest palindrome\n            # extended from s[i..j] (inclusive) by expanding around the center\n            while i >= 0 and j < len(s) and s[i] == s[j]:\n                i -= 1\n                j += 1\n            return [i + 1, j - 1]\n\n        for i in range(len(s)):\n            current_indices = expand_around_center(s, i, i)\n\n            # Compare the length of the current palindrome with the longest found so far\n            if current_indices[1] - current_indices[0] > longest_palindrome_indices[1] - longest_palindrome_indices[0]:\n                longest_palindrome_indices = current_indices\n\n            if i + 1 < len(s) and s[i] == s[i + 1]:\n                even_indices = expand_around_center(s, i, i + 1)\n\n                # Compare the length of the even-length palindrome with the longest found so far\n                if even_indices[1] - even_indices[0] > longest_palindrome_indices[1] - longest_palindrome_indices[0]:\n                    longest_palindrome_indices = even_indices\n\n        # Extract and return the longest palindrome substring using the indices\n        return s[longest_palindrome_indices[0]:longest_palindrome_indices[1] + 1]\n\n```\n``` JavaScript []\nvar longestPalindrome = function(s) {\n    // Check if the input string is empty, return an empty string if so\n    if (s.length === 0)\n        return "";\n\n    // Initialize variables to store the indices of the longest palindrome found\n    let longestPalindromeIndices = [0, 0];\n\n    // Loop through the characters in the input string\n    for (let i = 0; i < s.length; ++i) {\n        // Find the indices of the longest palindrome centered at character i\n        let currentIndices = expandAroundCenter(s, i, i);\n\n        // Compare the length of the current palindrome with the longest found so far\n        if (currentIndices[1] - currentIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n            // Update the longest palindrome indices if the current one is longer\n            longestPalindromeIndices = currentIndices;\n        }\n\n        // Check if there is a possibility of an even-length palindrome centered at\n        // character i and i+1\n        if (i + 1 < s.length && s[i] === s[i + 1]) {\n            // Find the indices of the longest even-length palindrome centered at characters\n            // i and i+1\n            let evenIndices = expandAroundCenter(s, i, i + 1);\n\n            // Compare the length of the even-length palindrome with the longest found so\n            // far\n            if (evenIndices[1] - evenIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                // Update the longest palindrome indices if the even-length one is longer\n                longestPalindromeIndices = evenIndices;\n            }\n        }\n    }\n\n    // Extract and return the longest palindrome substring using the indices\n    return s.slice(longestPalindromeIndices[0], longestPalindromeIndices[1] + 1);\n}\n\n// Helper function to find and return the indices of the longest palindrome\n// extended from s[i..j] (inclusive) by expanding around the center\nfunction expandAroundCenter(s, i, j) {\n    // Expand the palindrome by moving outward from the center while the characters match\n    while (i >= 0 && j < s.length && s[i] === s[j]) {\n        i--; // Move the left index to the left\n        j++; // Move the right index to the right\n    }\n    // Return the indices of the longest palindrome found\n    return [i + 1, j - 1];\n}\n\n```\n``` C# []\npublic class Solution {\n    public string LongestPalindrome(string s) {\n        // Check if the input string is empty, return an empty string if so\n        if (string.IsNullOrEmpty(s))\n            return "";\n\n        // Initialize variables to store the indices of the longest palindrome found\n        int[] longestPalindromeIndices = { 0, 0 };\n\n        // Loop through the characters in the input string\n        for (int i = 0; i < s.Length; ++i) {\n            // Find the indices of the longest palindrome centered at character i\n            int[] currentIndices = ExpandAroundCenter(s, i, i);\n\n            // Compare the length of the current palindrome with the longest found so far\n            if (currentIndices[1] - currentIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                // Update the longest palindrome indices if the current one is longer\n                longestPalindromeIndices = currentIndices;\n            }\n\n            // Check if there is a possibility of an even-length palindrome centered at\n            // character i and i+1\n            if (i + 1 < s.Length && s[i] == s[i + 1]) {\n                // Find the indices of the longest even-length palindrome centered at characters\n                // i and i+1\n                int[] evenIndices = ExpandAroundCenter(s, i, i + 1);\n\n                // Compare the length of the even-length palindrome with the longest found so\n                // far\n                if (evenIndices[1] - evenIndices[0] > longestPalindromeIndices[1] - longestPalindromeIndices[0]) {\n                    // Update the longest palindrome indices if the even-length one is longer\n                    longestPalindromeIndices = evenIndices;\n                }\n            }\n        }\n\n        // Extract and return the longest palindrome substring using the indices\n        return s.Substring(longestPalindromeIndices[0], longestPalindromeIndices[1] - longestPalindromeIndices[0] + 1);\n    }\n\n    // Helper function to find and return the indices of the longest palindrome\n    // extended from s[i..j] (inclusive) by expanding around the center\n    private int[] ExpandAroundCenter(string s, int i, int j) {\n        // Expand the palindrome by moving outward from the center while the characters match\n        while (i >= 0 && j < s.Length && s[i] == s[j]) {\n            i--; // Move the left index to the left\n            j++; // Move the right index to the right\n        }\n        // Return the indices of the longest palindrome found\n        return new int[] { i + 1, j - 1 };\n    }\n}\n```\n``` PHP []\nclass Solution {\n    public function longestPalindrome($s) {\n        // Check if the input string is empty, return an empty string if so\n        if (empty($s)) {\n            return "";\n        }\n\n        // Initialize variables to store the indices of the longest palindrome found\n        $longestPalindromeIndices = array(0, 0);\n\n        // Loop through the characters in the input string\n        for ($i = 0; $i < strlen($s); ++$i) {\n            // Find the indices of the longest palindrome centered at character i\n            $currentIndices = $this->expandAroundCenter($s, $i, $i);\n\n            // Compare the length of the current palindrome with the longest found so far\n            if ($currentIndices[1] - $currentIndices[0] > $longestPalindromeIndices[1] - $longestPalindromeIndices[0]) {\n                // Update the longest palindrome indices if the current one is longer\n                $longestPalindromeIndices = $currentIndices;\n            }\n\n            // Check if there is a possibility of an even-length palindrome centered at\n            // character i and i+1\n            if ($i + 1 < strlen($s) && $s[$i] == $s[$i + 1]) {\n                // Find the indices of the longest even-length palindrome centered at characters\n                // i and i+1\n                $evenIndices = $this->expandAroundCenter($s, $i, $i + 1);\n\n                // Compare the length of the even-length palindrome with the longest found so\n                // far\n                if ($evenIndices[1] - $evenIndices[0] > $longestPalindromeIndices[1] - $longestPalindromeIndices[0]) {\n                    // Update the longest palindrome indices if the even-length one is longer\n                    $longestPalindromeIndices = $evenIndices;\n                }\n            }\n        }\n\n        // Extract and return the longest palindrome substring using the indices\n        return substr($s, $longestPalindromeIndices[0], $longestPalindromeIndices[1] - $longestPalindromeIndices[0] + 1);\n    }\n\n    // Helper function to find and return the indices of the longest palindrome\n    // extended from s[i..j] (inclusive) by expanding around the center\n    private function expandAroundCenter($s, $i, $j) {\n        // Expand the palindrome by moving outward from the center while the characters match\n        while ($i >= 0 && $j < strlen($s) && $s[$i] == $s[$j]) {\n            $i--; // Move the left index to the left\n            $j++; // Move the right index to the right\n        }\n        // Return the indices of the longest palindrome found\n        return array($i + 1, $j - 1);\n    }\n}\n```\n![vote.jpg](https://assets.leetcode.com/users/images/6abbd7cf-6e46-4efe-ab50-c5ebc2bdc632_1698374053.3694885.jpeg)\n\n---\n\n# 2nd Method :- Manacher\'s Algorithm \uD83D\uDEA9\n\n## Intuition \uD83D\uDE80:\nThe code implements Manacher\'s algorithm, which is designed to find the longest palindromic substring in a given string. The algorithm is an efficient way to tackle this problem and is based on the following key ideas:\n\n1. Utilize symmetry: Palindromes have a property of symmetry, which means their left and right sides are mirror images of each other. Manacher\'s algorithm takes advantage of this property to optimize the process.\n\n2. Avoid redundant computations: The algorithm uses previously computed information to avoid redundant checks, which makes it more efficient than brute force methods.\n\n## Approach \uD83D\uDE80:\n\n1. **Preprocessing**:\n   - The input string `s` is preprocessed to create a modified string `T` with special characters (^, #, and dollar ) inserted between each character to simplify palindrome detection.\n\n2. **Initialization**:\n   - Initialize variables:\n     - `strLength` for the length of the modified string `T`.\n     - `palindromeLengths`, an array to store the lengths of palindromes centered at each position in `T`.\n     - `center` for the current center of the palindrome being processed.\n     - `rightEdge` for the rightmost edge of the palindrome found so far.\n\n3. **Palindrome Detection**:\n   - Loop through the modified string `T` to find palindromes centered at each position.\n   - Calculate the length of the palindrome at the current position `i` based on previously computed information and expand it if possible. This is done by comparing characters around the current position.\n   - Update `center` and `rightEdge` if a longer palindrome is found.\n\n4. **Find the Longest Palindrome**:\n   - After processing the entire modified string `T`, identify the longest palindrome by searching the `palindromeLengths` array for the maximum value.\n   - Determine the center of this longest palindrome.\n\n5. **Extract the Result**:\n   - Use the information about the longest palindrome (center and length) in the modified string `T` to extract the corresponding substring from the original input string `s`.\n\nThe code effectively implements this approach to find and return the longest palindromic substring in the input string `s`. Manacher\'s algorithm is more efficient than naive methods because it takes advantage of the properties of palindromes and avoids redundant comparisons, making it a good choice for solving this problem.\n\n\n## Complexity \uD83D\uDE81\n### \uD83C\uDFF9 Time complexity: O(N)\nThe time complexity of Manacher\'s algorithm is O(N), where N is the length of the input string `s`. This is because the algorithm processes each character of the modified string exactly once (with some constant factor overhead) in a linear pass. The key factor in achieving this efficiency is the "center expansion" technique used to find palindromes, which avoids unnecessary character comparisons. \n\n### \uD83C\uDFF9 Space complexity: O(N)\nThe space complexity of the code is O(N) as well. This is primarily due to the creation of the modified string `T`, which is constructed by adding extra characters, such as \'^\', \'#\', and \'$\', to the original string. The `P` array used to store the lengths of palindromes at each position also has a space complexity of O(N) because it is an array of the same length as the modified string. The other variables used in the algorithm (e.g., `C`, `R`, and loop counters) have constant space requirements and do not significantly contribute to the space complexity.\n\nSo, in terms of both time and space complexity, this code is very efficient for finding the longest palindromic substring in a string.\n\n\n## Code \u2712\uFE0F\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        // Step 1: Preprocess the input string\n        StringBuilder processedStr = new StringBuilder("^#");\n        for (char c : s.toCharArray()) {\n            processedStr.append(c).append("#");\n        }\n        processedStr.append("$");\n        String modifiedString = processedStr.toString();\n\n        // Step 2: Initialize variables for the algorithm\n        int strLength = modifiedString.length();\n        int[] palindromeLengths = new int[strLength];\n        int center = 0;  // Current center of the palindrome\n        int rightEdge = 0;  // Rightmost edge of the palindrome\n\n        // Step 3: Loop through the modified string to find palindromes\n        for (int i = 1; i < strLength - 1; i++) {\n            palindromeLengths[i] = (rightEdge > i) ? Math.min(rightEdge - i, palindromeLengths[2 * center - i]) : 0;\n            \n            // Expand the palindrome around the current character\n            while (modifiedString.charAt(i + 1 + palindromeLengths[i]) == modifiedString.charAt(i - 1 - palindromeLengths[i])) {\n                palindromeLengths[i]++;\n            }\n            \n            // Update the rightmost edge and center if necessary\n            if (i + palindromeLengths[i] > rightEdge) {\n                center = i;\n                rightEdge = i + palindromeLengths[i];\n            }\n        }\n\n        // Step 4: Find the longest palindrome and its center\n        int maxLength = 0;\n        int maxCenter = 0;\n        for (int i = 0; i < strLength; i++) {\n            if (palindromeLengths[i] > maxLength) {\n                maxLength = palindromeLengths[i];\n                maxCenter = i;\n            }\n        }\n        \n        // Step 5: Extract the longest palindrome from the modified string\n        int start = (maxCenter - maxLength) / 2;\n        int end = start + maxLength;\n\n        // Return the longest palindrome in the original string\n        return s.substring(start, end);\n    }\n}\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        // Step 1: Preprocess the input string\n        std::string processedStr = "^#";\n        for (char c : s) {\n            processedStr.push_back(c);\n            processedStr.push_back(\'#\');\n        }\n        processedStr.push_back(\'$\');\n\n        // Step 2: Initialize variables for the algorithm\n        int strLength = processedStr.length();\n        std::vector<int> palindromeLengths(strLength, 0);\n        int center = 0;  // Current center of the palindrome\n        int rightEdge = 0;  // Rightmost edge of the palindrome\n\n        // Step 3: Loop through the modified string to find palindromes\n        for (int i = 1; i < strLength - 1; i++) {\n            palindromeLengths[i] = (rightEdge > i) ? std::min(rightEdge - i, palindromeLengths[2 * center - i]) : 0;\n\n            // Expand the palindrome around the current character\n            while (processedStr[i + 1 + palindromeLengths[i]] == processedStr[i - 1 - palindromeLengths[i]]) {\n                palindromeLengths[i]++;\n            }\n\n            // Update the rightmost edge and center if necessary\n            if (i + palindromeLengths[i] > rightEdge) {\n                center = i;\n                rightEdge = i + palindromeLengths[i];\n            }\n        }\n\n        // Step 4: Find the longest palindrome and its center\n        int maxLength = 0;\n        int maxCenter = 0;\n        for (int i = 0; i < strLength; i++) {\n            if (palindromeLengths[i] > maxLength) {\n                maxLength = palindromeLengths[i];\n                maxCenter = i;\n            }\n        }\n\n        // Step 5: Extract the longest palindrome from the modified string\n        int start = (maxCenter - maxLength) / 2;\n        int end = start + maxLength;\n\n        // Return the longest palindrome in the original string\n        return s.substr(start, end - start);\n    }\n};\n```\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        # Step 1: Preprocess the input string\n        processed_str = "^#"\n        for c in s:\n            processed_str += c + "#"\n        processed_str += "$"\n\n        # Step 2: Initialize variables for the algorithm\n        str_length = len(processed_str)\n        palindrome_lengths = [0] * str_length\n        center = 0  # Current center of the palindrome\n        right_edge = 0  # Rightmost edge of the palindrome\n\n        # Step 3: Loop through the modified string to find palindromes\n        for i in range(1, str_length - 1):\n            palindrome_lengths[i] = min(right_edge - i, palindrome_lengths[2 * center - i]) if right_edge > i else 0\n\n            # Expand the palindrome around the current character\n            while processed_str[i + 1 + palindrome_lengths[i]] == processed_str[i - 1 - palindrome_lengths[i]]:\n                palindrome_lengths[i] += 1\n\n            # Update the rightmost edge and center if necessary\n            if i + palindrome_lengths[i] > right_edge:\n                center = i\n                right_edge = i + palindrome_lengths[i]\n\n        # Step 4: Find the longest palindrome and its center\n        max_length = 0\n        max_center = 0\n        for i in range(str_length):\n            if palindrome_lengths[i] > max_length:\n                max_length = palindrome_lengths[i]\n                max_center = i\n\n        # Step 5: Extract the longest palindrome from the modified string\n        start = (max_center - max_length) // 2\n        end = start + max_length\n\n        # Return the longest palindrome in the original string\n        return s[start:end]\n```\n``` JavaScript []\nclass Solution {\n    longestPalindrome(s) {\n        // Step 1: Preprocess the input string\n        let processedStr = "^#";\n        for (let i = 0; i < s.length; i++) {\n            processedStr += s[i] + "#";\n        }\n        processedStr += "$";\n        let modifiedString = processedStr;\n\n        // Step 2: Initialize variables for the algorithm\n        let strLength = modifiedString.length;\n        let palindromeLengths = new Array(strLength).fill(0);\n        let center = 0;  // Current center of the palindrome\n        let rightEdge = 0;  // Rightmost edge of the palindrome\n\n        // Step 3: Loop through the modified string to find palindromes\n        for (let i = 1; i < strLength - 1; i++) {\n            palindromeLengths[i] = (rightEdge > i) ? Math.min(rightEdge - i, palindromeLengths[2 * center - i]) : 0;\n\n            // Expand the palindrome around the current character\n            while (modifiedString[i + 1 + palindromeLengths[i]] === modifiedString[i - 1 - palindromeLengths[i]]) {\n                palindromeLengths[i]++;\n            }\n\n            // Update the rightmost edge and center if necessary\n            if (i + palindromeLengths[i] > rightEdge) {\n                center = i;\n                rightEdge = i + palindromeLengths[i];\n            }\n        }\n\n        // Step 4: Find the longest palindrome and its center\n        let maxLength = 0;\n        let maxCenter = 0;\n        for (let i = 0; i < strLength; i++) {\n            if (palindromeLengths[i] > maxLength) {\n                maxLength = palindromeLengths[i];\n                maxCenter = i;\n            }\n        }\n\n        // Step 5: Extract the longest palindrome from the modified string\n        let start = (maxCenter - maxLength) / 2;\n        let end = start + maxLength;\n\n        // Return the longest palindrome in the original string\n        return s.substring(start, end);\n    }\n}\n```\n``` C# []\npublic class Solution {\n    public string LongestPalindrome(string s) {\n        // Step 1: Preprocess the input string\n        StringBuilder processedStr = new StringBuilder("^#");\n        foreach (char c in s) {\n            processedStr.Append(c).Append("#");\n        }\n        processedStr.Append("$");\n        string modifiedString = processedStr.ToString();\n\n        // Step 2: Initialize variables for the algorithm\n        int strLength = modifiedString.Length;\n        int[] palindromeLengths = new int[strLength];\n        int center = 0;  // Current center of the palindrome\n        int rightEdge = 0;  // Rightmost edge of the palindrome\n\n        // Step 3: Loop through the modified string to find palindromes\n        for (int i = 1; i < strLength - 1; i++) {\n            palindromeLengths[i] = (rightEdge > i) ? Math.Min(rightEdge - i, palindromeLengths[2 * center - i]) : 0;\n\n            // Expand the palindrome around the current character\n            while (modifiedString[i + 1 + palindromeLengths[i]] == modifiedString[i - 1 - palindromeLengths[i]]) {\n                palindromeLengths[i]++;\n            }\n\n            // Update the rightmost edge and center if necessary\n            if (i + palindromeLengths[i] > rightEdge) {\n                center = i;\n                rightEdge = i + palindromeLengths[i];\n            }\n        }\n\n        // Step 4: Find the longest palindrome and its center\n        int maxLength = 0;\n        int maxCenter = 0;\n        for (int i = 0; i < strLength; i++) {\n            if (palindromeLengths[i] > maxLength) {\n                maxLength = palindromeLengths[i];\n                maxCenter = i;\n            }\n        }\n\n        // Step 5: Extract the longest palindrome from the modified string\n        int start = (maxCenter - maxLength) / 2;\n        int end = start + maxLength;\n\n        // Return the longest palindrome in the original string\n        return s.Substring(start, end - start);\n    }\n}\n```\n``` PHP []\nclass Solution {\n    public function longestPalindrome($s) {\n        // Step 1: Preprocess the input string\n        $processedStr = "^#";\n        for ($i = 0; $i < strlen($s); $i++) {\n            $processedStr .= $s[$i] . "#";\n        }\n        $processedStr .= "$";\n        $modifiedString = $processedStr;\n\n        // Step 2: Initialize variables for the algorithm\n        $strLength = strlen($modifiedString);\n        $palindromeLengths = array_fill(0, $strLength, 0);\n        $center = 0;  // Current center of the palindrome\n        $rightEdge = 0;  // Rightmost edge of the palindrome\n\n        // Step 3: Loop through the modified string to find palindromes\n        for ($i = 1; $i < $strLength - 1; $i++) {\n            $palindromeLengths[$i] = ($rightEdge > $i) ? min($rightEdge - $i, $palindromeLengths[2 * $center - $i]) : 0;\n\n            // Expand the palindrome around the current character\n            while ($modifiedString[$i + 1 + $palindromeLengths[$i]] == $modifiedString[$i - 1 - $palindromeLengths[$i]]) {\n                $palindromeLengths[$i]++;\n            }\n\n            // Update the rightmost edge and center if necessary\n            if ($i + $palindromeLengths[$i] > $rightEdge) {\n                $center = $i;\n                $rightEdge = $i + $palindromeLengths[$i];\n            }\n        }\n\n        // Step 4: Find the longest palindrome and its center\n        $maxLength = 0;\n        $maxCenter = 0;\n        for ($i = 0; $i < $strLength; $i++) {\n            if ($palindromeLengths[$i] > $maxLength) {\n                $maxLength = $palindromeLengths[$i];\n                $maxCenter = $i;\n            }\n        }\n\n        // Step 5: Extract the longest palindrome from the modified string\n        $start = ($maxCenter - $maxLength) / 2;\n        $end = $start + $maxLength;\n\n        // Return the longest palindrome in the original string\n        return substr($s, $start, $end - $start);\n    }\n}\n```\n\n![upvote.png](https://assets.leetcode.com/users/images/d2f2c9af-7fdd-4731-8b22-edd260e4d466_1698374064.625327.png)\n# Up Vote Guys\n, status: null, voteStatus: 0, voteCount: 52, creationDate: 1698374096, isHidden: null, author: {username: Akhilesh21, isActive: true, nameColor: null, activeBadge: {displayName: Nov LeetCoding Challenge, icon: /static/images/badges/dcc-2023-11.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1699007850.png, reputation: 1139}}}, searchMeta: null}, {id: 4212241, title: âœ… 98.55% Manacher's algorithm, commentCount: 11, topLevelCommentCount: 9, viewCount: 12533, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}, {name: Go, slug: golang}, {name: PHP, slug: php}, {name: String, slug: string}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 6327578, content: # Intuition\nWhen tackling the problem of finding the longest palindromic substring, one might initially think of generating all possible substrings and checking each for palindromicity. However, this approach is inefficient. A more nuanced understanding would lead us to the realization that for each character in the string, it could potentially be the center of a palindrome. Using this intuition, we can attempt to expand around each character to check for palindromes. But how can we make sure to handle palindromes of both even and odd lengths? This is where Manacher\'s algorithm comes in, transforming the string in a way that we only need to handle palindromes centered around a single character.\n\n## Live Codding & Comments\nhttps://youtu.be/6Bq8j2dhzJc?si=zPnSjdkRaNzo5KMa\n\n# Approach\n\n**Manacher\'s Algorithm** is a powerful technique that allows us to find the longest palindromic substring in a given string in linear time. Here\'s a detailed breakdown of the algorithm\'s approach:\n\n### 1. String Transformation\nWe first transform the original string to simplify the algorithm. This transformation achieves two things:\n- It ensures that every potential center of a palindrome is surrounded by identical characters (`#`), which simplifies the process of expanding around a center.\n- It adds special characters `^` at the beginning and `$` at the end of the string to avoid any boundary checks during the palindrome expansion.\n\nFor instance, the string `"babad"` is transformed into `"^#b#a#b#a#d#$"`.\n\n### 2. Initialization\nWe maintain an array `P` with the same length as the transformed string. Each entry `P[i]` denotes the radius (half-length) of the palindrome centered at position `i`.\n\nWe also introduce two critical pointers:\n- `C`: The center of the palindrome that has the rightmost boundary.\n- `R`: The right boundary of this palindrome.\n\nBoth `C` and `R` start at the beginning of the string.\n\n### 3. Iterating Through the String\nFor every character in the transformed string, we consider it as a potential center for a palindrome.\n\n**a. Using Previously Computed Information**:  \nIf the current position is to the left of `R`, its mirror position about the center `C` might have information about a palindrome centered at the current position. We can leverage this to avoid unnecessary calculations.\n\n**b. Expanding Around the Center**:  \nStarting from the current radius at position `i` (which might be derived from its mirror or initialized to 0), we attempt to expand around `i` and check if the characters are the same.\n\n**c. Updating `C` and `R`**:  \nIf the palindrome centered at `i` extends beyond `R`, we update `C` to `i` and `R` to the new boundary.\n\n### 4. Extracting the Result\nOnce we\'ve computed the palindromic radii for all positions in the transformed string, we find the position with the largest radius in `P`. This position represents the center of the longest palindromic substring. We then extract and return this palindrome from the original string.\n\n# Complexity\n- Time complexity: $O(n)$\nManacher\'s algorithm processes each character in the transformed string once, making the time complexity linear.\n\n- Space complexity: $O(n)$\nWe use an array `P` to store the palindrome radii, making the space complexity linear as well.\n\n# Code\n``` Python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        T = \'#\'.join(\'^{}$\'.format(s))\n        n = len(T)\n        P = [0] * n\n        C = R = 0\n        \n        for i in range(1, n-1):\n            P[i] = (R > i) and min(R - i, P[2*C - i])\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n            \n            if i + P[i] > R:\n                C, R = i, i + P[i]\n      \n        max_len, center_index = max((n, i) for i, n in enumerate(P))\n        return s[(center_index - max_len) // 2: (center_index + max_len) // 2]\n```\n``` Go []\nfunc longestPalindrome(s string) string {\n    T := "^#" + strings.Join(strings.Split(s, ""), "#") + "#$"\n    n := len(T)\n    P := make([]int, n)\n    C, R := 0, 0\n    \n    for i := 1; i < n-1; i++ {\n        if R > i {\n            P[i] = min(R-i, P[2*C-i])\n        }\n        for T[i+1+P[i]] == T[i-1-P[i]] {\n            P[i]++\n        }\n        if i + P[i] > R {\n            C, R = i, i + P[i]\n        }\n    }\n    \n    maxLen := 0\n    centerIndex := 0\n    for i, v := range P {\n        if v > maxLen {\n            maxLen = v\n            centerIndex = i\n        }\n    }\n    return s[(centerIndex-maxLen)/2 : (centerIndex+maxLen)/2]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n``` Java []\npublic class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sb = new StringBuilder("^#");\n        for (char c : s.toCharArray()) {\n            sb.append(c).append("#");\n        }\n        sb.append("$");\n        String T = sb.toString();\n        \n        int n = T.length();\n        int[] P = new int[n];\n        int C = 0, R = 0;\n        \n        for (int i = 1; i < n-1; i++) {\n            P[i] = (R > i) ? Math.min(R - i, P[2*C - i]) : 0;\n            while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i]))\n                P[i]++;\n            \n            if (i + P[i] > R) {\n                C = i;\n                R = i + P[i];\n            }\n        }\n        \n        int max_len = 0, center_index = 0;\n        for (int i = 0; i < n; i++) {\n            if (P[i] > max_len) {\n                max_len = P[i];\n                center_index = i;\n            }\n        }\n        return s.substring((center_index - max_len) / 2, (center_index + max_len) / 2);\n    }\n}\n```\n``` C++ []\nclass Solution {\npublic:\n    std::string longestPalindrome(std::string s) {\n        std::string T = "^#";\n        for (char c : s) {\n            T += c;\n            T += \'#\';\n        }\n        T += "$";\n\n        int n = T.size();\n        std::vector<int> P(n, 0);\n        int C = 0, R = 0;\n\n        for (int i = 1; i < n-1; ++i) {\n            P[i] = (R > i) ? std::min(R - i, P[2*C - i]) : 0;\n            while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\n                P[i]++;\n\n            if (i + P[i] > R) {\n                C = i;\n                R = i + P[i];\n            }\n        }\n\n        int max_len = *std::max_element(P.begin(), P.end());\n        int center_index = std::distance(P.begin(), std::find(P.begin(), P.end(), max_len));\n        return s.substr((center_index - max_len) / 2, max_len);\n    }\n};\n```\n``` PHP []\nclass Solution {\n    function longestPalindrome($s) {\n        $T = "^#".implode("#", str_split($s))."#$";\n        $n = strlen($T);\n        $P = array_fill(0, $n, 0);\n        $C = $R = 0;\n        \n        for ($i = 1; $i < $n-1; $i++) {\n            $P[$i] = ($R > $i) ? min($R - $i, $P[2*$C - $i]) : 0;\n            while ($T[$i + 1 + $P[$i]] == $T[$i - 1 - $P[$i]])\n                $P[$i]++;\n            \n            if ($i + $P[$i] > $R) {\n                $C = $i;\n                $R = $i + $P[$i];\n            }\n        }\n        \n        $max_len = max($P);\n        $center_index = array_search($max_len, $P);\n        return substr($s, ($center_index - $max_len) / 2, $max_len);\n    }\n}\n```\n``` C# []\npublic class Solution {\n    public string LongestPalindrome(string s) {\n        string T = "^#" + string.Join("#", s.ToCharArray()) + "#$";\n        int n = T.Length;\n        int[] P = new int[n];\n        int C = 0, R = 0;\n        \n        for (int i = 1; i < n-1; i++) {\n            P[i] = (R > i) ? Math.Min(R - i, P[2*C - i]) : 0;\n            while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\n                P[i]++;\n            \n            if (i + P[i] > R) {\n                C = i;\n                R = i + P[i];\n            }\n        }\n        \n        int max_len = P.Max();\n        int center_index = Array.IndexOf(P, max_len);\n        return s.Substring((center_index - max_len) / 2, max_len);\n    }\n}\n```\n``` JavaScript []\nvar longestPalindrome = function(s) {\n        let T = "^#" + s.split("").join("#") + "#$";\n        let n = T.length;\n        let P = new Array(n).fill(0);\n        let C = 0, R = 0;\n        \n        for (let i = 1; i < n-1; i++) {\n            P[i] = (R > i) ? Math.min(R - i, P[2*C - i]) : 0;\n            while (T[i + 1 + P[i]] === T[i - 1 - P[i]])\n                P[i]++;\n            \n            if (i + P[i] > R) {\n                C = i;\n                R = i + P[i];\n            }\n        }\n        \n        let max_len = Math.max(...P);\n        let center_index = P.indexOf(max_len);\n        return s.substring((center_index - max_len) / 2, (center_index + max_len) / 2);\n    }\n```\n\n# Performance\n| Language   | Runtime (ms) | Memory (MB) |\n|------------|--------------|-------------|\n| Go         | 5            | 5.2         |\n| Java       | 8            | 43.2        |\n| C++        | 11           | 8.7         |\n| PHP        | 18           | 19.4        |\n| C#         | 67           | 40.5        |\n| JavaScript | 71           | 45.6        |\n| Python3    | 90           | 16.4        |\n\n![v445.png](https://assets.leetcode.com/users/images/b28e7735-3ff4-455f-b40f-07c991e38ad6_1698366771.3878486.png)\n\n\n# What did we learn?\nWe learned about Manacher\'s algorithm, a linear-time solution to the longest palindromic substring problem. By transforming the string and leveraging the properties of palindromes, we can efficiently determine the longest palindrome without checking every possible substring.\n\n# Why does it work?\nManacher\'s algorithm works by taking advantage of the symmetrical nature of palindromes. It avoids redundant checks by using the information from previously computed palindromes. The transformation of the string ensures that we don\'t need to separately handle even and odd length palindromes.\n\n# What is the optimization here?\nThe brilliance of Manacher\'s algorithm lies in its ability to reduce the problem from quadratic to linear time. By using the palindrome information already computed and the nature of palindromes themselves, the algorithm avoids unnecessary checks, making it one of the most optimal solutions for this problem., status: null, voteStatus: 0, voteCount: 43, creationDate: 1698365425, isHidden: null, author: {username: vanAmsen, isActive: true, nameColor: null, activeBadge: {displayName: Sep LeetCoding Challenge, icon: /static/images/badges/dcc-2023-9.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1684156727.png, reputation: 10614}}}, searchMeta: null}, {id: 759291, title: Straight Forward Short and Clean Python DP with Detailed Simple Explanation!, commentCount: 6, topLevelCommentCount: 4, viewCount: 6539, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 1395376, content: The main things to explain here:\nWe are iterating through our string looking for palindromes, we fill in a dp table with what we find and use it for reference:\n<table style="width:100%">\n  <tr>\n  <th></th>\n    <th>a</th>\n    <th>b</th>\n    <th>a</th>\n  </tr>\n  <tr>\n    <td><b>a</b></td>\n    <td>t</td>\n    <td>f</td>\n\t<td>t</td>\n  </tr>\n  <tr>\n    <td><b>b</b></td>\n    <td>0</td>\n    <td>t</td>\n\t<td>f</td>\n  </tr>\n    <tr>\n    <td><b>a</b></td>\n    <td>0</td>\n    <td>0</td>\n\t<td>t</td>\n  </tr>\n</table>\n\nWe start our iterations from the bottom (reverse the range - range(n-1, -1, -1)), and build our solution up (bottom up).\nOur diagonal is always true as it means it\'s always 1 letter (you could think of the letters as idx\'s also (0,0), (1,1) etc.). \nBottom row: is \'a\' a pal? True.\nMiddle row: is \'b\' a pal? True, is \'ba\' a pal? False.\nTop row: is \'a\' a pal? True, is \'ab\' a pal? False, is \'aba\' a pal? True.\n\n The logic for recording the longest palindromes:\n*  ((j - i + 1) <= 3 if the length of the str is < 3\n\t*  eg. aba i= 0, j = 2, 2 - 0 + 1 = 3, here we dont care about the middle letter, and we know s[i] == s[j].\n\t*  eg. ab i= 0, j = 1, 1 - 0 + 1 = 2 this isn\'t valid? But we already know s[i] != s[j] so wouldn\'t have made it to this check.\n*  OR dp[i + 1][j - 1] - the last str before the current was a palindrome.\n\nWe store the palindromes we find along with their length in ans and return the str associated with the max len.\n```\nclass Solution:\n    def longestPalindrome(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n\t\tn = len(s)\n        if n < 2: return s\n        dp, ans = [[0]*n for _ in range(n)], {}\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and ((j - i + 1) <= 3 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n                    ans[j-i+1] = s[i:j+1]\n                else:\n                    dp[i][j] = False\n        return ans[max(ans)]\n```\n\nA very similar way to approach it:\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n        if len(s) < 2: \n            return s[0] if s else \'\'\n        dp = [[False] * len(s) for _ in range(len(s))]\n        max_seen = 1\n        mv = s[0]\n        for i in range(len(s)):\n            for j in range(i):\n                if s[i] == s[j] and ((i-j+1) <= 3 or dp[i-1][j+1]):\n                    dp[i][j] = True\n                    if i-j+1 >= max_seen:\n                        max_seen = i-j+1\n                        mv = s[j:i+1]\n\n        return mv\n```\nOR\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n        dp = [[False]*len(s) for _ in range(len(s))]\n        longest = \'\'\n        \n        for i in range(len(s)):\n            for j in range(i+1):\n                if s[i] == s[j] and ((i+1-j) <= 3 or dp[i-1][j+1]):\n                    dp[i][j] = True\n                    if i+1-j > len(longest):\n                        longest = s[j:i+1]\n        return longest\n```, status: null, voteStatus: 0, voteCount: 30, creationDate: 1595875965, isHidden: null, author: {username: Pythagoras_the_3rd, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2024, icon: https://assets.leetcode.com/static_assets/marketing/2024-50-lg.png}, profile: {userAvatar: https://assets.leetcode.com/users/pythagoras_the_3rd/avatar_1582330679.png, reputation: 710}}}, searchMeta: null}, {id: 4212570, title: ðŸ”¥ðŸš€Beats 99.90%ðŸš€ | ðŸ”¥ðŸš©Optimised Code | ðŸ§­O(n^2) Time & O(1) Space |ðŸ”¥ Using Dynamic ProgrammingðŸ”¥, commentCount: 8, topLevelCommentCount: 8, viewCount: 4205, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: JavaScript, slug: javascript}, {name: Ruby, slug: ruby}, {name: TypeScript, slug: typescript}, {name: String, slug: string}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 6328025, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe given code is an implementation of the "Expand Around Center" approach for finding the longest palindromic substring in a given string. This approach works by iterating through each character in the string and expanding around it to check for palindromes. It takes advantage of the fact that a palindrome can be centered around a single character (in the case of odd-length palindromes) or between two characters (in the case of even-length palindromes). By expanding from each character, it identifies the longest palindrome.\n\n---\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n1. The `expandAroundCenter` function takes a string `s` and two indices `left` and `right`. It starts from the characters at these indices and expands outwards while checking if the characters are the same. When different characters are encountered, the function returns the substring between `left` and `right`, which is a palindrome.\n\n2. The `longestPalindrome` function initializes an empty string longest to keep track of the `longest` palindromic substring found.\n\n3. It iterates through the characters of the input string s. For each character, it calls `expandAroundCenter` twice, once assuming an odd-length palindrome (with the character as the center) and once assuming an even-length palindrome (with the character and the next character as the center).\n\n4. If the length of the palindrome found (either odd or even) is greater than the length of the `longest` palindrome found so far, it updates the `longest` substring.\n\n5. After iterating through all characters, it returns the longest palindromic substring found.\n\n---\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nThe time complexity of this code is O(n^2), where \'n\' is the length of the input string \'s\'. This is because, in the worst case, for each of the \'n\' characters in \'s\', we may expand to both the left and the right, resulting in a quadratic time complexity.\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nThe space complexity of this code is O(1) because it doesn\'t use any additional data structures that grow with the input size. The space is primarily used for the variables and temporary substrings, which don\'t depend on the input size.\n\n---\n\n# \uD83D\uDCA1If you have come this far, then i would like to request you to please upvote this solution\u2763\uFE0F\uD83D\uDCA1So that it could reach out to another one\uD83D\uDD25\uD83D\uDD25\n\n---\n\n```C++ []\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\nstring expandAroundCenter(string s, int left, int right) {\n    while (left >= 0 && right < s.length() && s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    return s.substr(left + 1, right - left - 1);\n}\n\nstring longestPalindrome(string s) {\n    string longest = "";\n    for (int i = 0; i < s.length(); i++) {\n        string odd = expandAroundCenter(s, i, i);\n        string even = expandAroundCenter(s, i, i + 1);\n        if (odd.length() > longest.length()) longest = odd;\n        if (even.length() > longest.length()) longest = even;\n    }\n    return longest;\n}\n};\n```\n```Java []\npublic class Solution {\n    public String expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return s.substring(left + 1, right);\n    }\n\n    public String longestPalindrome(String s) {\n        String longest = "";\n        for (int i = 0; i < s.length(); i++) {\n            String odd = expandAroundCenter(s, i, i);\n            String even = expandAroundCenter(s, i, i + 1);\n            if (odd.length() > longest.length()) {\n                longest = odd;\n            }\n            if (even.length() > longest.length()) {\n                longest = even;\n            }\n        }\n        return longest;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = "babad";\n        String result = solution.longestPalindrome(s);\n        System.out.println("Longest Palindromic Substring: " + result);\n    }\n}\n\n```\n```Python []\nclass Solution:\n    def expandAroundCenter(self, s, left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    def longestPalindrome(self, s):\n        longest = ""\n        for i in range(len(s)):\n            odd = self.expandAroundCenter(s, i, i)\n            even = self.expandAroundCenter(s, i, i + 1)\n            if len(odd) > len(longest):\n                longest = odd\n            if len(even) > len(longest):\n                longest = even\n        return longest\n\nsolution = Solution()\ns = "babad"\nresult = solution.longestPalindrome(s)\nprint("Longest Palindromic Substring:", result)\n\n```\n```Javascript []\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    function expandAroundCenter(left, right) {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return s.substring(left + 1, right);\n    }\n\n    let longest = "";\n\n    for (let i = 0; i < s.length; i++) {\n        let odd = expandAroundCenter(i, i);\n        let even = expandAroundCenter(i, i + 1);\n\n        if (odd.length > longest.length) {\n            longest = odd;\n        }\n\n        if (even.length > longest.length) {\n            longest = even;\n        }\n    }\n\n    return longest;\n};\n\n// Example usage\nconst s = "babad";\nconst result = longestPalindrome(s);\nconsole.log("Longest Palindromic Substring: " + result);\n\n```\n```Ruby []\n# @param {String} s\n# @return {String}\ndef longest_palindrome(s)\n    def expand_around_center(s, left, right)\n        while left >= 0 && right < s.length && s[left] == s[right]\n            left -= 1\n            right += 1\n        end\n        s[left + 1...right]\n    end\n\n    longest = ""\n\n    (0...s.length).each do |i|\n        odd = expand_around_center(s, i, i)\n        even = expand_around_center(s, i, i + 1)\n\n        if odd.length > longest.length\n            longest = odd\n        end\n\n        if even.length > longest.length\n            longest = even\n        end\n    end\n\n    return longest\nend\n\n# Example usage\ns = "babad"\nresult = longest_palindrome(s)\nputs "Longest Palindromic Substring: #{result}"\n\n```\n```Typescript []\nfunction longestPalindrome(s: string): string {\n    function expandAroundCenter(left: number, right: number): string {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return s.substring(left + 1, right);\n    }\n\n    let longest = "";\n\n    for (let i = 0; i < s.length; i++) {\n        let odd = expandAroundCenter(i, i);\n        let even = expandAroundCenter(i, i + 1);\n\n        if (odd.length > longest.length) {\n            longest = odd;\n        }\n\n        if (even.length > longest.length) {\n            longest = even;\n        }\n    }\n\n    return longest;\n}\n\n// Example usage\nconst s = "babad";\nconst result = longestPalindrome(s);\nconsole.log("Longest Palindromic Substring: " + result);\n\n```, status: null, voteStatus: 0, voteCount: 27, creationDate: 1698378078, isHidden: null, author: {username: anshuP_cs24, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1696058046.png, reputation: 288}}}, searchMeta: null}, {id: 1057629, title: Python. Super simple & easy-understanding solution. O(n^2)., commentCount: 5, topLevelCommentCount: 3, viewCount: 3766, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1906153, content: \tclass Solution:\n\t\tdef longestPalindrome(self, s: str) -> str:\n\t\t\tres = ""\n\t\t\tlength = len(s)\n\t\t\tdef helper(left: int, right: int):\n\t\t\t\twhile left >= 0 and right < length and s[left] == s[right]:\n\t\t\t\t\tleft -= 1\n\t\t\t\t\tright += 1\n\t\t\t\t\t\n\t\t\t\treturn s[left + 1 : right]\n\t\t\t\n\t\t\t\n\t\t\tfor index in range(len(s)):\n\t\t\t\tres = max(helper(index, index), helper(index, index + 1), res, key = len)\n\t\t\t\t\n\t\t\treturn res, status: null, voteStatus: 0, voteCount: 23, creationDate: 1612873003, isHidden: null, author: {username: m-d-f, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 1207}}}, searchMeta: null}, {id: 4942782, title: ã€Videoã€‘Using two pointers - Python, JavaScript, Java, C++, commentCount: 0, topLevelCommentCount: 0, viewCount: 993, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 7270419, content: # Intuition\nUsing two pointers\n\n---\n\n# Solution Video\n\nhttps://youtu.be/aMH1eomKCmE\n\n\u25A0 Timeline of the video\n`0:04` How did you find longest palindromic substring?\n`0:59` What is start point?\n`1:44` Demonstrate how it works with odd case\n`4:36` How do you calculate length of palindrome we found?\n`7:35` Will you pass all test cases?\n`7:53` Consider even case\n`9:03` How to deal with even case\n`11:26` Coding\n`14:52` Explain how to calculate range of palindrome substring\n`17:18` Time Complexity and Space Complexity\n\n### \u2B50\uFE0F\u2B50\uFE0F Don\'t forget to subscribe to my channel! \u2B50\uFE0F\u2B50\uFE0F\n\n**\u25A0 Subscribe URL**\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\nSubscribers: 4,190\nThank you for your support!\n\n---\n\n# Approach\n\n### How we think about a solution\n\n---\n\n\nFirst of all, Manacher\'s Algorithm solves this question with $$O(n)$$ time. But in real interviews, nobody will come up with such a solution, so I think $$O(n^2)$$ time is enough to pass the interviews.\n\nIf interviewers ask you about a solution with $$O(n)$$. just leave the room. lol\n\n---\n\nSeriously from here, first of all, we need to understand Palindromic Substring.\n\nWhen I think about a solution, I usually start with the small and simple input, because it\'s easy to understand and find a solution. But this time let\'s start with a big input.\n\n```\nInput: "xkarqzghhgfedcbabcdefgzdekx"\n```\n\n---\n\n\u25A0 Question\n\nHow did you find longest palindromic substring?\n\n---\n\nI believe you choose one character, then expand the range to left and right at the same time. If you find longest palindromic substring directly, you are not a human. lol\n\nActually, that is main idea of my solution today. But problem is that we don\'t know where to start. That\'s why we need to shift start point one by one.\n\n---\n\n\u2B50\uFE0F Points\n\nWe need to shift a start point one by one to check longest palindromic substring.\n\n- What is the start point?\n\nSince palindromic substring is like a mirror from some character, it\'s good idea to consider current index as a center of palindromic substring and expand left and right at the same time.\n\nFor example,\n\n```\nInput = "abcba"\n```\nIf we start from `c`, then\n\n```\n"ab" "c" "ba"\n      i\n\ni = curerent index\n```\n"ab" and "ba" is a mirror when "c" is center.\n\n---\n\nLet\'s see one by one.\n\n```\nInput = "abcba"\n```\nWe use `left` and `right` pointers. The both pointers start from index `i` but let me start from next to index `i` to make my explanation short. A single character is definitely a palindrome which is length of `1`.\n```\ni = 0\n\n"abcba"\nlir\n \nCheck left(= out of bounds) and right(= "b")\nmax_length = 1 (= "a")\n\n```\n```\ni = 1\n\n"abcba"\n lir\n\nCheck left(= "a") and right(= "c")\nmax_length = 1 (= "a" or "b")\n\n```\n```\ni = 2\n\n"abcba"\n  lir\n\nl = 1\nr = 3\nCheck left(= "b") and right(= "b") \u2192 "bcb" is a palindrome.\uD83D\uDE06\n\nLet\'s expand the range!\n\n"abcba"\n l i r\n\nl = 0\nr = 4\nCheck left(= "a") and right(= "a") \u2192 "abcba" is a palindrome.\uD83D\uDE06\nmax_length = 5 (= "abcba")\n\n "abcba"\n l  i  r\n\nl = -1\nr = 5\nNow left and right are out of bounds, so we finish iteration.\n\n```\n\nLet me skip the cases where we start from later "b" and "a". We already found the max length. (of course solution code will check the later part)\n\n- How do you calculate length of palindrome we found?\n\nFrom the example above, we found `5` as a max length. how do you calculate it? Simply\n\n```\nright - left\n```\nRight? So,\n```\nright - left\n5 - (-1)\n= 6\n```\n\nWait? It\'s longer than max length we found. The reason why this happens is because the two pointers stop at the next position of max length of palindrome.\n\n```\n"abcba"\n l i r\n```\nWhen `i = 2 left = 0 and right = 4`, we found `5` as a max length, but we don\'t know `5` is the max length in the current iteration, so we try to move to the next place to find longer palindrome, even if we don\'t find it in the end.\n\nThat\'s why, left and right pointer always `overrun` and stop at max length in current iteration + 1, so we need to subtract -1 from right - left.\n```\n\u274C right - left\n\uD83D\uDD34 right - left - 1\n```\nBut still you don\'t get it because we have two pointers expanding at the same time? you think we should subtract `-2`?\n\nThis is calculation of index number, so index number usually starts from `0` not `1`, so right - left includes `-1` already. For example,\n\n```\n"aba"\n l r\n```\nActual length is `3`, but if we calculate the length with index number, that should be `2`(index 2 - index 0), so it\'s already including `-1` compared with actual length. That\'s why when we have two pointers and calculate actual length, right - left - 1 works well.\n\nNow you understand main idea of my solution, but I\'m sure you will not pass all cases. Can you geuss why?\n\nThe answer is I explain the case where we have odd length of input string.\n\n---\n\n\u2B50\uFE0F Points\n\nWe have to care about both odd length of input string and even length of input string\n\n---\n\n```\nInput: "abbc"\n ```\nLet\'s see one by one. we can use the same idea. Let me write briefly.\n\n```\n"abbc"\nlir\n\nmax length = 1\n```\n```\n"abbc"\n lir\n\nmax length = 1\n```\n```\n"abbc"\n  lir\n\nmax length = 1\n```\n```\n"abbc"\n   lir\n\nmax length = 1\n```\n```\n\u274C Output: "a" or "b" or "c"  \n```\nOutput should be\n```\n\uD83D\uDD34 Output: "bb"  \n```\n- Why this happens?\n\nRegarding odd length of input array, center position of palindrome is definitely on some charcter.\n```\n"abcba", center is "c"\n```\nHow about even length of input string\n```\n"abbc"\nCenter of palindrome is "b | b" \n```\n`|` is center of palindrome. Not on some character.\n\n- So how can you avoid this?\n\nMy idea to avoid this is we start left with current index and right with current index + 1, so we start interation as if we are coming from between the characters. Let me write only when index = 1.\n```\ncurrent index = 1\n\n  lr\n"abbc"\n  i\n\nWe found palindrome "bb"\n\n l  r\n"abbc"\n  i\n\nFinish iteration.\n```\nThen\n```\nright - left - 1\n3 - 0 - 1\n= 2(= length of "bb")\n```\n\nWe can use the same idea for both cases but start position is different, that\'s why we call the same function twice in one iteration.\n\nLet\'s see a real algorithm!\n\n### Algorithm Overview:\n1. Initialize `start` and `end` variables to keep track of the starting and ending indices of the longest palindromic substring.\n2. Iterate through each character of the input string `s`.\n3. For each character, expand around it by calling the `expand_around_center` function with two different center possibilities: (i) the current character as the center (odd length palindrome), and (ii) the current character and the next character as the center (even length palindrome).\n4. Compare the lengths of the two expanded palindromes and update `start` and `end` if a longer palindrome is found.\n5. Finally, return the longest palindromic substring by slicing the input string `s` based on the `start` and `end` indices.\n\n### Detailed Explanation:\n1. Check if the input string `s` is empty. If it is, return an empty string, as there can be no palindromic substring in an empty string.\n\n2. Define a helper function `expand_around_center` that takes three arguments: the input string `s`, and two indices `left` and `right`. This function is responsible for expanding the palindrome around the center indices and returns the length of the palindrome.\n\n3. Initialize `start` and `end` variables to 0. These variables will be used to keep track of the indices of the longest palindromic substring found so far.\n\n4. Iterate through each character of the input string `s` using a for loop.\n\n5. Inside the loop, call the `expand_around_center` function twice: once with `i` as the center for an odd length palindrome and once with `i` and `i + 1` as the center for an even length palindrome.\n\n6. Calculate the length of the palindrome for both cases (odd and even) and store them in the `odd` and `even` variables.\n\n7. Calculate the maximum of the lengths of the two palindromes and store it in the `max_len` variable.\n\n8. Check if the `max_len` is greater than the length of the current longest palindromic substring (`end - start`). If it is, update the `start` and `end` variables to include the new longest palindromic substring. The new `start` is set to `i - (max_len - 1) // 2`, and the new `end` is set to `i + max_len // 2`.\n\n9. Continue the loop until all characters in the input string have been processed.\n\n10. After the loop, return the longest palindromic substring by slicing the input string `s` using the `start` and `end` indices. This substring is inclusive of the characters at the `start` and `end` indices.\n\n\n\n# Complexity\n- Time complexity: $$O(n^2)$$\n\n "n" is the length of the input string "s." This is because the code uses nested loops. The outer loop runs for each character in the string, and the inner loop, expand_around_center, can potentially run for the entire length of the string in the worst case, leading to a quadratic time complexity.\n\n- Space complexity: $$O(1)$$\n\nthe code uses a constant amount of extra space for variables like "start," "end," "left," "right," and function parameters. The space used does not depend on the size of the input string.\n\n```python []\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return ""\n\n        def expand_around_center(s: str, left: int, right: int):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return right - left - 1\n\n\n        start = 0\n        end = 0\n\n        for i in range(len(s)):\n            odd = expand_around_center(s, i, i)\n            even = expand_around_center(s, i, i + 1)\n            max_len = max(odd, even)\n            \n            if max_len > end - start:\n                start = i - (max_len - 1) // 2\n                end = i + max_len // 2\n        \n        return s[start:end+1]\n```\n```javascript []\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    if (!s) {\n        return "";\n    }\n\n    function expandAroundCenter(s, left, right) {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    let start = 0;\n    let end = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const odd = expandAroundCenter(s, i, i);\n        const even = expandAroundCenter(s, i, i + 1);\n        const max_len = Math.max(odd, even);\n\n        if (max_len > end - start) {\n            start = i - Math.floor((max_len - 1) / 2);\n            end = i + Math.floor(max_len / 2);\n        }\n    }\n\n    return s.substring(start, end + 1);    \n};\n```\n```java []\nclass Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) {\n            return "";\n        }\n\n        int start = 0;\n        int end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            int odd = expandAroundCenter(s, i, i);\n            int even = expandAroundCenter(s, i, i + 1);\n            int max_len = Math.max(odd, even);\n\n            if (max_len > end - start) {\n                start = i - (max_len - 1) / 2;\n                end = i + max_len / 2;\n            }\n        }\n\n        return s.substring(start, end + 1);        \n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }    \n}\n```\n```C++ []\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        if (s.empty()) {\n            return "";\n        }\n\n        int start = 0;\n        int end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            int odd = expandAroundCenter(s, i, i);\n            int even = expandAroundCenter(s, i, i + 1);\n            int max_len = max(odd, even);\n\n            if (max_len > end - start) {\n                start = i - (max_len - 1) / 2;\n                end = i + max_len / 2;\n            }\n        }\n\n        return s.substr(start, end - start + 1);        \n    }\n\nprivate:\n    int expandAroundCenter(string s, int left, int right) {\n        while (left >= 0 && right < s.length() && s[left] == s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }    \n};\n```\n\nLet me explain this.\n```[]\nif max_len > end - start:\n    start = i - (max_len - 1) // 2\n    end = i + max_len // 2\n```\nif statement means just when we find longer length.\n\nLet\'s use the same example again.\n```\nInput = "abcba"\n\n```\nWhen `i = 2`, we find 5 as a max length. Let\'s see what will happen.\n\n```[]\nstart = i(2) - (max_len(5) - 1) // 2\nend = i(2) + max_len(5) // 2\n\u2193\nstart = 2 - 2\nend = 2 + 2\n\u2193\nstart = 0\nend = 4\n```\n- Why -1?\n\nThe `-1` is used to calculate the length of the palindrome correctly based on whether it is of odd or even length.\n\nHere, we try to get length of half palindrome except center chracters.\n\nRegarding odd case, actually it works if we don\'t subtract `-1`, because we have only one center chracter and we start from the character.\n\nFor example\n```\n"abcba"\n   \u2191\nCenter of palindrome is "c" \n```\nWe will get length of "ab"\n```[]\nno -1 case, 5 // 2 = 2\n-1 case, 4 // 2 = 2\n```\nThe result is the same.\n\nBut regarding even case we start from between characters.\n```\n"abbc"\nCenter of palindrome is "bb" \n```\n\nWe will get length of ""(empty = 0), because center character "bb" itself is whole length of palindrome.\n\n```[]\nno -1 case, 2 // 2 = 1\n-1 case, 1 // 2 = 0\n```\nThe result is different.\n\nIn this case, we have two center charcters, if we remove one character, we can create the same odd case situation from even situaiton, so that we can get correct length except center charcters.\n\nIn this case, i = 1, we get 2 as a max length.\n```\n"abbc"\n```\n\n```[]\nstart = i(1) - (max_len(2) - 1) // 2\nend = i(1) + max_len(2) // 2\n\u2193\nstart = 1 - 0\nend = 1 + 1\n\u2193\nstart = 1\nend = 2\n```\n\nLooks good! \uD83D\uDE06\n\nSince the result is not affected by `-1` in odd case, we subtract `-1` both odd case and even case.\n\n---\n\nThank you for reading my post.\n\u2B50\uFE0F Please upvote it and don\'t forget to subscribe to my channel!\n\n\u25A0 Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\n### My next daily coding challenge post and video.\n\npost\nhttps://leetcode.com/problems/count-vowels-permutation/solutions/4218427/video-give-me-10-minutes-how-we-think-about-a-solution-python-javascript-java-c/\n\nvideo\nhttps://youtu.be/SFm0hhVCjl8\n\n\u25A0 Timeline of the video\n`0:04` Convert rules to a diagram\n`1:14` How do you count strings with length of n?\n`3:58` Coding\n`7:39` Time Complexity and Space Complexity\n\n### My previous daily coding challenge post and video.\n\npost\nhttps://leetcode.com/problems/binary-trees-with-factors/solutions/4209156/video-give-me-10-minutes-how-we-think-about-a-solution-python-javascript-java-c/\n\nvideo\nhttps://youtu.be/LrnKFjcjsqo\n\n\u25A0 Timeline of video\n`0:04` Understand question exactly and approach to solve this question\n`1:33` How can you calculate number of subtrees?\n`4:12` Demonstrate how it works\n`8:40` Coding\n`11:32` Time Complexity and Space Complexity, status: null, voteStatus: 0, voteCount: 17, creationDate: 1711725144, isHidden: null, author: {username: niits, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1698738357.png, reputation: 7282}}}, searchMeta: null}, {id: 1541249, title: O(N) Using an EERTREE, commentCount: 1, topLevelCommentCount: 1, viewCount: 650, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Tree, slug: tree}], post: {id: 2672724, content: Solve this problem using a Palindrome Tree, aka an EERTREE! An EERTREE works a lot like a Trie and despite being very obscure and recent, it\'s quite elegant to solve this problem.\n\nSince for a string of length N there are only up to N distinct palindromes, we can represent each one as a node in a Tree.\n\nTaking advantage of a palindrome\'s recursive structure, we create dictionary links to show that one palindrome is just another palindrome with 1 letter concatenated on both sides.  For example, if we had some node that represents the palindrome `\'aba\'` and another palindrome `\'babab\'`, then we could show that:\n\n`aba ----b----> babab`\n\nMore formally, the palindrome `X` has an edge labeled `c` to palindrome `Y` when `Y = cXc`.\n\nIn addition, you also have one suffix link for each node, which point to it\'s longest proper suffix that is a palindrome. In other words, `ababa` would point to `aba` because that is the longest proper suffix that is also a palindrome. This is useful because if I am considering the longest palindrome ending at position `i`, I can just find the longest palindrome ending at position `i-1` and descend down the suffix links until I find a palindrome that has a `S[i]` right before it.\n\nFor example, let\'s say I had the string `xabacabac` and I am trying to find the longest palindrome ending at the last character. If I know the longest palindrome ending at the character before it is `abacaba` then I just have to check the first palindrome `X` that matches `cXc`.\n\n`x[abacaba]c` has `x` right before it which is not equal to `c`, so I go to it\'s next longest palindromic suffix `aba`\n\n`xabac[aba]c` has `c` right before it which is equal to `c` so we have found the palindrome `c[aba]c = cabac`\n\nAs for the initialization of our EERTREE, we have 2 nodes to handle the 1 letter and 2 letter palindrome case.\nThere is the empty string `E` of length 0, such that `cEc = cc`\nThere is the empty string `I` of length -1, such that `cIc = c`\n\nHere\'s the paper on it:\nhttps://arxiv.org/abs/1506.04862\n\nHere\'s a helpful medium article on learning the basics of it:\nhttps://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b\n\n```\nclass Node:\n    def __init__(self, len, sfx = None):\n        self.len = len\n        self.sfx = sfx\n        self.next = {}\n        \nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        curr = empty = Node(0, Node(-1))\n        ans_len = ans_idx = 0\n        for i, c in enumerate(s):\n            while i <= curr.len or s[i-1-curr.len] != c:\n                curr = curr.sfx\n            if c in curr.next:\n                curr = curr.next[c]\n                continue\n            node = curr.next[c] = Node(curr.len+2, empty)\n            if node.len > ans_len:\n                ans_len, ans_idx = node.len, i-node.len+1\n            if node.len > 1:\n                curr = curr.sfx\n                while i <= curr.len or s[i-1-curr.len] != c:\n                    curr = curr.sfx\n                node.sfx = curr.next[c]\n            curr = node\n        return s[ans_idx:ans_idx+ans_len]\n```, status: null, voteStatus: 0, voteCount: 15, creationDate: 1635232474, isHidden: null, author: {username: Aylup, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1661908435.png, reputation: 20}}}, searchMeta: null}, {id: 678400, title: AC Python, DP O(n) Space, Manacher, commentCount: 2, topLevelCommentCount: 2, viewCount: 3022, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 1254217, content: Dynamic Programming, O(n) Space\n```\ndef longestPalindrome(self, s: str) -> str:\n\tif not s: return s\n\tn, l, r = len(s), 0, 0\n\tdp = [[True]*n, [False]*n]    # dp[0]: old letters palindromes, dp[1]: even letters palindromes\n\tfor i in range(n-1):\n\t\tif s[i] == s[i+1]:\n\t\t\tdp[1][i] = True\n\t\t\tl, r = i, i+1                        \n\tfor m in range(2, n):         # m letters palindromes\n\t\tfor i in range(n-m):\n\t\t\tj = i+m\n\t\t\tx, k = m%2, i+m//2\n\t\t\tdp[x][k] = dp[x][k] and s[i] == s[j]\n\t\t\tif dp[x][k] and j-i > r-l:\n\t\t\t\tl, r = i, j\n\treturn s[l:r+1]\n```\nDynamic Programming, O(n^2) Space\n```\ndef longestPalindrome(self, s: str) -> str:\n\tif not s: return s\n\tn, l, r = len(s), 0, 0\n\tdp = [[False]*n for _ in range(n)]\n\tdp[-1][-1] = True\n\tfor i in range(n-1):\n\t\tdp[i][i] = True\n\t\tif s[i] == s[i+1]:\n\t\t\tdp[i][i+1] = True\n\t\t\tl, r = i, i+1                        \n\tfor m in range(2, n):\n\t\tfor i in range(n-m):\n\t\t\tj = i+m\n\t\t\tdp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n\t\t\tif dp[i][j] and j-i > r-l:\n\t\t\t\tl, r = i, j\n\treturn s[l:r+1]\n```\nCenter Expansion, O(1) Space\n```\ndef longestPalindrome(self, s: str) -> str:\n\tdef check(l, r):\n\t\twhile 0 <= l and r < n and s[l] == s[r]: \n\t\t\tl -= 1\n\t\t\tr += 1\n\t\treturn l, r\n\n\tn, L, R = len(s), 0, 0\n\tfor i in range(2*n-1):\n\t\tif i%2: l, r = check((i-1)//2, (i+1)//2)\n\t\telse: l, r = check(i//2, i//2)\n\t\tif r-l > R-L: L, R = l, r                \n\treturn s[L+1:R]\n```\nCenter Expansion, most efficient one except Manacher by my own test\n```\ndef longestPalindrome(self, s: str) -> str:\n\tt = \'^#\'+\'#\'.join(s)+\'#$\'\n\tc = r = 0                             # center and radius\n\tfor i in range(1,len(t)-1):\n\t\tj = 1 if t[i] == \'#\' else 2       # skip \'#\' and check letters only\n\t\twhile  t[i-j] == t[i+j]: j += 2\n\t\tif j > r: c, r = i, j\n\treturn s[(c-r+1)//2:(c+r-1)//2]\n```\n Manacher\'s algorithm\n```\ndef longestPalindrome(self, s: str) -> str:               \n\tt = \'^#\'+\'#\'.join(s)+\'#$\'\n\tn = len(t)\n\tp = [0]*n\n\tc = r = cm = rm = 0\n\tfor i in range (1, n-1):\n\t\tp[i] = min(r-i, p[2*c-i]) if r > i else 0\n\t\twhile t[i-p[i]-1] == t[i+p[i]+1]: p[i] += 1\n\t\tif p[i]+i > r: c, r = i, p[i]+i\n\t\tif p[i] > rm: cm, rm = i, p[i]\n\treturn s[(cm-rm)//2:(cm+rm)//2]\n```, status: null, voteStatus: 0, voteCount: 15, creationDate: 1591689155, isHidden: null, author: {username: lccn345, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/lccn345/avatar_1589663914.png, reputation: 170}}}, searchMeta: null}, {id: 2156653, title: âœ”ï¸ PYTHON || DYNAMIC AND BRUTE || ;], commentCount: 0, topLevelCommentCount: 0, viewCount: 1944, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 3599703, content: **UPVOTE IF HELPFuuL**\n\nDYNAMIC APPROACH\n\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\n\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\n* substrings of length 2 are *palin* if both characters are same.\n* \nAnd for rest of lengths use the sub problem.\n\nNow we need longest so the palindromic substring with longest length is the substring.\n\n**BRUTE FORECE**\n```\nclass Solution:\n   \n    def longestPalindrome(self, s: str) -> str:\n        res=s[0]\n        nn=len(res)\n        n=len(s)\n        for i in range(1,n-1):\n            \n            kk=s[i]\n            z=1\n            while ((i-z)>=0) and ((i+z)<n) and (s[i-z]==s[i+z]):\n                kk=s[i-z]+kk+s[i-z]\n                z+=1\n            \n            if len(kk)>nn:\n                res=kk\n                nn=len(res)\n        for i in range(0,n-1):\n            if s[i]==s[i+1]:\n                \n                kk=s[i]+s[i+1]\n                z=1\n                while ((i-z)>=0) and ((i+z+1)<n) and (s[i-z]==s[i+z+1]):\n                    kk=s[i-z]+kk+s[i-z]\n                    z+=1\n                if len(kk)>nn:\n                    res=kk\n                    nn=len(res)\n        return res\n```\n\n**UPVOTE IF HELPFuuL**\n\n**DYNAMIC APPROACH**\n\n```\nclass Solution:\n   def longestPalindrome(self, s):\n        res = \'\'\n        dp = [[0]*len(s) for i in range(len(s))]\n        \n        for i in range(len(s)):\n            dp[i][i] = True\n            res = s[i]\n\t\t\t\n        for i in range(len(s)-1,-1,-1):\n            for j in range(i+1,len(s)):  \n                \n                if s[i] == s[j]:\n                    if j-i ==1 or dp[i+1][j-1] is True:\n                        dp[i][j] = True\n                        \n                        if len(res) < len(s[i:j+1]):\n                            res = s[i:j+1]\n                \n        return res\n```\n![image](https://assets.leetcode.com/users/images/0007f2ce-d76f-46e8-b520-794d74ca5506_1655338899.7001777.jpeg)\n, status: null, voteStatus: 0, voteCount: 13, creationDate: 1655338969, isHidden: null, author: {username: karan_8082, isActive: true, nameColor: null, activeBadge: {displayName: Binary Search I, icon: https://assets.leetcode.com/static_assets/others/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE_%E5%85%A5%E9%97%A8.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1701023904.png, reputation: 4881}}}, searchMeta: null}, {id: 2157014, title: [Python] 2 Approaches with Explanation, commentCount: 1, topLevelCommentCount: 1, viewCount: 2942, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 3600214, content: ### Introduction\n\nGiven a string `s`, we want to find the longest substring in `s` that is a palindrome.\nWe can define a palindrome to be the following: **a string with a centre position (which may or may not point to a character in the string) that has a substring `sub` on its left and the reversed substring `sub[::-1]` on its right**. Some examples are shown below:\n\n```text\nOdd-length palindromes (spaced out for clarity)\n    "a b c d e d c b a"   "r a c e c a r"\n             ^                   ^\n\nEven-length palindromes (spaced out for clarity)\n    " a b c d d b c a"   "t o o t"\n             ^               ^\n```\n\n---\n\n### Approach 1\n\nBased on the definition above, we can try to find these centre positions in substrings of `s`, since these centre positions will eventually lead us to find the longest palindromic substring. One way is to space out `s` as we did above and check each index. As we noted above, if the index points to a character, then the resulting palindrome is odd-length; if the index points to a space, then the resulting palindrome is even-length.\n\nWe can optimise this approach by performing both odd-length and even-length checks on the same index as we iterate through them. At index `i`, **we first assert that `s[i]` is a palindrome of length 1, and iteratively check its adjacent characters for equality until we hit the end(s) of `s`**.\n\n```text\ns = "abcdedcba"\n                      i = 0                 i = 1                 i = 2                 i = 3                 i = 4\n               "a b c d e d c b a"   "a b c d e d c b a"   "a b c d e d c b a"   "a b c d e d c b a"   "a b c d e d c b a"\n                ^                     # ^ #                   # ^ #                   # ^ #             ^ ^ ^ ^ ^ ^ ^ ^ ^\npalindromes:           "a"                   "b"                   "c"                   "d"               "abcdedcba"\n```\n\nChecking for even-length palindromes is slightly tricker; **at index `i`, we assert that the (nonexistent) index between `i-1` and `i` is a palindrome of length 0, and we perform the same iteration as described above**.\n\n```text\ns = "toot"\n                 i = 0       i = 1       i = 2\n               "t o o t"   "t o o t"   "t o o t"\n               ^            #^#         ^ ^^^ ^\npalindromes:      ""          ""        "toot"\n```\n\nAfter checking for the longest odd-length and even-length palindromes at index `i`, we store the longest found palindrome to be returned.\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        """\n        Consider each character in s as the centre of a palindrome.\n        Check for the longest possible odd-length and even-length palindrome; store the longest palindrome\n        """\n        # res is the starting index of the longest palindrome\n        # len_res is the length of the longest palindrome\n        # len_s is the length of the given string\n        res, len_res, len_s = 0, 0, len(s)\n        for i in range(len_s):\n            # check for palindromes with odd number of characters centred around s[i]\n            # i.e., s[i] -> s[i-1:i+2] -> s[i-2:i+3] -> ...\n            # odd is the starting index of the current palindrome with odd number of characters\n            # len_odd is the length of the current palindrome with odd number of characters\n            odd, len_odd = i, 1\n            for j in range(min(i, len_s-i-1)):   # checking indexes [0, i) and [i+1, len_s); take the smaller range\n                if s[i-j-1] != s[i+j+1]:         # if the two characters adjacent to the ends of the current palindrome are not equal,\n                    break                        #   a longer palindrome does not exist; break out of the loop\n                odd, len_odd = odd-1, len_odd+2  # else, a longer palindrome exists; update odd and len_odd to point to that palindrome\n            # check for palindromes with even number of characters centred around s[i-1:i+1]\n            # i.e., s[i-1:i+1] -> s[i-2:i+2] -> s[i-3:i+3] -> ...\n            # even is the starting index of the current palindrome with even number of characters\n            # len_even is the length of the current palindrome with even number of characters\n            even, len_even = i, 0\n            for j in range(min(i, len_s-i)):         # checking indexes [0, i) and [i, len_s); take the smaller range\n                if s[i-j-1] != s[i+j]:               # if the two characters adjacent to the ends of the current palindrome are not equal,\n                    break                            #   a longer palindrome does not exist; break out of the loop\n                even, len_even = even-1, len_even+2  # else, a longer palindrome exists; update even and len_even to point to that palindrome\n            # update res and len_res to point to the longest palindrome found so far\n            len_res, res = max((len_res, res), (len_odd, odd), (len_even, even))\n        return s[res:res+len_res]\n```\n\n**TC: O(n<sup>2</sup>)**; in the worst case, we are iterating through the entirety of `s` in the inner for loop.\n**SC: O(1)**; no additional data structures used.\n\n---\n\n### Approach 2: Manacher\'s algorithm\n\nI happened to chance upon [this post](https://leetcode.com/problems/longest-palindromic-substring/discuss/2156882/Manacher\'s-algorithm) that implemented the [Manacher\'s algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher\'s_algorithm), which basically makes use of DP to compute if there is a palindrome at each index.\n\nUnfortunately, there\'s not much explanation I can give since I do not understand the approach too well yet. If you can explain it to me, please let me know in the comments :)\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        """\n        Manacher\'s Algorithm for longest palindromic substrings (LPS)\n        """\n        # Transform S into T\n        # For example, S = "abba", T = "^#a#b#b#a#$"\n        # ^ and $ signs are sentinels appended to each end to avoid bounds checking\n        T = \'#\'.join(\'^{}$\'.format(s))\n        n = len(T)\n        P = [0]*n\n        C = R = 0\n        for i in range (1, n-1):\n            P[i] = (R > i) and min(R-i, P[2*C-i]) # equals to i\' = C - (i-C)\n            # Attempt to expand palindrome centered at i\n            while T[i+1+P[i]] == T[i-1-P[i]]:\n                P[i] += 1\n            # If palindrome centered at i expand past R,\n            # adjust center based on expanded palindrome\n            if i+P[i] > R:\n                C, R = i, i+P[i]\n        # Find the maximum element in P\n        maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\n        return s[(centerIndex-maxLen)//2: (centerIndex+maxLen)//2]\n```\n\n**TC: O(n)**; please read the article linked above for explanation.\n**SC: O(n)**; DP array used.\n\n---\n\nPlease upvote if this has helped you! Appreciate any comments as well :), status: null, voteStatus: 0, voteCount: 12, creationDate: 1655351166, isHidden: null, author: {username: zayne-siew, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual.png}, profile: {userAvatar: https://assets.leetcode.com/users/zayne-siew/avatar_1631290983.png, reputation: 2355}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 891, solutions: [{id: 817306, title: Very simple and intuitive O(n) python solution with explanation, commentCount: 22, topLevelCommentCount: 20, viewCount: 10805, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1495800, content: In this question the most important thing is getting the pattern correct. It is very easy to go down the wrong path and spend 10 minutes trying to figure out how to make a complicated algorithm work when a very easy one would suffice.\n\n> Thinking process\n\n1. First I looked at the problem and thought about how the printed pattern looked like it would be mapped out on a matrix. I wrote out the number of "main" columns and then the number of "middle" columns\n    ```\n    P           I         N\n    A      L    S     I   G\n    Y    A      H    R\n    P           I\n    ------------------------\n    4     2     4     2   2(*)\n    ``` \n    The last line is 2 only because the word ends, but we can see that the pattern is `4-2-4-2-4-...`. When drawing it out for `numRows = 3`, the pattern became \n\n     ```\n    P         A         H         N\n    A    P    L    S    I    I    G\n    Y         I         R\n    ---------------------------------\n    3    1    3    1    3    1    2(*)\n    ``` \n    Again we can see the pattern is `3-1-3-1-3-...`\n\n    So the pattern of "main" rows to "mid" rows is `n, n-2, n, n-2, ...`\n\n    When I tried to build an algorithm for this pattern I got stuck. How would I make the index move up `n`, then down `n-2` without confusing myself or missing edge cases?\n2. Next I tried to write out the row of each letter in the string. For numRows = 4, it became:\n   ```\n   P  A  Y  P  A  L  I  S  H  I  R  I  N  G\n   -----------------------------------------\n   1  2  3  4  3  2  1  2  3  4  3  2  1  2\n   ```\n   For numRows = 3, it became:\n    ```\n   P  A  Y  P  A  L  I  S  H  I  R  I  N  G\n   -----------------------------------------\n   1  2  3  2  1  2  3  2  1  2  3  2  1  2\n   ```\n\n   This is where I found the correct pattern. Basically instead of worrying about "main" rows vs. "mid" rows, it easily maps into moving the index from 1 -> numRows, and then from numRows -> 1. We don\'t even need to think about a matrix and worrying about rows vs. columns.\n\n> Algorithm\n\nAt first I thought about how to make the different rows as strings. How would I make `row1`, `row2`, `row3`? Sure if there were only a few rows I could hardcode them, but then how would I be able to add the character to each row easily? It is too difficult, so I thought using an array would be much better. \n\nThen I thought how would we make sure that we are going up and down in the correct pattern? The easiest way was to use a `going_up` flag to make sure to switch the direction of the index.\n\nLastly the only thing to check was edge cases, which by this point was pretty easy with a simple run through of the algorithm.\n\n> Code:\n\n```py\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n            \n        row_arr = [""] * numRows\n        row_idx = 1\n        going_up = True\n\n        for ch in s:\n            row_arr[row_idx-1] += ch\n            if row_idx == numRows:\n                going_up = False\n            elif row_idx == 1:\n                going_up = True\n            \n            if going_up:\n                row_idx += 1\n            else:\n                row_idx -= 1\n        \n        return "".join(row_arr)\n```\n\n> Time & Space Complexity\n\nTime: `O(n)`\n- We run through the whole string once: `O(n)`\n  - everything we do inside the for loop: `O(1)`\n- Finally we join the whole array int a string: `O(n)`\n\nSpace: `O(n)`\n- We are creating a new array: `O(n)`\n- We are using join to put it back into a string: `O(n)`, status: null, voteStatus: 0, voteCount: 203, creationDate: 1598653413, isHidden: null, author: {username: deleted_user, isActive: false, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 4332}}}, searchMeta: null}, {id: 3133966, title: Easy Explanation with Pics and Video | Java C++ Python, commentCount: 9, topLevelCommentCount: 8, viewCount: 20165, pinned: false, isFavorite: false, solutionTags: [{name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}], post: {id: 4922608, content: ![image](https://assets.leetcode.com/users/images/fdf22375-8354-4cb7-adb0-cef316e39a2d_1675385332.2793877.png)\n\n\nThings become clear with the above image.\n\n# Intuition:\n1. Just look at the top row what is the difference b/w each char i.e A and I and I and Q = 8\n            5*2-2 == numberOf rows *2 - 2 (The corner elements are excluded).\nSimilarly for each row i.e B and J the diff is 8, C and K is 8\n2. The interesting part comes when the char in the diagnoal has to be added, but even this has a pattern\n\t\n\tThere will be no char in between for row 0 and row n.\n\tThere can be only one diagonal char and the diagonal diff is original diff -2 at each step or diff - (rowNumber*2);\n\n# Approach\n\n1. Create an empty StringBuilder which is our ans.\n2.  Calculate the diff = numRows*2 -2;\n3. Iterate over 0 to rowNumber in a for loop  \nThe first char will be row number or i (append to String)\n4. Write a while loop in the above for loop :\n5. The first char will be row number or i (append to String)\n6. Calculate the diagonalDiff if any and append to the String.\n7. Increase the index by diff and return ans.\n\n\nhttps://youtu.be/YwU8pENP-vw\n# If you find this useful\n![image](https://assets.leetcode.com/users/images/2ffb3a66-a5d4-4df4-b5d2-d87bb7059594_1675386290.4900236.jpeg)\n\n```\nclass Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1) {\n            return s;\n        }\n        \n        StringBuilder answer = new StringBuilder();\n        int n = s.length();\n        int diff = 2 * (numRows - 1);\n        int diagonalDiff = diff;\n        int secondIndex;\n        int index;\n        for (int i = 0; i < numRows; i++) {\n            index = i;\n\n            while (index < n) {\n                answer.append(s.charAt(index));\n                if (i != 0 && i != numRows - 1) {\n                    diagonalDiff = diff-2*i;\n                    secondIndex = index + diagonalDiff;\n                    \n                    if (secondIndex < n) {\n                        answer.append(s.charAt(secondIndex));\n                    }\n                }\n                index += diff;\n            }\n        }\n        \n        return answer.toString();\n    }\n}\n```\n\n```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows == 1) {\n            return s;\n        }\n        \n        stringstream answer;\n        int n = s.length();\n        int diff = 2 * (numRows - 1);\n        int diagonalDiff = diff;\n        int secondIndex;\n        int index;\n        for (int i = 0; i < numRows; i++) {\n            index = i;\n\n            while (index < n) {\n                answer << s[index];\n                if (i != 0 && i != numRows - 1) {\n                    diagonalDiff = diff-2*i;\n                    secondIndex = index + diagonalDiff;\n                    \n                    if (secondIndex < n) {\n                        answer << s[secondIndex];\n                    }\n                }\n                index += diff;\n            }\n        }\n        \n        return answer.str();\n    }\n};\n\n```\n\n```\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        answer = \'\'\n        n = len(s)\n        diff = 2 * (numRows - 1)\n        diagonal_diff = diff\n        second_index = 0\n        index = 0\n        for i in range(numRows):\n            index = i\n            while index < n:\n                answer += s[index]\n                if i != 0 and i != numRows - 1:\n                    diagonal_diff = diff - 2 * i\n                    second_index = index + diagonal_diff\n                    if second_index < n:\n                        answer += s[second_index]\n                index += diff\n        return answer\n```\n, status: null, voteStatus: 0, voteCount: 125, creationDate: 1675386551, isHidden: null, author: {username: jeevankumar159, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1675908947.png, reputation: 2368}}}, searchMeta: null}, {id: 2837185, title: 100 % âœ”ï¸ Solution Explained with visualization to the code, commentCount: 2, topLevelCommentCount: 2, viewCount: 9240, pinned: false, isFavorite: false, solutionTags: [{name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 4532734, content: [https://youtu.be/EWZWiG750FI](), status: null, voteStatus: 0, voteCount: 54, creationDate: 1669058589, isHidden: null, author: {username: CoderrrMan, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1669150350.png, reputation: 6225}}}, searchMeta: null}, {id: 4673243, title: [VIDEO] Step-by-Step Visualization of O(n) Solution, commentCount: 0, topLevelCommentCount: 0, viewCount: 4591, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Array, slug: array}, {name: String, slug: string}], post: {id: 6917782, content: https://youtu.be/ytSl-K4xo3w\n\nThe key to solving this problem is to understand that we assign characters to rows by <i>oscillating</i> between the top and bottom rows.  In other words, if we traversed the string and looked at which row each character belonged to (let\u2019s say numRows is 3), the pattern would be 1 2 3 2 1 2 3 2 1.. so the first character goes in row 1, the second character goes in rows 2, the third character goes in row 3 - which is the bottom row - so now you go back up to row 2, then row 1.\n\nTo represent the rows, we\u2019ll use a 2D array named `rows`, where each inner list represents a row.  We then use a variable called `index` that will oscillate between the top and bottom rows and assign characters to rows.\n\nWe\u2019ll control the direction that index moves by using a variable called `step`.  `step` will either be 1 or -1, where a value of 1 means we need to increment the index (so move DOWN a row) and a value of -1 means we need to decrement the index (move UP a row).  Whenever we reach either the first or last row, we\'ll switch the direction to move `index` in the opposite direction.\n\nA common mistake I see is creating a 1D list and initializing an empty string for each row.  Then, instead of appending to a list, each character is added by using string concatenation.  While this works, this is not O(n) because strings are immutable.  In other words, string concatenation  allocates new memory and copies over each character from both strings to create an entirely new string.  That means that the string concatenation runs in O(n), so the overall algorithm runs in O(n<sup>2</sup>) time.\n\nInstead, by using lists (since lists are mutable), appending to a list runs in constant time - or more precisely, the amortized complexity of appending to a list is constant.  So that allows everything inside the loop to run in constant time, so the algorithm now runs in O(n) time.  \n\n# Code\n```\nclass Solution(object):\n    def convert(self, s, numRows):\n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        rows = [[] for row in range(numRows)]\n        index = 0\n        step = -1\n        for char in s:\n            rows[index].append(char)\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n\n        for i in range(numRows):\n            rows[i] = \'\'.join(rows[i])\n        return \'\'.join(rows)\n```, status: null, voteStatus: 0, voteCount: 36, creationDate: 1706994631, isHidden: null, author: {username: AlgoEngine, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1673908639.png, reputation: 5273}}}, searchMeta: null}, {id: 791453, title: 90% faster and 90% less space + explanation, commentCount: 4, topLevelCommentCount: 3, viewCount: 2536, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1449881, content: The idea is to go up and down the zigzag\n\n```\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows < 2:\n            return s\n        i = 0\n        res = [""]*numRows      # We will fill in each line in the zigzag\n        for letter in s:\n            if i == numRows-1:  # If this is the last line in the zigzag we go up\n                grow = False\n            elif i == 0:        #Otherwise we go down\n                grow = True \n            res[i] += letter    #Add the letter to its row\n            i = (i+1) if grow else i-1  # We increment (add 1) if grow is True, \n\t\t\t                            # and decrement otherwise\n\t\t\t\t\t\t\t\t\t\t\n        return "".join(res)     # return the joined rows\n```\n\nDo you like my solution?, status: null, voteStatus: 0, voteCount: 33, creationDate: 1597411962, isHidden: null, author: {username: MariaMozgunova, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1654438974.png, reputation: 70}}}, searchMeta: null}, {id: 3134883, title: Python3 68ms, commentCount: 1, topLevelCommentCount: 1, viewCount: 3786, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 4923887, content: \n![image.png](https://assets.leetcode.com/users/images/7355fe80-b411-48ef-8793-ad7991645e93_1675406149.6565611.png)\nPlease UPVOTE if it helps \u2764\uFE0F\uD83D\uDE0A\nThank You and Happy To Help You!!\n# Code\n```\nclass Solution:\n    def convert(self, s: str, n: int) -> str:\n        if(n==1):\n            return s\n        ans=["" for i in range(n)]\n        x=0\n        bl=True\n        for i in range(len(s)):\n            if(bl and x==n):\n                bl=False\n                x-=1\n            if(not bl and x==0):\n                x+=1\n                bl=True\n            if(bl):\n                ans[x]+=s[i]\n                x+=1\n            else:\n                x-=1\n                ans[x]+=s[i]\n        s=""\n        for i in ans:\n            s+=i\n        return s\n```, status: null, voteStatus: 0, voteCount: 17, creationDate: 1675406168, isHidden: null, author: {username: abdullayev_akbar, isActive: true, nameColor: null, activeBadge: {displayName: Data Structure I, icon: https://assets.leetcode.com/static_assets/others/DS_I.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1670287703.png, reputation: 4173}}}, searchMeta: null}, {id: 354390, title: [Python3] mod to calculate the pattern with explanation, commentCount: 1, topLevelCommentCount: 1, viewCount: 1030, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 675245, content: ```\ns = "PAYPALISHIRING"\nnumRow = 3\n        """\n        p (0)      a(4)      h(8)         n(12)\n        a (1) p(3) l(5) s(7) i(9) i(11)  g(13)\n        y (2)      i(6)      r(10)\n        """\n# There is a pattern consists 4 elements as below:\n\t\t"""\n        p (0)     \n        a (1)  p(3) \n        y (2)     \n        """\n# The ith element can be mapping into this pattern by i%pattern_length:\nThe first line: 0 % 4 = 4 % 4 = 8 % 4 = 12 % 4 =0\n"""\n p (0)      a(4)      h(8)         n(12)\n"""\nThe second line: there is 2 type pattern:\na: 1 % 4 = 5 % 4 = 9 % 4 = 13 % 4 = 1\nb: 3 % 4 = 7 % 4 = 11 % 4 = 3\nSo here we need an extra mapping to deal with these 2 situations.\n1 = 4 - 3 is key to combine these two situation into one.\n d={i:i if i<numRows else (period-i) for i in range(period)}\n"""\na (1) p(3) l(5) s(7) i(9) i(11)  g(13)\n"""\nThe third line:\n2 % 4 = 6 % 4 = 10  % 4 = 2\n"""\n y (2)      i(6)      r(10)\n"""\n```\n\n```\nPeriod 4\nd =  {0: 0, 1: 1, 2: 2, 3: 1}\ni =  0   i%period =  0\nlines: [\'P\', \'\', \'\']\ni =  1   i%period =  1\nlines: [\'P\', \'A\', \'\']\ni =  2   i%period =  2\nlines: [\'P\', \'A\', \'Y\']\ni =  3   i%period =  3\nlines: [\'P\', \'AP\', \'Y\']\ni =  4   i%period =  0\nlines: [\'PA\', \'AP\', \'Y\']\ni =  5   i%period =  1\nlines: [\'PA\', \'APL\', \'Y\']\ni =  6   i%period =  2\nlines: [\'PA\', \'APL\', \'YI\']\ni =  7   i%period =  3\nlines: [\'PA\', \'APLS\', \'YI\']\ni =  8   i%period =  0\nlines: [\'PAH\', \'APLS\', \'YI\']\ni =  9   i%period =  1\nlines: [\'PAH\', \'APLSI\', \'YI\']\ni =  10   i%period =  2\nlines: [\'PAH\', \'APLSI\', \'YIR\']\ni =  11   i%period =  3\nlines: [\'PAH\', \'APLSII\', \'YIR\']\ni =  12   i%period =  0\nlines: [\'PAHN\', \'APLSII\', \'YIR\']\ni =  13   i%period =  1\nlines: [\'PAHN\', \'APLSIIG\', \'YIR\']\n```\n\n```\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        """\n        p (0)      a(4)      h(9)         n(13)\n        a (1) p(3) l(6) s(8) i(10) i(12)  g(14)\n        y (2)      i(7)      r(11)\n        """\n        if numRows==1:return s\n        period= 2*(numRows -1)\n        d={i:i if i<numRows else (period-i) for i in range(period)}\n        lines=["" for i in range(numRows)]\n        for i in range(len(s)):\n            lines[d[i%period]] +=s[i]\n        return "".join(lines)\n```, status: null, voteStatus: 0, voteCount: 13, creationDate: 1565326980, isHidden: null, author: {username: zhanweiting, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/weiting-zhan/avatar_1529194985.png, reputation: 3849}}}, searchMeta: null}, {id: 4051564, title: Simple O(n) Python Solution for Zigzag Strings, commentCount: 0, topLevelCommentCount: 0, viewCount: 1279, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 6114745, content: # Intuition\nThink of it like bouncing a ball: it goes down, hits the floor, and bounces back up. This is like our zigzag pattern with the string.\n\n# Approach\n1. If we only have one row or more rows than letters, just give back the original word.\n2. I used a jump thing to know if I should go up or down. If I\'m at the top, I\'ll go down. If I\'m at the bottom, I\'ll go up.\n3. For each letter in the word, I put it in the right row and then decide if I should move up or down next.\n4. After placing all the letters, I put all the rows together for the final word.\n\n# Complexity\n- Time complexity:\nIt\'s pretty quick. It goes through the word once, so $$O(n)$$.\n\n- Space complexity:\nI saved space. I only made room for the letters in the word, so $$O(n)$$ space.\n\n# Code\n```\nclass Solution(object):\n    def convert(self, s, numRows):\n        """\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        """\n        if numRows == 1 or numRows >= len(s):\n            return s\n        result = [\'\'] * numRows\n        row, jump = 0, 1\n\n        for char in s:\n            result[row] += char\n            if row == 0:\n                jump = 1\n            elif row == numRows - 1:\n                jump = -1\n            row += jump\n        \n        return \'\'.join(result)\n```, status: null, voteStatus: 0, voteCount: 8, creationDate: 1694868051, isHidden: null, author: {username: dhruvpuri-goswami, isActive: true, nameColor: null, activeBadge: {displayName: Top SQL 50, icon: https://assets.leetcode.com/static_assets/others/Top_SQL_50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1673029326.png, reputation: 9}}}, searchMeta: null}, {id: 427621, title: Python Solution with Step by Step Walk Through (Beats 95%), commentCount: 1, topLevelCommentCount: 1, viewCount: 643, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 815757, content: ```\nclass Solution(object):\n    def convert(self, s, numRows):\n        if numRows == 1:\n            return s\n        \n\t\t# Store all levels as arr inside a larger levels arr\n        levels = []\n        for n in range(numRows):\n            levels.append([])\n\n        # Iterate through letters of the string\n\t\t# For each letter, append it to the level that corresponds to the level variable below\n\t\t# Add step to level to increase/decrease level\n        level = 0\n        step = 1\n        \n        for letter in s:\n            levels[level].append(letter)\n            level += step\n            \n\t\t\t# Step turns negative when we reach the last level\n\t\t\t# Step turns positive when we reach the top level\n            if level == 0 or level == numRows-1:\n                step *= -1\n        \n\t\t# Convert the list of letter into strings\n        for level, string in enumerate(levels):\n            levels[level] = \'\'.join(string)\n           \n        return \'\'.join(levels)\n```\n\n## Example: \nstring = \'hello\' \nnumRows = 3 \n\n**Iteration #1** \n\t- append current letter to current level\n\t- increment level by step\n```\n\tlevel = 0 \n\tstep = 1\n\tstring = \'(h)ello\'\n\t\n\tlevels = [\n\t\t\t\t[],    # Level One  <- current level\n\t\t\t\t[],    # Level Two\n\t\t\t\t[]     # Level Three\n\t\t\t]\n```\n**Iteration #2**\n \t- append current letter to current level\n\t- increment level by step\n```  \n\t   level = 1\n\t   step = 1\n\t   string = \'h(e)llo\'\n      \n\t\tlevels = [\n\t\t\t\t\t[\'h\'],     # Level One \n\t\t\t\t\t[],        # Level Two <- current level\n\t\t\t\t\t[]         # Level Three\n\t\t\t\t]\n```\n**Iteration #3**\n\t- append current letter to current level\n\t- increment level by step\t\n\t- Current level is max level depth\n\t      -> So begin going up levels (step *= -1)\n```\n\t   level = 2\n\t   step = 1\n\t\t            \n\t\tlevels = [\n\t\t\t\t\t[\'h\'],     # Level One \n\t\t\t\t\t[\'e\'],     # Level Two \n\t\t\t\t\t[]         # Level Three <- current level\n\t\t\t\t]\n\t\t\n\t\tstring = \'he(l)lo\'\n```\n**Iteration #4**\n\t- append current letter to current level\n\t- increment level by step (-1)\n```\n\t    level = 1\n\t    step = -1\n\t\tstring = \'hel(l)o\'            \n\t\tlevels = [\n\t\t\t\t\t[\'h\'],       # Level One \n\t\t\t\t\t[\'e\'],       # Level Two  <- current level\n\t\t\t\t\t[\'l\']        # Level Three \n\t\t\t\t]\n```\n**Iteration #5**\n\t- append current letter to current level\n\t- increment level by step (-1)\n```\n\t   level = 0\n\t   step = -1\n\t   string = \'hell(o)\'     \n\t   \n\t\tlevels = [\n\t\t\t\t\t[\'h\'],         # Level One    <- current level\n\t\t\t\t\t[\'e\', \'l\'],    # Level Two\n\t\t\t\t\t[\'l\']          # Level Three \n\t\t\t\t]\n```\n**Iteration #6**\n\t- append current letter to current level\n\t- increment level by step (-1)\n```\n\t   level = 0\n\t   step = -1\n\t   string = \'hello\'\n\t            \n\t\tlevels = [\n\t\t\t\t\t[\'h\', \'o\'],    # Level One    <- current level\n\t\t\t\t\t[\'e\', \'l\'],    # Level Two\n\t\t\t\t\t[\'l\']          # Level Three \n\t\t\t\t]\n\t\t\n```\n**Done with string iteration, time to create an answer**\nFinal levels array looks like: \n```\n\t\tlevels = [\n\t\t\t\t\t[\'h\', \'o\'],    # Level One\n\t\t\t\t\t[\'e\', \'l\'],    # Level Two\n\t\t\t\t\t[\'l\']          # Level Three \n\t\t\t\t]\n```\nJoin letters inside each level together as a level string:\n\n\t\t\tlevels = [\n\t\t\t\t\t[\'ho\'],    # Level One\n\t\t\t\t\t[\'el\'],    # Level Two\n\t\t\t\t\t[\'l\']      # Level Three \n\t\t\t\t]\n\t\t\n\t\t\nJoin all level strings together:\n\n\t\tanswer = \'hoell\'\n\t\n, status: null, voteStatus: 0, voteCount: 8, creationDate: 1573596201, isHidden: null, author: {username: teampark, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/ttpark/avatar_1577464095.png, reputation: 5606}}}, searchMeta: null}, {id: 4387201, title: ZigZag Conversion Decoded! ðŸ”„âœ¨ Code in C++, Java, Python, C#, JS ðŸš€, commentCount: 4, topLevelCommentCount: 3, viewCount: 1584, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}, {name: JavaScript, slug: javascript}, {name: String, slug: string}], post: {id: 6554518, content: # \u2753ZigZag Conversion\u2753\n---\n\n## \uD83D\uDCA1Approach 1: ZigZag Pattern\n\n### \u2728Explanation\nThe solution utilizes the zigzag pattern to convert the input string. It initializes a vector of strings representing each row and iterates through the input string, placing characters in the corresponding rows based on the zigzag pattern.\n\n### \uD83D\uDCDDDry Run\nLet\'s take the example input "PAYPALISHIRING" with numRows = 3:\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n#### Execution Steps:\n\n1. **Initialization:**\n   - `rows`: ["", "", ""]\n   - `direction`: -1\n   - `idx`: 0\n\n2. **Iterative Placement:**\n   - Process characters one by one and place them in the corresponding rows.\n   - Adjust the row index based on the zigzag pattern.\n\n3. **Resultant `rows`:**\n   - ["PAHN", "APLSIIG", "YIR"]\n\n4. **Combining Rows:**\n   - Concatenate the rows to obtain the final result: "PAHNAPLSIIGYIR"\n\n### \uD83D\uDD78\uFE0F Complexity Analysis\n\n- **Time Complexity:** O(N), where N is the length of the input string.\n- **Space Complexity:** O(min(N, numRows)), as `rows` stores each row.\n\n\n## \uD83D\uDCA1 Additional Explanation\n\n### \uD83D\uDE80 Handling Single Row Case\n\nThe solution efficiently handles the case when numRows is 1. In such a scenario, the input string remains unchanged, and the original string is returned. This optimization improves the overall efficiency of the algorithm.\n\n\n### \uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDCBBCodes in (C++) (Java) (Python) (C#) (JavaScript)\n\n```cpp []\nclass Solution {\npublic:\n    string convert(string inputString, int numRows) {\n        // If there\'s only one row, return the string as it is\n        if (numRows == 1) return inputString;\n        \n        vector<string> rows(min(numRows, int(inputString.size())), "");\n        int direction = -1; // -1 represents down, 1 represents up\n        int currentRow = 0;\n        \n        for (int i = 0; i < inputString.size(); i++) {\n            rows[currentRow] += inputString[i];\n            currentRow += (direction == -1) ? 1 : -1;\n            \n            // Change direction when reaching the first or last row\n            if (currentRow == 0 || currentRow == numRows - 1) {\n                direction = -direction;\n            }\n        }\n        \n        string result = "";\n        for (const auto& row : rows) {\n            result += row;\n        }\n        \n        return result;\n    }\n};\n```\n\n```java []\n// Java code block for the approach\nclass Solution {\n    public String convert(String inputString, int numRows) {\n        if (numRows == 1) return inputString;\n\n        List<StringBuilder> rows = new ArrayList<>();\n        for (int i = 0; i < Math.min(numRows, inputString.length()); i++) {\n            rows.add(new StringBuilder());\n        }\n\n        int direction = -1;\n        int currentRow = 0;\n\n        for (char c : inputString.toCharArray()) {\n            rows.get(currentRow).append(c);\n            currentRow += (direction == -1) ? 1 : -1;\n\n            if (currentRow == 0 || currentRow == numRows - 1) {\n                direction = -direction;\n            }\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) {\n            result.append(row);\n        }\n\n        return result.toString();\n    }\n}\n```\n\n```python []\n# Python code block for the approach\nclass Solution:\n    def convert(self, inputString: str, numRows: int) -> str:\n        if numRows == 1:\n            return inputString\n\n        rows = [\'\'] * min(numRows, len(inputString))\n        direction, current_row = -1, 0\n\n        for char in inputString:\n            rows[current_row] += char\n            current_row += 1 if direction == -1 else -1\n\n            if current_row == 0 or current_row == numRows - 1:\n                direction = -direction\n\n        return \'\'.join(rows)\n```\n\n```csharp []\n// C# code block for the approach\npublic class Solution {\n    public string Convert(string inputString, int numRows) {\n        if (numRows == 1) return inputString;\n\n        List<StringBuilder> rows = new List<StringBuilder>(Math.Min(numRows, inputString.Length));\n        for (int i = 0; i < Math.Min(numRows, inputString.Length); i++) {\n            rows.Add(new StringBuilder());\n        }\n\n        int direction = -1;\n        int currentRow = 0;\n\n        foreach (char c in inputString) {\n            rows[currentRow].Append(c);\n            currentRow += (direction == -1) ? 1 : -1;\n\n            if (currentRow == 0 || currentRow == numRows - 1) {\n                direction = -direction;\n            }\n        }\n\n        StringBuilder result = new StringBuilder();\n        foreach (StringBuilder row in rows) {\n            result.Append(row);\n        }\n\n        return result.ToString();\n    }\n}\n```\n\n```javascript []\n// JavaScript code block for the approach\n\n    var convert = function(inputString, numRows) {\n        if (numRows === 1) return inputString;\n\n        const rows = new Array(Math.min(numRows, inputString.length)).fill(\'\');\n        let direction = -1;\n        let currentRow = 0;\n\n        for (const char of inputString) {\n            rows[currentRow] += char;\n            currentRow += (direction === -1) ? 1 : -1;\n\n            if (currentRow === 0 || currentRow === numRows - 1) {\n                direction = -direction;\n            }\n        }\n\n        return rows.join(\'\');\n    }\n\n```\n---\n## \uD83D\uDCCA Analysis\n\n![image.png](https://assets.leetcode.com/users/images/74236461-10b4-48ad-9829-b214c1d51ee7_1702226478.652393.png)\n\n| Language    | Runtime (ms) | Memory (MB) |\n|-------------|--------------|-------------|\n| C++         | 3            | 11          |\n| JAVA        | 5            | 44.5        |\n| PYTHON      | 56           | 16.4        |\n| JAVASCRIPT  | 69           | 45.4        |\n| C#          | 100          | 48.8        |\n\n\n---\n\n##  \uD83D\uDCAF Related Questions and Practice\n- [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/)\n- [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/description/)\n---\n\n# Consider UPVOTING\u2B06\uFE0F\n\n![image.png](https://assets.leetcode.com/users/images/853344be-bb84-422b-bdec-6ad5f07d0a7f_1696956449.7358863.png)\n\n# DROP YOUR SUGGESTIONS IN THE COMMENT\n\n## Keep Coding\uD83E\uDDD1\u200D\uD83D\uDCBB\n\n -- *MR.ROBOT SIGNING OFF*, status: null, voteStatus: 0, voteCount: 7, creationDate: 1702226915, isHidden: null, author: {username: LakshayBrejwal_1_0, isActive: true, nameColor: null, activeBadge: {displayName: Apr LeetCoding Challenge, icon: /static/images/badges/dcc-2022-4.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1693891977.png, reputation: 347}}}, searchMeta: null}, {id: 3135865, title: ðŸ“ŒðŸ“ŒPython3 || âš¡49 ms, faster than 95.18% of Python3, commentCount: 0, topLevelCommentCount: 0, viewCount: 931, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: String, slug: string}], post: {id: 4925140, content: ```\ndef convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        zigzag = [\'\' for _ in range(numRows)]\n        row = 0\n        step = 1\n        for c in s:\n            zigzag[row] += c\n            if row == numRows-1:\n                step = -1\n            elif row == 0:\n                step = 1\n            row += step\n        return \'\'.join(zigzag)\n```\nThe code implements a solution to the problem of converting a given string into a zigzag pattern using a specified number of rows. The steps involved are as follows:\n\n1. Check if the number of rows is 1. If so, return the input string as is, as there\'s no zigzag pattern to be formed.\n1. Initialize an empty list, called "zigzag", with "numRows" number of empty strings. This list will store the zigzag pattern of the input string.\n1. Initialize two variables, "row" and "step", both set to 0. "row" will be used to keep track of the current row that we\'re adding characters to, while "step" will determine the direction in which we\'re adding characters.\n1. Loop through each character in the input string "s".\n1. Add the current character to the "zigzag" list, at the current row.\n1. Update the value of "step" based on the current row. If "row" is equal to "numRows - 1", set "step" to -1, which will cause the next character to be added to the previous row. If "row" is equal to 0, set "step" to 1, which will cause the next character to be added to the next row.\n1. Update the value of "row" by adding "step".\n1. Repeat steps 5-7 for each character in the input string "s".\n1. After the loop, join all the strings in the "zigzag" list together and return the result as the final zigzag pattern of the input string., status: null, voteStatus: 0, voteCount: 7, creationDate: 1675423023, isHidden: null, author: {username: harshithdshetty, isActive: true, nameColor: null, activeBadge: {displayName: Jan LeetCoding Challenge, icon: /static/images/badges/dcc-2023-1.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1672100960.png, reputation: 356}}}, searchMeta: null}, {id: 3133912, title: python3 | c++ | generate row pattern and merge array, commentCount: 2, topLevelCommentCount: 2, viewCount: 2792, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: C, slug: c}, {name: Iterator, slug: iterator}], post: {id: 4922536, content: **Python3**\n\nGenerate the row number pattern for the string which is ... fwd, rev, fwd, etc\n0,1,2...n, [n-1, ... 1],0,1,2,3  .. n\n```\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        rr = range(numRows)\n        pattern = list(rr) + list(range(numRows-2, 0, -1))\n        times = math.ceil(len(s)/len(pattern))\n        patterns = pattern*times\n        \n        arr = ["" for _ in rr] \n\n        for a,b in zip(patterns, s):\n            arr[a] += b\n        \n        return "".join(arr)\n```\n**C++**\n\nA slighly different solution but depending on the same logic of patterns fwd,rev, etc\n\n```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int S = s.length(), index = 0, alen = S > numRows ? S : numRows, direction=1; \n        string vs[alen+1], ans;\n        \n        for (int i = 0; i < S; i++) {\n            vs[index] += s[i];\n            if (index == numRows-1 || index == 0) {\n                direction = 1 - direction;\n            }\n            if (!direction) {\n                index += 1;\n            } else { \n                index -= 1;\n            }\n            \n        }\n        for (int i = 0; i <= alen; i++) {\n            ans += vs[i];\n        }\n        \n        return ans;\n    }\n};, status: null, voteStatus: 0, voteCount: 6, creationDate: 1675384706, isHidden: null, author: {username: iter_next, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1673118556.png, reputation: 94}}}, searchMeta: null}, {id: 3135775, title: Python simple solution â€“ 46 ms beats 97%, commentCount: 0, topLevelCommentCount: 0, viewCount: 651, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 4925022, content: # Intuition\nk goes up and down so we add current letter to the right substring\n\n\n# Code\n```\nclass Solution:\n    def convert(self, s: str, n: int) -> str:\n        if n == 1:\n            return s\n\n        a = [\'\']*n\n        k = index = 0\n\n        for letter in s:\n            a[k%n] += letter\n\n            if k == n-1:\n                index = 1\n            if k == 0:\n                index = 0\n            k = k+1 if index == 0 else k-1\n\n        result = a[0]\n        for i in a[1:]:\n            result += i\n        return result\n```, status: null, voteStatus: 0, voteCount: 4, creationDate: 1675421226, isHidden: null, author: {username: Saltkroka, isActive: true, nameColor: null, activeBadge: {displayName: Dec LeetCoding Challenge, icon: /static/images/badges/dcc-2022-12.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1675536002.png, reputation: 72}}}, searchMeta: null}, {id: 3135511, title: Python3 50ms ðŸ”¥very simple solution: Detailed ExplainedðŸ”¥ðŸ”¥ðŸ”¥, commentCount: 1, topLevelCommentCount: 1, viewCount: 2288, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 4924691, content: # Intuition\n**![Capture.PNG](https://assets.leetcode.com/users/images/c777de6f-78d4-4daa-b97d-14a9b04c4ae0_1675446391.282558.png)**\n<!-- Describe your first thoughts on how to solve this problem. -->\n**Zig-zag traversal is simple level order string traversal.**\n# Approach\n<!-- Describe your approach to solving the problem. -->\n- we have to travers in level order, and our $$level-threshold$$ is $$numRows$$.\n- travers over $$length-of-string$$ and initial level is $$0$$.\n- increment level by 1 in each iteration\n- if we reach at last level according to numRows then $$traverse backwards$$ and decrement level by 1.\n- put current alphabet from string s to it\'s respective level\n- this all operation happens in $$O(n)$$ times.\n- now $$concatenate-all-characters$$ from level array and return, this also happens in $$O(n)$$ time.\n# Complexity\n- Time complexity: $$O(2n)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(n+c)$$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        ans = [[] for _ in range(numRows)]\n        level = 0\n        answer = ""\n        forward = True\n        for i in range(len(s)):\n            ans[level].append(s[i])\n            if forward:\n                level += 1\n            if not forward:\n                level -= 1\n            if level > numRows - 1:\n                level -= 2\n                forward = False\n            if level < 0:\n                level += 2\n                forward = True\n        for i in ans:\n            for j in i:\n                answer += j\n        return answer\n```, status: null, voteStatus: 0, voteCount: 4, creationDate: 1675416697, isHidden: null, author: {username: shivam_1110, isActive: true, nameColor: null, activeBadge: {displayName: Feb LeetCoding Challenge, icon: /static/images/badges/dcc-2023-2.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1674718657.png, reputation: 282}}}, searchMeta: null}, {id: 3134192, title: Python | well Explanation | Simple | Easy âœ…âœ…, commentCount: 0, topLevelCommentCount: 0, viewCount: 555, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 4922923, content: ![explanision.PNG](https://assets.leetcode.com/users/images/39ed3cd5-0c1e-4353-af74-777a021ecdcb_1675392805.2104511.png)\nI solved this problem using index of each character in string `s`\n###  The first and last rows:\nI find sequence of numbers that, each element is greater than the one before it by 6 (add) `2*numRows - 2`,\n### The others rows:\nThere are two numbers, the difference between them is fixed and repeated every `numRows`,\nThe first number, like the one I mentioned before, is greater than the one before it by 6 (add) `2*numRows - 2`.\nThe second is greater than the first by this equation: `index = j + add - 2*i`, `j: index of character`, `i: number of row`.\nAnd then I add every character using these equations in string `word` \n\n# Code\n```\nclass Solution(object):\n    def convert(self, s, numRows):\n        """\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        """\n        if numRows == 1:\n            return s\n        word = ""\n        add = 2*numRows - 2\n        n = len(s)\n        for i in range(numRows):\n            if i == 0 or i == numRows-1:\n                for j in range(i,n,add):\n                    word += s[j]\n            else:\n                for j in range(i,n,add):\n                    word += s[j]\n                    index = j + add - 2*i\n                    if index < n:\n                        word += s[index]\n                    \n        return word\n```, status: null, voteStatus: 0, voteCount: 4, creationDate: 1675394179, isHidden: null, author: {username: emadmagdy72, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1672609331.png, reputation: 20}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 1492, solutions: [{id: 732756, title: 24ms (96.82%) Python3 solution, commentCount: 30, topLevelCommentCount: 12, viewCount: 18168, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1350478, content: Python\'s `bit_length()` is useful, it returns the number of bits required to represent an integer in binary. \n\nWe can utilize this and create a compound conditional statement for dealing with the assumption of 32-bit signed integer range.\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        rev = int(str(abs(x))[::-1])\n        return (-rev if x < 0 else rev) if rev.bit_length() < 32 else 0\n```\n\nThis approach is faster than other approaches, for example: `join()` and `reversed()`., status: null, voteStatus: 0, voteCount: 63, creationDate: 1594570402, isHidden: null, author: {username: deleted_user, isActive: false, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 4332}}}, searchMeta: null}, {id: 408697, title: Two Python Solutions and Explanation of Python Modulo and Int Division Differences From C/Java, commentCount: 7, topLevelCommentCount: 6, viewCount: 6200, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 776961, content: **Solution 1:** \nSimilar Approach to the official solution, but modified to work with python modulo and division differences\n\n```\n    def reverse_v1(self, x: int) -> int:\n        reverse = 0\n        max_int = pow(2, 31)-1\n        min_int = pow(-2, 31)\n        \n        while x != 0:   \n            # Python modulo does not work the same as c or java. It always returns the same\n            # sign as the divisor and rounds towards negative infinit. Also // rounds towards negative infinity not 0 as in C so this also\n            # behaves differently. Python 3.7 added a math.remainder(), but leet code is\n            # running a python version prior to this (at least at the time of writing). Since the C \'remainder\' behavior is desirable for\n            # this problem, the following code emulates it. \n            #\n            # See https://stackoverflow.com/questions/1907565/c-and-python-different-behaviour-of-the-modulo-operation and\n\t\t\t# http://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html\n            pop = x % 10 if x >= 0 else (abs(x) % 10)*-1\n            x = x // 10 if x >=0 else math.ceil(x / 10)\n\n            if (reverse > max_int//10) or (reverse == max_int // 10 and pop > 7):\n                return 0\n            \n            if (reverse < math.ceil(min_int / 10)) or (reverse == math.ceil(min_int / 10) and pop < -8):\n                return 0\n            \n            reverse = reverse * 10 + pop\n        \n        return reverse\n```\n\n**Solution 2:** \nUsing string as an intermediate representation. \n\n```\ndef reverse_v2(self, x: int) -> int:\n\tmax_int = pow(2, 31)-1\n\tmin_int = pow(-2, 31)\n\n\tstr_x = str(abs(x))\n\tstr_x_reversed = str_x[::-1]\n\tresult = int(str_x_reversed)\n\tresult = result * -1 if x < 0 else result\n\n\treturn result if (result < max_int and result > min_int) else 0\n```, status: null, voteStatus: 0, voteCount: 42, creationDate: 1571517808, isHidden: null, author: {username: grand-nagus-rom, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/grand-nagus-rom/avatar_1571518204.png, reputation: 43}}}, searchMeta: null}, {id: 4854766, title: ã€Videoã€‘2 ways to solve this question, commentCount: 2, topLevelCommentCount: 1, viewCount: 5982, pinned: false, isFavorite: false, solutionTags: [{name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 7151855, content: # Intuition\nConvert input to string or use remainders.\n\n# Solution Video\n\nhttps://youtu.be/Y_NCKgC3BiM\n\n### \u2B50\uFE0F\u2B50\uFE0F Don\'t forget to subscribe to my channel! \u2B50\uFE0F\u2B50\uFE0F\n\n**\u25A0 Subscribe URL**\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\nSubscribers: 4,010\nThank you for your support!\n\n---\n\n# Approach\n\nI think there are several ways to reverse integer but I\'ll show you two ways to solve this question.\n\n# Solution 1 - Convert to string\n\nSimply, if we convert input number to string, we can reverse the string number then convert it to integer again.\n\n```\nInput: x = 123\n```\nConvert to string.\n```\n123 \u2192 "123"\n```\nThen reverse "123".\n```\n"123" \u2192 "321"\n```\nThen Convert it to integer again.\n\n```\n"321" \u2192 321\n```\n```\nreturn 321\n```\n\nBe careful! We have also negative case. In that case, start reversing the string from `index 1`, not `index 0`.\n\nEasy!\uD83D\uDE04\nLet\'s see a solution codes and step by step algorithm!\n\nIn the solution codes, we have \n```\nif res > 2 ** 31 - 1 or res < -2 ** 31:\n    return 0\n```\nbut we don\'t have to worry about it. It\'s a requirement the description says.\n\n---\nIf reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n\n---\n---\n\n\u2B50\uFE0F I recently created a video on how I\'ve been using LeetCode to learn.\n\nhttps://youtu.be/bU_dXCOWHls\n\n---\n\n```python []\nclass Solution:\n    def reverse(self, x: int) -> int:\n        res = 0\n        if x < 0:\n            res = int(str(x)[1:][::-1]) * -1\n        else:\n            res = int(str(x)[::-1])\n        \n        if res > 2 ** 31 - 1 or res < -2 ** 31:\n            return 0\n        \n        return res\n```\n```javascript []\nvar reverse = function(x) {\n    let res = 0;\n    if (x < 0) {\n        res = parseInt(String(x).slice(1).split(\'\').reverse().join(\'\')) * -1;\n    } else {\n        res = parseInt(String(x).split(\'\').reverse().join(\'\'));\n    }\n\n    if (res > Math.pow(2, 31) - 1 || res < -Math.pow(2, 31)) {\n        return 0;\n    }\n\n    return res;    \n};\n```\n```java []\nclass Solution {\n    public int reverse(int x) {\n        int res = 0;\n        boolean isNegative = x < 0;\n        String strX = String.valueOf(Math.abs(x));\n        StringBuilder sb = new StringBuilder(strX).reverse();\n        \n        try {\n            res = Integer.parseInt(sb.toString());\n        } catch (NumberFormatException e) {\n            return 0;\n        }\n        \n        return isNegative ? -res : res;       \n    }\n}\n```\n\n## Step by step algorithm\n\n1. **Initialize the result variable `res`**:\n    ```python\n    res = 0\n    ```\n    - We start by initializing the variable `res` to store the reversed integer.\n\n2. **Check if the input number `x` is negative**:\n    ```python\n    if x < 0:\n    ```\n    - We check if the given integer `x` is negative.\n\n3. **Reverse the digits of the integer**:\n    ```python\n    res = int(str(x)[1:][::-1]) * -1\n    ```\n    - If `x` is negative, we convert it to a string, remove the negative sign (`str(x)[1:]`), reverse the string (`[::-1]`), convert it back to an integer, and then multiply by -1 to keep the sign negative.\n\n4. **Handle positive integers**:\n    ```python\n    else:\n        res = int(str(x)[::-1])\n    ```\n    - If `x` is positive, we simply convert it to a string, reverse the string, and then convert it back to an integer.\n\n5. **Check for overflow**:\n    ```python\n    if res > 2 ** 31 - 1 or res < -2 ** 31:\n        return 0\n    ```\n    - We check if the reversed integer `res` is within the range of a 32-bit signed integer. If it exceeds this range, we return 0 to indicate overflow.\n\n6. **Return the reversed integer**:\n    ```python\n    return res\n    ```\n    - Finally, we return the reversed integer.\n\nOverall, the code efficiently reverses the digits of the given integer while handling negative numbers and checking for overflow. It demonstrates a concise approach to solve the problem.\n\n\n---\n\n# Solution 2 - Using remainder\n\nLet me use the same input.\n\n```\nInput: x = 123\n```\nIn the end, we want to return `321`, so how we can move `3` to the first position?\n\nMy strategy is to use remainder divided by `10`.\n\n```\n123 % 10 = 3\n```\nWe can get `3` easily and add `3` to result variable(=`res`).\n\n```\nres = 3\n```\nBut the next question is "How can we get `2` from `123`?"\n\nMy answer is to divide `123` by `10` so that we can get `12` for the next process. This time not remainder, we use the answer.\n\n```\n123 // 10 = 12\nx = 12\n```\nWe will get remainder of\n```\n12 % 10 = 2\n```\nThe next problem is now `res = 3` and we got `2`. We want to create `32` right? Because in the end we want to return `321`. How can we create `32` with `3` and `2`?\n\nMy answer is to multiply `10` with `res`, then add remainder(= `2`) to it.\n\n\n---\n\n\n\u2B50\uFE0F Points\n```\nres = (res * 10) + (x % 10)\n```\n```\nres = (3 * 10) + (12 % 10)\n= 32\n```\n---\n\nWe got `32`. Next, we want `1` to create `321`, so devide `12` by `10`.\n```\n12 // 10 = 1\nx = 1\n```\nThen we use the same formula above.\n```\nres = (res * 10) + (x % 10)\nres = (32 * 10) + (1 % 10)\n= 321\n\nx(= 1) // 10 = 0\n```\nWhen we reach `0`, we finish iteration.\n```\nreturn 321\n```\n\nOf course, we handle negative case, but I believe you can understand it easily if you see the solution codes. Just convert a negative to a positive, reverse numbers, then convert the positive to a negative before we return output.\n\n```python []\nclass Solution:\n    def reverse(self, x: int) -> int:\n        is_negative = False\n\n        if x < 0:\n            is_negative = True\n            x *= -1\n        \n        res = 0\n        while x > 0:\n            res = (res * 10) + (x % 10)\n            x //= 10\n        \n        if res > 2 ** 31 - 1:\n            return 0\n        \n        return res * -1 if is_negative else res\n                \n```\n```javascript []\n/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n    let isNegative = false;\n\n    if (x < 0) {\n        isNegative = true;\n        x *= -1;\n    }\n    \n    let res = 0;\n    while (x > 0) {\n        res = (res * 10) + (x % 10);\n        x = Math.floor(x / 10);\n    }\n    \n    if (res > Math.pow(2, 31) - 1) {\n        return 0;\n    }\n    \n    return isNegative ? -res : res;    \n};\n```\n```java []\nclass Solution {\n    public int reverse(int x) {\n        int reversed = 0;\n        while (x != 0) {\n            int digit = x % 10;\n            x /= 10;\n            if (reversed > Integer.MAX_VALUE / 10 || (reversed == Integer.MAX_VALUE / 10 && digit > 7)) return 0;\n            if (reversed < Integer.MIN_VALUE / 10 || (reversed == Integer.MIN_VALUE / 10 && digit < -8)) return 0;\n            reversed = reversed * 10 + digit;\n        }\n        return reversed;       \n    }\n}\n```\n\n## Step by step algorithm\n\n1. **Initialize a boolean variable to track negativity**:\n    ```python\n    is_negative = False\n    ```\n    - We initialize a boolean variable `is_negative` to keep track of whether the input integer `x` is negative.\n\n2. **Check if the input number `x` is negative**:\n    ```python\n    if x < 0:\n        is_negative = True\n        x *= -1\n    ```\n    - If the input integer `x` is negative, we set `is_negative` to `True` and make `x` positive by multiplying it by -1.\n\n3. **Reverse the digits of the integer**:\n    ```python\n    res = 0\n    while x > 0:\n        res = (res * 10) + (x % 10)\n        x //= 10\n    ```\n    - We initialize a variable `res` to store the reversed integer.\n    - Inside the `while` loop, we repeatedly extract the last digit of `x` using the modulo operator `%`, add it to the current value of `res` multiplied by 10, and then update `x` by removing its last digit using integer division `//`.\n\n4. **Check for integer overflow**:\n    ```python\n    if res > 2 ** 31 - 1:\n        return 0\n    ```\n    - We check if the reversed integer `res` exceeds the range of a 32-bit signed integer. If it does, we return 0 to indicate integer overflow.\n\n5. **Return the reversed integer**:\n    ```python\n    return res * -1 if is_negative else res\n    ```\n    - If the original input integer `x` was negative, we return the reversed integer with a negative sign. Otherwise, we return the reversed integer as is.\n\nThe code efficiently reverses the digits of the given integer while handling negative numbers and checking for integer overflow. It demonstrates a concise approach to solve the problem.\n\n---\n\nThank you for reading my post. Please upvote it and don\'t forget to subscribe to my channel!\n\n\u2B50\uFE0F Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\n\u2B50\uFE0F Twitter\nhttps://twitter.com/CodingNinjaAZ\n, status: null, voteStatus: 0, voteCount: 34, creationDate: 1710083652, isHidden: null, author: {username: niits, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1698738357.png, reputation: 7282}}}, searchMeta: null}, {id: 1061403, title: Clean pythonic solution, commentCount: 17, topLevelCommentCount: 9, viewCount: 5665, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1912113, content: ```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        retval = int(str(abs(x))[::-1])\n        \n        if(retval.bit_length()>31):\n            return 0\n    \n        if x<0:\n            return -1*retval\n        else:\n            return retval\n```, status: null, voteStatus: 0, voteCount: 24, creationDate: 1613080819, isHidden: null, author: {username: njain07, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/njain07/avatar_1624723576.png, reputation: 51}}}, searchMeta: null}, {id: 488686, title: Python - string slicing - 28 ms (76.88%), 12.6 MB (100.00%), commentCount: 7, topLevelCommentCount: 6, viewCount: 3401, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 926161, content: ```\n# reverse an integer\nclass Solution:\n    def reverse(self, x: int) -> int:\n        result = int(str(x)[::-1]) if x >= 0 else -int(str(x)[1:][::-1])\n\n        if -2**31 <= result <= (2**31)-1:\n            return result\n        else:\n            return 0\n```, status: null, voteStatus: 0, voteCount: 17, creationDate: 1579829699, isHidden: null, author: {username: __alex__, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/__alex__/avatar_1580428792.png, reputation: 23}}}, searchMeta: null}, {id: 1290537, title: Python, Clean solution with suggested assumption, commentCount: 2, topLevelCommentCount: 2, viewCount: 2434, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2277596, content: ```\n    def reverse(self, x: int) -> int:\n        positive = x > 0\n        limits = [214748364, 7 if positive else 8]  # 2**31 // 10 == (2**31 - 1) // 10 == 214748364\n\n        x = abs(x)\n        rev = 0\n\n        while x != 0:\n            pop = x % 10\n            x //= 10\n\n            if rev > limits[0] or (rev == limits[0] and pop > limits[1]):\n                return 0\n\n            rev = rev * 10 + pop\n\n        return rev if positive else -rev\n```, status: null, voteStatus: 0, voteCount: 15, creationDate: 1624383818, isHidden: null, author: {username: MihailP, isActive: true, nameColor: null, activeBadge: {displayName: Jan LeetCoding Challenge, icon: /static/images/badges/dcc-2022-1.png}, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 70}}}, searchMeta: null}, {id: 857688, title: Python. Cool and clean solution., commentCount: 4, topLevelCommentCount: 2, viewCount: 2574, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 1566120, content: \tclass Solution:\n\t\tdef reverse(self, x: int) -> int:\n\t\t\tif x > 0:\n\t\t\t\tans = int(str(x)[:: -1])\n\t\t\t\treturn ans if ans < 2**31 else 0\n\t\t\tans = - int(str(- x)[:: -1])\n\t\t\treturn ans if ans > - 2**31 else 0\n, status: null, voteStatus: 0, voteCount: 13, creationDate: 1600696654, isHidden: null, author: {username: m-d-f, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 1207}}}, searchMeta: null}, {id: 3642573, title: PYTHON SOLUTION, commentCount: 2, topLevelCommentCount: 2, viewCount: 4797, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5576566, content: # Intuition\nEasy solution in python\n\n# Code\n```\nMIN=-2**31\nMAX=(2**31)-1\nclass Solution:\n    def __init__(self):\n        self.rev=0\n        self.is_neg=False\n    def reverse(self, x: int) -> int:\n        if x < 0:\n            self.is_neg=True\n            x=abs(x)\n        while(x!=0):\n            digit=x%10\n            x=x//10\n\n            if self.rev > MAX//10 or (self.rev==MAX//10 and digit>MAX%10):\n                return 0\n            if self.rev<MIN//10 or (self.rev==MIN//10 and digit <MIN%10):\n                return 0\n            \n            self.rev=10*self.rev+digit\n        if self.is_neg:\n            self.rev=-self.rev\n        return self.rev\n        \n```\n\n\n![upvote.jpg](https://assets.leetcode.com/users/images/f2b20535-89a4-4005-acb6-e9ba67f53399_1686849752.7148187.jpeg)\n, status: null, voteStatus: 0, voteCount: 12, creationDate: 1686849843, isHidden: null, author: {username: bhatganeshdarshan10, isActive: true, nameColor: null, activeBadge: {displayName: Nov LeetCoding Challenge, icon: /static/images/badges/dcc-2023-11.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1684812887.png, reputation: 135}}}, searchMeta: null}, {id: 3227561, title: Simple 2 liner in Python, commentCount: 1, topLevelCommentCount: 1, viewCount: 4357, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5044790, content: # Code\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        ans = int(str(abs(x))[::-1]) * (-1 if x < 0 else 1)\n        return ans if -2**31 <= ans < 2**31 else 0\n```, status: null, voteStatus: 0, voteCount: 11, creationDate: 1677305112, isHidden: null, author: {username: Zhongli4869, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1661858583.png, reputation: 709}}}, searchMeta: null}, {id: 895338, title: Easy Python3 Solution w/ Runtime: 16 ms, faster than 99.94%; MemU: 14.2 MB, less than 99.98%, commentCount: 3, topLevelCommentCount: 1, viewCount: 2037, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1631225, content: ```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        rev = int(str(abs(x))[::-1])\n        i = -rev if x < 0 else rev\n        if i < -2**31 or i > 2**31-1:\n            return 0\n        return i\n```, status: null, voteStatus: 0, voteCount: 10, creationDate: 1602746610, isHidden: null, author: {username: gabrielpetrov99, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 10}}}, searchMeta: null}, {id: 4818716, title: [VIDEO] Step-by-Step Visualization - Checking for Overflow, commentCount: 0, topLevelCommentCount: 0, viewCount: 1110, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 7105110, content: https://youtu.be/YCxDTkWqcxw\n\nStep 1: Extract the digit in the ones place of `x` by using the modulo operator and store it in `digit`\n\nStep 2: Add that digit to `reverse` as the rightmost digit\n\nStep 3: Remove the ones digit from `x` and continue until `x` equals 0.\n\nIn Python, the modulo operator works slightly differently than other languages (such as Java or C) when it comes to negative numbers.  Basically, you will get weird results if you try to do [positive number] mod [negative number].  If you want the modulo to behave the same way with negative numbers as it does with positive numbers, but just have the result be negative, then you need to make sure the divisor is also negative, since the modulo operation will always return a number with the same sign as the divisor.\n\nLastly, I use `math.trunc` instead of just using floor division `//` because of negative numbers.  When dividing `x` by 10 and truncating the decimal, if the number is negative, then it would round down <i>away</i> from zero, when really, we want it to round up <i>towards</i> zero.\n\n# Code\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        MAX_INT = 2 ** 31 - 1 # 2,147,483,647\n        MIN_INT = -2 ** 31    #-2,147,483,648\n        reverse = 0\n\n        while x != 0:\n            if reverse > MAX_INT / 10 or reverse < MIN_INT / 10:\n                return 0\n            digit = x % 10 if x > 0 else x % -10\n            reverse = reverse * 10 + digit\n            x = math.trunc(x / 10)\n\n        return reverse\n\n```, status: null, voteStatus: 0, voteCount: 8, creationDate: 1709502687, isHidden: null, author: {username: AlgoEngine, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1673908639.png, reputation: 5273}}}, searchMeta: null}, {id: 3770118, title: Python 3   ||   5 lines, confession and strings   ||   T/M: 95% / 72%, commentCount: 10, topLevelCommentCount: 4, viewCount: 4788, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5744947, content: **Scoff\u2022law** | \u02C8sk\xF4fl\xF4 | *noun, North American informal* -- A person who flouts the rules, especially by failing to comply with a rule that is difficult to enforce effectively.\n\nMy first take on this problem was that it should be classified as *easy*. I reversed the digits, checked whether it was indeed less than 2^31-1 in absolute value, and submitted the code, which AC\'d with time/memory 98%/100%.\n\nBut I unknowingly was being a scofflaw. The last line of the problem description is:\n- **Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**\n\nI had broken this rule; by applying`int`to the reversed digits, I potentially created a 64-bit integer, which is not allowed.\n\nBelow is my revised code, which I now believe is non-scofflawish. Thanks for allowing me to get that off my chest.\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n\n        mxStr =  \'2147483647\'\n\n        ansLst = reversed(str(abs(x)))\n      \n        ansStr = \'\'.join(ansLst).rjust(10,\'0\')\n\n        if ansStr > mxStr: return 0\n       \n        return int(ansStr)*(1 - 2*(x < 0))\n```\n[https://leetcode.com/problems/reverse-integer/submissions/995246504/](http://)\n\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~ `len(str(x))`.\n\nHere is my scofflaw code:\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n\n        Neg, mxInt = x < 0, 2147483647\n        \n        ansStr = reversed(str(abs(x)))\n\n        ansInt = int(\'\'.join(ansStr))   #  <-- violates the "no 64-bit" rule\n        if ansInt > mxInt: return 0     #  \n            \n        return -ansInt if Neg else ansInt, status: null, voteStatus: 0, voteCount: 7, creationDate: 1689445811, isHidden: null, author: {username: Spaulding_, isActive: true, nameColor: null, activeBadge: {displayName: Algorithm II, icon: https://assets.leetcode.com/static_assets/others/algorithm_II.png}, profile: {userAvatar: https://assets.leetcode.com/users/warrenruud/avatar_1634857511.png, reputation: 6778}}}, searchMeta: null}, {id: 4514753, title: Easy Solution, commentCount: 0, topLevelCommentCount: 0, viewCount: 2576, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 6716321, content: # Code\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        MAX_INT = 2 ** 31 - 1 \n        MIN_INT = -2 ** 31    \n        reverse = 0\n\n        while x != 0:\n            if reverse > MAX_INT / 10 or reverse < MIN_INT / 10:\n                return 0\n            digit = x % 10 if x > 0 else x % -10\n            reverse = reverse * 10 + digit\n            x = math.trunc(x / 10)\n\n        return reverse\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1704504403, isHidden: null, author: {username: mideasy2, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1703472338.png, reputation: 8}}}, searchMeta: null}, {id: 4048544, title: Python || 2 Approaches || 4line code || 99%beat ||| Easy to Understand, commentCount: 2, topLevelCommentCount: 1, viewCount: 2298, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Math, slug: math}, {name: String, slug: string}], post: {id: 6110753, content: **Plz Upvote ..if you got help from this...**\n\n2 Different Approach 99.68 % in both\n\n# Code\n```\n            <!-- 1st Approach String-->\nclass Solution:\n    def reverse(self, x: int) -> int:\n        flag = -1 if x < 0 else 1\n\n        s = str(abs(x))\n        x = int(s[::-1])\n\n        return x*flag if x < 2**31 else 0\n\n<!-- ========================================================= -->\n        <!-- 2nd Approach Python Modulo and Int Division -->\nclass Solution:\n    def reverse(self, x: int) -> int:\n        max_int = pow(2, 31)-1\n        min_int = pow(-2, 31)\n\n        flag = -1 if x < 0 else 1\n        ans = 0\n        x = abs(x)\n\n        while x > 0:\n            digit = x %10\n            if ans > max_int/10:\n                return 0\n            ans = (ans*10) + digit\n            x //=10\n        \n        return ans * flag    \n        \n```\n\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1694796785, isHidden: null, author: {username: vvivekyadav, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1695548140.png, reputation: 489}}}, searchMeta: null}, {id: 2803440, title: Python | Easy Solutionâœ…, commentCount: 5, topLevelCommentCount: 4, viewCount: 7636, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 4486554, content: \n# Code\u2705\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        if x not in range(-9,9):\n            x = int(str(x)[::-1].lstrip(\'0\')) if x >= 0 else int(f"-{str(x)[:0:-1]}".lstrip(\'0\'))\n        return x if (x < 2**31-1 and x > -2**31) else 0\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1668169711, isHidden: null, author: {username: gmanayath, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1671114329.png, reputation: 928}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 569, solutions: [{id: 798380, title: Fast and simpler DFA approach (Python 3), commentCount: 33, topLevelCommentCount: 28, viewCount: 27973, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1462220, content: A fast and (probably) **much simpler and easier to understand DFA solution** than the others when you search for the keyword `DFA`:\n\n```python\nclass Solution:\n    def myAtoi(self, str: str) -> int:\n        value, state, pos, sign = 0, 0, 0, 1\n\n        if len(str) == 0:\n            return 0\n\n        while pos < len(str):\n            current_char = str[pos]\n            if state == 0:\n                if current_char == " ":\n                    state = 0\n                elif current_char == "+" or current_char == "-":\n                    state = 1\n                    sign = 1 if current_char == "+" else -1\n                elif current_char.isdigit():\n                    state = 2\n                    value = value * 10 + int(current_char)\n                else:\n                    return 0\n            elif state == 1:\n                if current_char.isdigit():\n                    state = 2\n                    value = value * 10 + int(current_char)\n                else:\n                    return 0\n            elif state == 2:\n                if current_char.isdigit():\n                    state = 2\n                    value = value * 10 + int(current_char)\n                else:\n                    break\n            else:\n                return 0\n            pos += 1\n\n        value = sign * value\n        value = min(value, 2 ** 31 - 1)\n        value = max(-(2 ** 31), value)\n\n        return value\n```\n\nDFA, which stands for Deterministic finite automaton, is a state machine that either accepts or rejects a sequence of symbols by running through a state sequence uniquely determined by the string. The DFA I used to implement this answer is very simple:\n\n![image](https://assets.leetcode.com/users/images/519c4035-9a46-4dbe-a921-08920282029b_1597736931.5275571.png)\n\n, status: null, voteStatus: 0, voteCount: 316, creationDate: 1597736949, isHidden: null, author: {username: spencerwoo, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/spencerwooo/avatar_1594175283.png, reputation: 320}}}, searchMeta: null}, {id: 1688546, title: âœ”ï¸ [Python3] 5 LINES (FASTER 100%) (â˜ Õžà¨Š Õž)â˜, Explained, commentCount: 12, topLevelCommentCount: 6, viewCount: 4548, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 2909870, content: **UPVOTE if you like (\uD83C\uDF38\u25E0\u203F\u25E0), If you have any question, feel free to ask.**\n\nJust do it in 4 simple steps:\n\n- Iterate over the string until all leading white spaces are exhausted.\n- Check whether the next character is a sign. For `"+"` we assign `+1` to a variable `sign`, and `-1` otherwise.\n- Iterate the next characters and accumulate our integer in `res` until the first non-digital symbol is met.\n- Convert the string `res` into an integer, multiply by `sign` and clamp the result: `max(-2e31, min(2e31-1, result))`.\n\nTime: **O(N)** - for scan\nSpace: **O(1)** - nothing is strored\n\nRuntime: 16 ms, faster than **99.99%** of Python3 online submissions for String to Integer (atoi).\nMemory Usage: 14.1 MB, less than **94.32%** of Python3 online submissions for String to Integer (atoi).\n\n```\n    def myAtoi(self, s: str) -> int:\n        length, i, sign, res = len(s), 0, +1, \'\'\n        \n        while i < length and s[i] == \' \': i = i + 1\n            \n        if i < length and s[i] in (\'-\', \'+\'): \n\t\t\tsign, i = -1 if s[i] == \'-\' else +1, i + 1\n            \n        while i < length and s[i].isdigit(): \n\t\t\tres, i = res + s[i], i + 1\n        \n        return max( -2**31, min( sign * int(res or 0), 2**31 - 1 ) )\n```\n\n**UPVOTE if you like (\uD83C\uDF38\u25E0\u203F\u25E0), If you have any question, feel free to ask.**, status: null, voteStatus: 0, voteCount: 36, creationDate: 1642122341, isHidden: null, author: {username: artod, isActive: true, nameColor: null, activeBadge: {displayName: Jan LeetCoding Challenge, icon: /static/images/badges/dcc-2022-1.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1641775737.png, reputation: 7598}}}, searchMeta: null}, {id: 425289, title: Python 99.89% (no cheating by using int()), commentCount: 6, topLevelCommentCount: 4, viewCount: 6966, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 811311, content: ```\nMAPPING = {\n    "1": 1,\n    "2": 2,\n    "3": 3,\n    "4": 4,\n    "5": 5,\n    "6": 6,\n    "7": 7,\n    "8": 8,\n    "9": 9,\n    "0": 0,\n}\n\nMAX_INT = 2**31-1\nMIN_INT = -(2**31)\n\nclass Solution:\n    def myAtoi(self, string: str) -> int:\n        s = string.lstrip(\' \')\n        if not s:\n            return 0\n        \n        sign = -1 if s[0] == "-" else 1\n        if sign != 1 or s[0] == "+":\n            s = s[1:]\n            \n        res = 0\n        for c in s:\n            if c not in MAPPING:\n                return self.limit(res * sign)\n            \n            res *= 10\n            res += MAPPING[c]\n            \n        return self.limit(res * sign)\n    \n    def limit(self, x: int) -> int:\n        if x > MAX_INT:\n            return MAX_INT\n        if x < MIN_INT:\n            return MIN_INT\n        return x\n```, status: null, voteStatus: 0, voteCount: 26, creationDate: 1573364458, isHidden: null, author: {username: roganartu, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 26}}}, searchMeta: null}, {id: 748024, title: Python3 solution with a Process for coding interviews, commentCount: 2, topLevelCommentCount: 1, viewCount: 3660, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1376612, content: Hello,\n\nHere is my solution with a process to follow during a coding interview:\n\n1.  Problem Summary / Clarifications / TDD:\n\t\t- Q1. What if there is a space between the sign and the number? (see cases 5 and 6)\n\t\t- Q2. What if the result is not an int. Python manages overflow issues. See case 12 and 14.  \n\t\t\n        Case.01. myAtoi("           ") = 0          (a non valid number with spaces only)\n        Case.02. myAtoi("words      ") = 0          (a non valid number only)\n        Case.03. myAtoi("words12365 ") = 0          (a non valid number is followed by a valid number I)\n        Case.04. myAtoi("words 1236 ") = 0          (a non valid number is followed by a valid number II)\n        Case.05. myAtoi("+ 4193"     ) = 0          (a non valid number: space between sign and number I)\n        Case.06. myAtoi("- 4193    " ) = 0          (a non valid number: space between sign and number II)\n        \n        Case.07. myAtoi("4193"       ) = 4193       (a valid number only)\n        Case.08. myAtoi("4193word"   ) = 4193       (a valid number is followed by a non valid number I)\n        Case.09. myAtoi("4193 word"  ) = 4193       (a valid number is followed by a non valid number II)\n        Case.10. myAtoi("4193 12 wo" ) = 4193       (a valid number is followed by a another valid number)\n        Case.11. myAtoi("+4193"      ) = 4193       (a positive valid number with the sign +)\n        Case.12. myAtoi("+2147483648") = 2147483647 (a positive number greater than int max value)\n        Case.13. myAtoi("-4193"      ) = -4193      (a negatve valid number with the sign -)\n        Case.14. myAtoi("-2147483649") = -2147483648(a negative number less than int min value)\n        \n2.  Intuition:\n        1. Extract the number (str_num) from s\n        2. Extract the sign from str_num\n        3. Loop each digit of str_num and compute the conversion in num\n        4. Break when a non digit char is found or num reach max/min int\n        5. Return num * sign\n        \n3. Implementation: see below\n4. Tests: Use all tests created in step 1 (TDD)\n5. Analysis:\n\t- Time Complexity: O(|s|)\n\t- Space Complexity: O(|s|)\n\t- Could we do better?\n\t\t-  Time Complexity:  We can\'t in term of asymptotique analysis but if we don\'t use the split function and `break` as soon as a non valid digit is found, the code may be faster\n\t\t- Space Complexity:  Yes, we could make it O(1) if we don\'t use the split function and we loop on each character of s \n\n```\nclass Solution:\n    \n    def myAtoi(self, s: str) -> int:\n        str_list = s.split()\n        \n        if not str_list:\n            return 0\n                \n        num_str = str_list[0]\n        sign = -1 if num_str[0] == \'-\' else +1\n        start = 1 if num_str[0] in \'-+\' else 0\n        \n        num = 0\n\t\tint_boundary =  0x80000000 if sign == -1 else 0x7fffffff # 2147483648 or 2147483647\n        \n        for i in range(start, len(num_str)):\n            \n\t\t\tord_digit = ord(num_str[i])\n            if ord_digit < 48 or ord_digit > 57:\n                break\n            \n            num *= 10\n            num += ord_digit - 48\n            \n            if num >= int_boundary:\n                num = int_boundary\n                break\n        \n        return num * sign\n\t\t\n```, status: null, voteStatus: 0, voteCount: 18, creationDate: 1595360825, isHidden: null, author: {username: O_Leet_Code, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/hamidgasmi/avatar_1554615785.png, reputation: 735}}}, searchMeta: null}, {id: 1510014, title: Python Simple Solution without Strip beats 95%, commentCount: 4, topLevelCommentCount: 2, viewCount: 1855, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2622578, content: ```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n     \n        if not s:\n            return 0\n        sign = 1\n        integer = 0\n        i = 0\n        while i < len(s) and s[i] == \' \':\n            i+=1    #skipping leading white space\n        if i < len(s) and (s[i] == \'-\' or s[i] == \'+\'):\n            if s[i] == \'-\':\n                sign = -1\n            i+=1\n        while(i < len(s) and s[i].isdigit()):\n            integer = integer * 10 + int(s[i])\n            i+=1\n            \n        integer = sign*integer\n        ans = self.limit(integer)\n        return ans\n    \n    def limit(self, num):\n        if num > pow(2, 31) -1:\n            return pow(2, 31) -1\n        if num < -1*pow(2, 31):\n            return -1*pow(2, 31)\n        return num\n```\nRuntime: 28 ms, faster than 95.37% of Python3 online submissions for String to Integer (atoi).\nMemory Usage: 14.1 MB, less than 81.77% of Python3 online submissions for String to Integer (atoi).\n\n![image](https://assets.leetcode.com/users/images/4ac2f1fe-cd40-4f9c-9ae4-77cb2d8ddb08_1633676436.6743143.png)\n\n, status: null, voteStatus: 0, voteCount: 13, creationDate: 1633676452, isHidden: null, author: {username: emerald19, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1649572069.png, reputation: 90}}}, searchMeta: null}, {id: 4704849, title: Simple Solution with Java || Python3 || c++ || c#ðŸ˜Š, commentCount: 5, topLevelCommentCount: 5, viewCount: 4240, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: C#, slug: csharp}], post: {id: 6958130, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe goal is to convert a given string to an integer, considering leading whitespaces, signs, and possible overflow conditions. The approach involves iterating through the characters of the string, handling sign, and converting digits to an integer. We need to be cautious about overflow conditions and return the appropriate result.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n1. Trim the input string to remove leading and trailing whitespaces.\n2. Initialize variables `i` (iterator), `num` (resulting integer), and `sign` (to handle positive or negative numbers).\n3. Check for the sign at the beginning of the string. If present, update the sign and move the iterator.\n4. Iterate through the remaining characters, converting each digit to an integer and updating the result.\n5. Check for overflow conditions during the conversion and return the result accordingly.\n\n# Complexity\n- Time complexity: ***O(n)***\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: ***O(1)***\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```java []\nclass Solution {\n    public int myAtoi(String s) {\n        s = s.trim();\n        if (s.length() == 0) {\n            return 0;\n        }\n\n        int i = 0;\n        long num = 0;\n        int sign = 1;\n\n        // Check for sign\n        if (s.charAt(i) == \'+\' || s.charAt(i) == \'-\') {\n            sign = (s.charAt(i++) == \'-\') ? -1 : 1;\n        }\n\n        // Process digits\n        while (i < s.length() && Character.isDigit(s.charAt(i))) {\n            int digit = s.charAt(i++) - \'0\';\n\n            // Check for overflow\n            if (num > (Integer.MAX_VALUE - digit) / 10) {\n                return (sign == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            }\n\n            num = num * 10 + digit;\n        }\n\n        return (int) (sign * num);\n    }\n}\n\n```\n```c++ []\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        s.erase(0, s.find_first_not_of(\' \'));\n        if (s.empty()) return 0;\n\n        int i = 0, num = 0, sign = 1;\n\n        if (s[0] == \'+\' || s[0] == \'-\') {\n            sign = (s[0] == \'-\') ? -1 : 1;\n            i++;\n        }\n\n        while (i < s.length() && isdigit(s[i])) {\n            int digit = s[i] - \'0\';\n            if (num > (INT_MAX - digit) / 10) {\n                return (sign == 1) ? INT_MAX : INT_MIN;\n            }\n            num = num * 10 + digit;\n            i++;\n        }\n\n        return sign * num;\n    }\n};\n```\n```python3 []\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        if not s:\n            return 0\n\n        i, num, sign = 0, 0, 1\n\n        if s[0] == \'+\' or s[0] == \'-\':\n            sign = -1 if s[0] == \'-\' else 1\n            i += 1\n\n        while i < len(s) and s[i].isdigit():\n            digit = int(s[i])\n            if num > (2**31 - 1 - digit) // 10:\n                return 2**31 - 1 if sign == 1 else -2**31\n            num = num * 10 + digit\n            i += 1\n\n        return sign * num\n```\n```c# []\npublic class Solution {\n    public int MyAtoi(string s) {\n        s = s.Trim();\n        if (string.IsNullOrEmpty(s)) {\n            return 0;\n        }\n\n        int i = 0, num = 0, sign = 1;\n\n        if (s[0] == \'+\' || s[0] == \'-\') {\n            sign = (s[0] == \'-\') ? -1 : 1;\n            i++;\n        }\n\n        while (i < s.Length && Char.IsDigit(s[i])) {\n            int digit = s[i] - \'0\';\n            if (num > (Int32.MaxValue - digit) / 10) {\n                return (sign == 1) ? Int32.MaxValue : Int32.MinValue;\n            }\n            num = num * 10 + digit;\n            i++;\n        }\n\n        return sign * num;\n    }\n}\n```, status: null, voteStatus: 0, voteCount: 10, creationDate: 1707547464, isHidden: null, author: {username: sagarsindhu36, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2024, icon: https://assets.leetcode.com/static_assets/marketing/2024-50-lg.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1704865240.png, reputation: 440}}}, searchMeta: null}, {id: 3110465, title: Python3 Fast Code and Simple, commentCount: 0, topLevelCommentCount: 0, viewCount: 2564, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 4891868, content: \n# Approach\n<!-- Describe your approach to solving the problem. -->\n**iterative**\n\n# Complexity\n- Time complexity: O(n)\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity:O(1)\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s=s.lstrip()\n        sign,res,i=1,0,0\n        if i < len(s) and (s[i] == \'-\' or s[i] == \'+\'):\n            if s[i] == \'-\':\n                sign = -1\n            i += 1\n        while i < len(s) and s[i].isdigit():\n            res = res * 10 + int(s[i])\n            i += 1\n        res = max(min(res * sign, 2**31 - 1), -2**31)\n        return res\n```, status: null, voteStatus: 0, voteCount: 8, creationDate: 1674929322, isHidden: null, author: {username: manoharmj2338, isActive: true, nameColor: null, activeBadge: {displayName: Binary Search I, icon: https://assets.leetcode.com/static_assets/others/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE_%E5%85%A5%E9%97%A8.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1677046179.png, reputation: 24}}}, searchMeta: null}, {id: 787459, title: Python Solution | 28ms | Faster than 95.80%, commentCount: 1, topLevelCommentCount: 1, viewCount: 1757, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1443257, content: ```python\nclass Solution:\n    def myAtoi(self, s):\n        maxii = 2147483647                         # define the maximum limit\n        minii = -2147483648                        # define minimum limit\n        s = s.strip()                              # Remove all whitespaces\n        if not s:\n            return 0\n        sign, idx = 1, 0                                  # sign set to 1 -> Positive, index set to 0\n        if s[idx]==\'+\':                                   # check if the first character is a \'+\'\n            idx+=1                                        # if so, move index to next character\n        elif s[idx]==\'-\':                                 # check if first character is \'-\'\n            sign = -1                                     # change status of sign to be a negative number\n            idx+=1                                        # update the index\n        num = 0\n        n = len(s)\n        while idx<n:\n            if not s[idx].isdigit():            # if the number is not a digit, then stop\n                break\n            num = num*10 + ord(s[idx])-ord(\'0\') # else move the units, tenths, hundredth... places by multiplying the number by 10 and add the unicode integer\n            if num>maxii:\n                break\n            idx+=1\n        return min(max(sign*num, minii), maxii) # return answer if its within the maximum and minimum range\n```, status: null, voteStatus: 0, voteCount: 7, creationDate: 1597227391, isHidden: null, author: {username: k-g-prajwal, isActive: true, nameColor: null, activeBadge: {displayName: Jan LeetCoding Challenge, icon: /static/images/badges/dcc-2022-1.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1674390439.png, reputation: 26}}}, searchMeta: null}, {id: 4899280, title: ðŸ”¥Beats 100%ðŸ”¥âœ…Easiest (C++/Java/Python) Solution With Detailed Explanationâœ…, commentCount: 0, topLevelCommentCount: 0, viewCount: 2101, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: String, slug: string}], post: {id: 7212266, content: # Intuition\nThe C++ function `myAtoi` converts a string to an integer by ignoring leading whitespaces, considering an optional sign, accumulating digits until a non-digit is encountered, and handling overflows by clamping the result to the limits of a 32-bit signed integer.\n\n![Screenshot 2024-03-20 075007.png](https://assets.leetcode.com/users/images/a0151180-e322-48b4-b31a-199247baea0b_1710901543.5116532.png)\n\n\n# Approach\n\n1. **Initialization**: The function begins by initializing several variables:\n   - `n`: The size of the string.\n   - `res`: A double used to accumulate the result. This choice allows handling potential overflow situations more gracefully, as it has a wider range than an `int`.\n   - Flags `dig` (digit found), `posi` (positive sign found), `neg` (negative sign found), and `other` (any other character found) to track the state of parsing.\n\n2. **Whitespace Skipping**: The function starts with a while loop to skip any leading whitespace characters in the input string.\n\n3. **Parsing**: The function then enters a for loop to parse the rest of the string:\n   - If a digit is encountered (`\'0\'` through `\'9\'`), it multiplies the current `res` by 10 (shifting it one decimal place to the left) and adds the numerical value of the current digit.\n   - If a non-digit character is encountered before any digit, the function checks for `\'+\'` and `\'-\'`. It sets the respective flag if found and only if no other sign has been processed. Any other character leads to setting the `other` flag, indicating an invalid input, and breaking the loop.\n   - If digits have been encountered (`dig` is true) and the function then encounters a non-digit character, it breaks out of the loop as it has reached the end of the numeric part of the string.\n\n4. **Post-Parsing Checks**: After the loop, the function checks for invalid states:\n   - If both `posi` and `neg` flags are true, it means the input is invalid (both signs were found), so it returns 0.\n   - If the `neg` flag is true, it negates `res` to make the number negative.\n\n5. **Overflow Handling**: Before returning, the function checks if `res` exceeds the range of a 32-bit signed integer (`INT_MAX` and `INT_MIN`) and clamps the value accordingly.\n\n6. **Return**: Finally, it casts `res` to an `int` and returns it.\n\n## Complexity Analysis\n\n- **Time Complexity**: The function iterates over each character of the string exactly once. Therefore, the time complexity is **O(n)**, where **n** is the length of the input string.\n\n- **Space Complexity**: The space complexity is **O(1)**. Regardless of the input size, the function uses a constant amount of space for its variables (`n`, `res`, the flags, and a few others for control flow).\n\n\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int n = s.size();\n        double res = 0;\n        bool dig = false;\n        bool posi = false;\n        bool neg = false;\n        bool other = false;\n\n        int i = 0;\n        while (i < n && s[i] == \' \')\n            i++;\n\n        for (; i < n; i++) {\n            if (other)\n                break;\n            \n            if (s[i] >= \'0\' && s[i] <= \'9\') {\n                res = (res * 10) + (s[i] - \'0\');\n                dig = true;\n            } else {\n                if (dig)\n                    break;\n\n                else if (s[i] == \'-\' && !neg)\n                    neg = true;\n\n                else if (s[i] == \'+\' && !posi)\n                    posi = true;\n\n                else\n                    other = true;\n            }\n        }\n\n        if (posi && neg)\n            return 0;\n\n        if (neg)\n            res = -res;\n\n        if (res > INT_MAX)\n            return INT_MAX;\n\n        if (res < INT_MIN)\n            return INT_MIN;\n\n        return (int)res;\n    }\n};\n```\n```Java []\nclass Solution {\n    public int myAtoi(String s) {\n        double res = 0;\n        boolean dig = false;\n        boolean pos = false;\n        boolean neg = false;\n        boolean other = false;\n        int n = s.length();\n        int i = 0;\n        while (i<n && s.charAt(i)==\' \')\n            i++;\n        for (; i<n; i++)\n        {\n            if (other)\n                break;\n\n            char S = s.charAt(i);\n            if (S>=\'0\' && S<=\'9\')\n            {\n                res = res*10 + (S-\'0\');\n                dig = true;\n            }\n            else\n            {\n                if (dig)\n                    break;\n\n                else if (S==\'-\' && !neg)\n                    neg = true;\n\n                else if (S==\'+\' && !pos)\n                    pos = true;\n                \n                else\n                    other = true;\n            }\n        }\n        if (pos && neg)\n            return 0;\n\n        if (neg)\n            res = -res;\n\n        if (res < Integer.MIN_VALUE)\n            return Integer.MIN_VALUE;\n        \n        if (res > Integer.MAX_VALUE)\n            return Integer.MAX_VALUE;\n\n        return (int)res;\n    }\n}\n```\n```Python []\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        n = len(s)\n        res = 0\n        dig = False\n        posi = False\n        neg = False\n        other = False\n        \n        i = 0\n        while i < n and s[i] == \' \':\n            i += 1\n            \n        for j in range(i, n):\n            if other:\n                break\n                \n            if \'0\' <= s[j] <= \'9\':\n                res = (res * 10) + (ord(s[j]) - ord(\'0\'))\n                dig = True\n            else:\n                if dig:\n                    break\n                \n                elif s[j] == \'-\' and not neg:\n                    neg = True\n                    \n                elif s[j] == \'+\' and not posi:\n                    posi = True\n                    \n                else:\n                    other = True\n                    \n        if posi and neg:\n            return 0\n        \n        if neg:\n            res = -res\n            \n        if res > 2**31 - 1:\n            return 2**31 - 1\n        \n        if res < -2**31:\n            return -2**31\n        \n        return int(res)\n\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1710901551, isHidden: null, author: {username: suyogshete04, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1705026521.png, reputation: 224}}}, searchMeta: null}, {id: 3264380, title: Python Easy Solution, commentCount: 4, topLevelCommentCount: 4, viewCount: 6154, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 5091718, content: ```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        su,num,flag = 1,0,0\n        s = s.strip()\n        if len(s) == 0: return 0\n        if s[0] == "-":\n            su = -1\n        for i in s:\n            if i.isdigit():\n                num = num*10 + int(i)\n                flag = 1\n            elif (i == "+" or i == "-") and (flag == 0):\n                flag = 1\n                pass\n            else: break\n        num = num*su\n        if (-2**31<=num<=(2**31)-1): return num\n        if num<0: return -2**31\n        else: return 2**31-1, status: null, voteStatus: 0, voteCount: 6, creationDate: 1678105918, isHidden: null, author: {username: Debasish365, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1686310255.png, reputation: 62}}}, searchMeta: null}, {id: 2716487, title: Python Very Intuitive with Comments, commentCount: 0, topLevelCommentCount: 0, viewCount: 3009, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 4369360, content: ```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        if not s:\n            return 0\n\n        # remove leading and trailing whitespace\n        s = s.strip()\n\n        # save sign if one exists\n        pos = True\n        if s and s[0] == \'-\':\n            pos = False\n            s = s[1:]\n        elif s and s[0] == \'+\':\n            s = s[1:]\n        \n        # ignore leading zeros\n        i = 0\n        while i < len(s) and s[i] == \'0\':\n            i += 1\n\n        # apply relevant digits\n        res = None\n        while i < len(s) and s[i] in \'0123456789\':\n            if res is None:\n                res = int(s[i])\n            else:\n                res = (res * 10) + int(s[i])\n            i += 1\n        res = 0 if res is None else res\n\n        # apply sign\n        res = res if pos else -res\n\n        # clip result\n        res = max(res, -2**31)\n        res = min(res, (2**31)-1)\n\n        return res\n\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1666064369, isHidden: null, author: {username: jonathanbrophy47, isActive: true, nameColor: null, activeBadge: {displayName: Level 3, icon: https://assets.leetcode.com/static_assets/others/%E4%BC%9A%E5%91%98.png}, profile: {userAvatar: https://assets.leetcode.com/users/jonathanbrophy47/avatar_1581814689.png, reputation: 14}}}, searchMeta: null}, {id: 943508, title: Python Simple Solution with clear explanation, commentCount: 1, topLevelCommentCount: 1, viewCount: 1077, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 1715553, content: Because the input will contain whitespaces, we strip the string `s = s.strip()` so we don\'t need to deal with whitespaces inside the string `s`.\n\nThe conditions we need to satisfy in this problem are,\n* `s[0]` must be a digit or a sign `+/-` \n* s contains only digit, an exceptional for sign `+/-` in the beginning of the string\n* the answer is an integer, so need to be  `-2^31 <= int number <= (2^31)-1`\n\nIf the input string doesn\'t satisfy the forementioned conditions, then `return 0`. Otherwise, return the int number.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        if len(s) == 0 or (len(s) > 0 and not (s[0] in [\'+\',\'-\'] or s[0].isdigit())):\n            return 0\n\n        value = 0\n        sign = -1 if s[0] == \'-\' else 1\n        i = 1 if not s[0].isdigit() else 0\n\n        while i < len(s) and s[i].isdigit():\n            value = (value * 10) + (ord(s[i]) - ord(\'0\'))\n            i += 1\n        value *= sign\n\n        if value < -(2**31):\n            return -(2**31)\n        elif value > (2**31)-1:\n            return (2**31)-1\n\n        return value        \n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1605942902, isHidden: null, author: {username: iamtheluckiestsyn, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/syennyw98/avatar_1550282420.png, reputation: 34}}}, searchMeta: null}, {id: 857817, title: Python. A beautiful solution. faster than 98.72% of Python3, commentCount: 0, topLevelCommentCount: 0, viewCount: 1122, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 1566317, content: \tclass Solution:\n\t\tdef myAtoi(self, string: str) -> int:\n\t\t\tstripped = string.strip()\n\t\t\tsign = 1\n\t\t\t\n\t\t\tif not stripped:\n\t\t\t\treturn 0       \n\t\n\t\t\telif stripped[0] in ("+", "-"): \n\t\t\t\tif stripped[0] == "-":\n\t\t\t\t\tsign = -1\n\t\t\t\tstripped = stripped[1:]\n\t\t\telif not stripped[0].isdigit():\n\t\t\t\treturn 0\n\t\t\t\n\t\t\tif not stripped:\n\t\t\t\treturn 0\n\t\t\ttry:\n\t\t\t\tans = int(stripped[0])\n\t\t\t\tstripped = stripped[1:]\n\t\n\t\t\t\tfor c in stripped:\n\t\t\t\t\tif c.isdigit():\n\t\t\t\t\t\tans = ans * 10 + int(c)\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak    \n\t\n\t\t\t\tif sign == 1:\n\t\t\t\t\treturn sign * ans if ans < 2**31 else 2147483647\n\t\t\t\treturn -ans if ans <= 2**31 else -2147483648\n\t\t\texcept:\n\t\t\t\treturn 0\n, status: null, voteStatus: 0, voteCount: 6, creationDate: 1600702607, isHidden: null, author: {username: m-d-f, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 1207}}}, searchMeta: null}, {id: 3966089, title: Beats 93.02%in runtime (36ms), commentCount: 1, topLevelCommentCount: 1, viewCount: 940, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 6001800, content: \n![image.png](https://assets.leetcode.com/users/images/bb1aafb2-cd57-4b39-a7ed-f89f8d77928f_1693120652.7405164.png)\n\n# Code\n```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.lstrip()\n        if len(s) == 0:\n            return 0\n        if s[0] == \'-\' or s[0] == \'+\':\n            sign = -1 if s[0] == \'-\' else 1\n            s = s[1:]\n        else:\n            sign = 1\n        digits = []\n        for c in s:\n            if c.isdigit():\n                digits.append(c)\n            else:\n                break\n        if len(digits) == 0:\n            return 0\n        else:\n            num = int(\'\'.join(digits))\n            num *= sign\n        num = max(num, -2**31)\n        num = min(num, 2**31 - 1)\n        return num\n```, status: null, voteStatus: 0, voteCount: 5, creationDate: 1693120675, isHidden: null, author: {username: ayan_101, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1703143471.png, reputation: 229}}}, searchMeta: null}, {id: 3501521, title: Beats : 90.02% [42/145 Top Interview Question], commentCount: 7, topLevelCommentCount: 2, viewCount: 4552, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5392245, content: # Intuition\n*Paper and pen and try to figure out all the possible edge cases, The question was easy, but the question explanation was poor.No need to worry about the **least acceptance rate** that the question has.*\n\n# Approach\nThis code defines a class called Solution with a method named `myAtoi` which takes a string `s` as input and returns an integer as output. The method has some considerations which are mentioned in its docstring ***`(please do read)`***. The method performs the following steps:\n\n1. Define two constants `maxInt` and `minInt` as the maximum and minimum integer values that can be represented using 32 bits.\n\n2. Initialize the integer variables `result`, `startIdx`, and `sign` to 0, 0, and 1, respectively. \n\n3. Remove any leading whitespace characters from the input string `s` using the `lstrip()` method and store it in a variable called `cleanStr`. If `cleanStr` is an empty string, return `result`.\n\n4. Check if the first character of `cleanStr` at `startIdx` is either `"+"` or `"-"`. If it is `"-"`, set the `sign` variable to -1, otherwise, leave it as 1. If the first character is a sign, increment `startIdx` by 1.\n\n5. Iterate through the remaining characters in `cleanStr` starting at index `startIdx`. If a non-digit character is encountered, break the loop. If a digit is encountered, add it to the `result` variable by multiplying it by 10 and adding the integer value of the character.\n\n6. Check if the final result multiplied by `sign` is greater than `maxInt`. If it is, return `maxInt`. If it is less than or equal to `minInt`, return `minInt`.\n\n7. If the value is within the range of `maxInt` and `minInt`, return the value multiplied by `sign`.\n\n\n# Complexity\n- Time complexity:\nO(n)\n\n- Space complexity:\n\n(edited)\nO(1) or O(n) // It\'s complicated to wrap around. \n\n`Time complexity`:\n- The method performs a single pass through the input string, which takes `O(n)` time, where `n` is the length of the input string.\n- The string operations such as `lstrip()` and `isdigit()` take constant time per character, so they don\'t affect the overall time complexity of the algorithm.\n- Therefore, the `time complexity` of the method is `O(n)`.\n\n`Space complexity`:\n- The method uses a constant amount of extra space to store integer variables and constants, so the `space complexity` is `O(1)`.\n- The additional space required by the method doesn\'t depend on the input size, so it is considered `constant`.\n\nTherefore, the overall `time complexity` is `O(n)` and the `space complexity` is `O(1)`.\n\n# Code\n```\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        """\n        Considerations:        \n        1. If there is a leading whitespace at start, remove it.\n        2. Check the sign and store it in a varible.\n        3. try adding the digits to the result.\n        4. witnessing anything other than a digit break the loop.\n\t    5. check the range and return accordingly.\n        """\n\n        maxInt, minInt = 2**31 - 1 , -2**31\n        result, startIdx, sign = 0,0,1\n        cleanStr = s.lstrip()\n        \n        if not cleanStr: return result\n\n        if cleanStr[startIdx] in ("-", "+"):\n            sign = -1 if cleanStr[startIdx] == "-" else 1 \n            startIdx += 1\n        \n        for i in range(startIdx, len(cleanStr)):\n            char = cleanStr[i]\n            if not char.isdigit():\n                break\n            else:\n                # read note at the end, if confusing\n                result = (result * 10) + int(char)\n\n        if result * sign > maxInt:\n            return maxInt\n        elif result * sign <= minInt:\n            return minInt\n        \n        return result * sign\n\n"""\nNote: \nQ1.  why int(char)?\nAns: The char will be x, where x is a digit in string format\n\nQ2.  why result * 10?\nAns: We need to shift the current value of result\n     to the left by one decimal place (i.e., multiply it by 10) \n     and then add the integer value of the new digit to the result\n"""\n             \n```, status: null, voteStatus: 0, voteCount: 5, creationDate: 1683564048, isHidden: null, author: {username: rahulbnair, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2024, icon: https://assets.leetcode.com/static_assets/marketing/2024-50-lg.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1681829619.png, reputation: 393}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 2532, solutions: [{id: 3651712, title: âœ…2 Method's || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥, commentCount: 51, topLevelCommentCount: 36, viewCount: 257389, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 5589484, content: # Intuition:\nThe intuition behind this code is to reverse the entire input number and check if the reversed number is equal to the original number. If they are the same, then the number is a palindrome.\n\n# Approach 1: Reversing the Entire Number\n# Explanation:\n1. We begin by performing an initial check. If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\n\n2. We initialize two variables:\n   - `reversed`: This variable will store the reversed value of the number `x`.\n   - `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\n\n3. We enter a loop that continues until `temp` becomes zero:\n   - Inside the loop, we extract the last digit of `temp` using the modulo operator `%` and store it in the `digit` variable.\n   - To reverse the number, we multiply the current value of `reversed` by 10 and add the extracted `digit`.\n   - We then divide `temp` by 10 to remove the last digit and move on to the next iteration.\n\n4. Once the loop is completed, we have reversed the entire number. Now, we compare the reversed value `reversed` with the original input value `x`.\n   - If they are equal, it means the number is a palindrome, so we return `true`.\n   - If they are not equal, it means the number is not a palindrome, so we return `false`.\n\nThe code uses a `long long` data type for the `reversed` variable to handle potential overflow in case of large input numbers.\n\n# Code\n\n```C++ []\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) {\n            return false;\n        }\n\n        long long reversed = 0;\n        long long temp = x;\n\n        while (temp != 0) {\n            int digit = temp % 10;\n            reversed = reversed * 10 + digit;\n            temp /= 10;\n        }\n\n        return (reversed == x);\n    }\n};\n\n```\n```Java []\nclass Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0) {\n            return false;\n        }\n\n        long reversed = 0;\n        long temp = x;\n\n        while (temp != 0) {\n            int digit = (int) (temp % 10);\n            reversed = reversed * 10 + digit;\n            temp /= 10;\n        }\n\n        return (reversed == x);\n    }\n}\n\n```\n```Python3 []\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n\n        reversed_num = 0\n        temp = x\n\n        while temp != 0:\n            digit = temp % 10\n            reversed_num = reversed_num * 10 + digit\n            temp //= 10\n\n        return reversed_num == x\n\n```\n\n# Approach 2: Reversing Half of the Number\nInstead of reversing the entire number, we can reverse only the last half of the number. This approach is tricky because when we reverse the last half of the number, we don\'t want the middle digit to be reversed back to its original value. This can happen if the number has an odd number of digits. To resolve this, we can compare the first half of the number with the reversed second half of the number.\n# Explanation:\n1. We begin with an initial check to handle special cases:\n   - If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\n   - If `x` is non-zero and ends with a zero, it cannot be a palindrome because leading zeros are not allowed in palindromes. We return `false` for such cases.\n\n2. We initialize two variables:\n   - `reversed`: This variable will store the reversed second half of the digits of the number.\n   - `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\n\n3. We enter a loop that continues until the first half of the digits (`x`) becomes less than or equal to the reversed second half (`reversed`):\n   - Inside the loop, we extract the last digit of `x` using the modulo operator `%` and add it to the `reversed` variable after multiplying it by 10 (shifting the existing digits to the left).\n   - We then divide `x` by 10 to remove the last digit and move towards the center of the number.\n\n4. Once the loop is completed, we have reversed the second half of the digits. Now, we compare the first half of the digits (`x`) with the reversed second half (`reversed`) to determine if the number is a palindrome:\n   - For an even number of digits, if `x` is equal to `reversed`, then the number is a palindrome. We return `true`.\n   - For an odd number of digits, if `x` is equal to `reversed / 10` (ignoring the middle digit), then the number is a palindrome. We return `true`.\n   - If none of the above conditions are met, it means the number is not a palindrome, so we return `false`.\n\nThe code avoids the need for reversing the entire number by comparing only the necessary parts. This approach reduces both time complexity and memory usage, resulting in a more efficient solution.\n\n# Code\n\n```C++ []\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n        return (x == reversed) || (x == reversed / 10);\n    }\n};\n```\n```Java []\nclass Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        int original = x;\n\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n\n        return (x == reversed) || (x == reversed / 10);\n    }\n}\n```\n```Python3 []\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x != 0 and x % 10 == 0):\n            return False\n\n        reversed_num = 0\n        original = x\n\n        while x > reversed_num:\n            reversed_num = reversed_num * 10 + x % 10\n            x //= 10\n\n        return x == reversed_num or x == reversed_num // 10\n```\n\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/bc4560f0-64e2-4083-8f14-c5e8220c2e7f_1687078450.4746537.png)\n\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\n\n\n\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\n\n, status: null, voteStatus: 0, voteCount: 1095, creationDate: 1687077671, isHidden: null, author: {username: rahulvarma5297, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1690766901.png, reputation: 34032}}}, searchMeta: null}, {id: 785314, title: Python 3 -> 1 solution is 89.20% faster. 2nd is 99.14% faster. Explanation added, commentCount: 49, topLevelCommentCount: 25, viewCount: 97342, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: String, slug: string}], post: {id: 1439550, content: **Suggestions to make them better are always welcomed.**\n\n**Solution 1: 89.20% faster**\nThis is the easiest way to check if integer is palindrome. \n\nConvert the number to string and compare it with the reversed string.\n\nI wrote this working solution first and then found in the description that we need to solve this problem without converting the input to string. Then I wrote solution 2.\n```\ndef isPalindrome(self, x: int) -> bool:\n\tif x < 0:\n\t\treturn False\n\t\n\treturn str(x) == str(x)[::-1]\n```\n\nIf we don\'t want to convert the number to string, then recreate a new number in reverse order.\n```\ndef isPalindrome(self, x: int) -> bool:\n\tif x<0:\n\t\treturn False\n\n\tinputNum = x\n\tnewNum = 0\n\twhile x>0:\n\t\tnewNum = newNum * 10 + x%10\n\t\tx = x//10\n\treturn newNum == inputNum\n```\n\n**Solution 2: 99.14% faster.**\nI\'d recommend you to solve leetcode question 7 (reverse integer) to understand the logic behind this solution.\n\nPython3 int type has no lower or upper bounds. But if there are constraints given then we have to make sure that while reversing the integer we don\'t cross those constraints.\n\nSo, instead of reversing the whole integer, let\'s convert half of the integer and then check if it\'s palindrome.\nBut we don\'t know when is that half going to come. \n\nExample, if x = 15951, then let\'s create reverse of x in loop. Initially, x = 15951, revX = 0\n1. x = 1595, revX = 1\n2. x = 159, revX = 15\n3. x = 15, revX = 159\n\nWe see that revX > x after  3 loops and we crossed the half way in the integer bcoz it\'s an odd length integer.\nIf it\'s an even length integer, our loop stops exactly in the middle.\n\nNow we can compare x and revX, if even length, or x and revX//10 if odd length and return True if they match.\n\nThere\'s a difference between / and // division in Python3. Read it here on [stackoverflow](https://stackoverflow.com/questions/183853/what-is-the-difference-between-and-when-used-for-division).\n```\ndef isPalindrome(self, x: int) -> bool:\n\tif x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\n\t\treturn False\n\t\n\tresult = 0\n\twhile x > result:\n\t\tresult = result * 10 + x % 10\n\t\tx = x // 10\n\t\t\n\treturn True if (x == result or x == result // 10) else False\n```\n\n **If you like the solutions, please upvote it for better reach to other people.**, status: null, voteStatus: 0, voteCount: 688, creationDate: 1597128251, isHidden: null, author: {username: mybuddy29, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 3015}}}, searchMeta: null}, {id: 316164, title: Python no string involved, commentCount: 6, topLevelCommentCount: 4, viewCount: 9123, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 609318, content: Reads the number backwards and checks if the numbers are equal.\n<br>\n```\nimport math \n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        orig = x\n        back_x = 0\n        while x > 0:\n            back_x = (back_x * 10) + (x % 10)\n            x = x // 10\n        return orig == back_x\n```, status: null, voteStatus: 0, voteCount: 75, creationDate: 1561079576, isHidden: null, author: {username: shrubs_and_trees, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 75}}}, searchMeta: null}, {id: 4488524, title: âœ… [C++]Easy solution with Video explaination in O(n) time complexityðŸŽ‰âœ…, commentCount: 14, topLevelCommentCount: 8, viewCount: 9402, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}], post: {id: 6683831, content: **Easy Video Explaination for beginners(must watch)**\n\nhttps://youtu.be/OxGW1x-5AVc\n\nSubscribe for more approach and explaination\n\n**Target:-100 Subscribers**\n\n**Approach:-**\n\n1. **Store the original number**: Save the original number in a variable for later comparison.\n\n2. **Set up a variable for the reversed number**: Prepare a space to store the digits of the number in reverse order.\n\n3. Check if the number is negative: If the number is negative, it cannot be a palindrome (a number that reads the same forward and backward). In such cases, immediately say it\'s not a palindrome.\n\n**Reverse the number:**\n\n4. Start from the last digit and go backward, storing each digit in reverse order.\n\n5. Build the reversed number by taking digits from the original number and placing them in reverse order.\n\n6.Compare the reversed number with the original number:\n - If the reversed number is the same as the original number, then it\'s a palindrome.\n - If they\'re different, then it\'s not a palindrome\n \n# Complexity Analysis\nTime Complexity=O(d)where d is numer of digit\nSC :- O(1)\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int n=x;\n        long long rev=0;\n        if(x<0)return false;\n        while(x>0){\n            rev=(rev*10)+(x%10);\n            x/=10;\n        }\n        if(rev==n)return true;\n        return false;\n    }\n};\n```\n```java []\npublic class Solution {\n    public boolean isPalindrome(int x) {\n        int n = x;\n        long rev = 0;\n        if (x < 0) return false;\n        while (x > 0) {\n            rev = (rev * 10) + (x % 10);\n            x /= 10;\n        }\n        if (rev == n) return true;\n        return false;\n    }\n}\n\n```\n```Python []\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        n = x\n        rev = 0\n        if x < 0:\n            return False\n        while x > 0:\n            rev = (rev * 10) + (x % 10)\n            x //= 10\n        if rev == n:\n            return True\n        return False\n```\n\n\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\n**Let me know in comment if i can do better.**\nI would greatly appreciate your support and look forward to connecting with you on **[LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)** \na\n\n![upvote.jfif](https://assets.leetcode.com/users/images/b0bf2fa1-1680-41fc-be3f-3ba1c8745505_1675216604.7695017.jpeg), status: null, voteStatus: 0, voteCount: 49, creationDate: 1704129599, isHidden: null, author: {username: vishnoi29, isActive: true, nameColor: null, activeBadge: {displayName: Jun LeetCoding Challenge, icon: /static/images/badges/dcc-2022-6.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1672812109.png, reputation: 5216}}}, searchMeta: null}, {id: 1549534, title: Python simple one line solution, commentCount: 8, topLevelCommentCount: 5, viewCount: 3894, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 2685779, content: **Python :**\n\n```\ndef isPalindrome(self, x: int) -> bool:\n\treturn str(x) == str(x)[::-1]\n```\n\n**Like it ? please upvote !**, status: null, voteStatus: 0, voteCount: 46, creationDate: 1635625389, isHidden: null, author: {username: TovAm, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1646133189.png, reputation: 2830}}}, searchMeta: null}, {id: 2996838, title: Python one-line solution with explanation, commentCount: 10, topLevelCommentCount: 7, viewCount: 13922, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 4741199, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nString has method to reverse\n# Approach\n<!-- Describe your approach to solving the problem. -->\nwith reversing it is possible to write in one line\n\'[::]\' this means print all, and this \'[::-1]\' reverses, it is mostly used with list in python \n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        return True if str(x)==str(x)[::-1] else False, status: null, voteStatus: 0, voteCount: 39, creationDate: 1672821502, isHidden: null, author: {username: nathan2077, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1672844241.png, reputation: 72}}}, searchMeta: null}, {id: 519779, title: Noob-friendly Python code, O(1) space O(n) time, commentCount: 5, topLevelCommentCount: 3, viewCount: 2477, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 981513, content: Let me know if a comment or code needs to be clarified so I can make it even easier to understand. Thanks!\n\n```\ndef isPalindrome(self, num):\n\t#negatives can\'t be palindromes cause of their minus sign so\n\t#instead of dealing with this in our main code, we get rid of this possibility immediately\n    if num < 0: return False\n\n    """\n\tSteps in this algorithm:\n    1. get the reversed number (the original number but its digits reversed). e.g. 125 becomes 521\n    2. if the reversed number == original number, its a palindrome! Done!\n    \n\tHow to get reversed number (rev_num):\n    1. we do this by \'popping\' the num\'s last digit. e.g. 125 becomes 12, we store 5 as last_digit\n    2. and then \'appending\' that last digit to rev_num. e.g. rev_num starts at 0. 0 becomes 5 after appending 5. 5 becomes 52 after appending 2 \n    3. we keep doing this until all num\'s digits have been popped, which happens when num becomes 0. e.g. when num is 0, rev_num will be 521\n\tNote: the \'popping\' and \'appending\' is done with cute math tricks, which is more space saving & usually faster than converting the number to a string\n\t"""\n\t\n    original_num = num\n    rev_num = 0\n\t#each line inside the while loop below does a neat math trick, try them w/ pencil & paper to understand why they work\n    while num > 0:\n\t  #get last digit from num. e.g. 125 % 10 returns 5\n      last_digit = num % 10\n\t  #remove last digit from num. e.g. lets say num is 125. num is then set to 125 // 10 which is 12\n      num = num // 10\n\t  #effectively, the above two lines of code have simply popped the last digit from num and saved it. e.g. num is changed from 125 to 12. last_digit is set to 5\n\n      #append last digit to right of rev_num, e.g. 5 becomes 52 after appending 2\n      rev_num = rev_num*10 + last_digit\n    \n\t#once the while loop is done, rev_num represents the reversed number of the original number\n\t#in below code, if they match, its a palindrome, since palindromes are symmetrical! e.g. 125 does not equal 521 so this condition would fail\n    return original_num == rev_num\n\t\n\t"""\n\tside note: the while loop gets completely skipped if num is initially 0.\n\tHere that situation conviently still gives us the right answer as rev_num will be 0 so its no problem, but\n\tstill its good to think about edge cases.\n\t"""\n```, status: null, voteStatus: 0, voteCount: 29, creationDate: 1582595818, isHidden: null, author: {username: grassworm, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 29}}}, searchMeta: null}, {id: 4795373, title: ðŸ¤” Why not 1 line of code Python | Python3 | C++ | Everyone can understand ðŸ«¥, commentCount: 8, topLevelCommentCount: 7, viewCount: 6249, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 7074826, content: ![Glenn Radars_8.png](https://assets.leetcode.com/users/images/bedf48a4-ad4b-4796-96d5-43c3eb3fa088_1709132425.2262912.png)\n\n# Code\n\n```python []\nclass Solution(object):\n    def isPalindrome(self, x):\n        return str(x) == str(x)[::-1]\n```\n```python3 []\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        return str(x) == str(x)[::-1]\n```\n```c++ []\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        std::string strX = std::to_string(x);\n        return strX == std::string(strX.rbegin(), strX.rend());\n    }\n};\n```\n![Screen Shot 2024-03-14 at 11.30.19.png](https://assets.leetcode.com/users/images/99fe0b15-b318-4601-af0f-574bc98640ee_1710652249.4421208.png)\n\n![Glenn Radars_7.png](https://assets.leetcode.com/users/images/50f5a963-e0dc-4931-818e-20860929d1f9_1709131836.7440155.png)\n\n\n## **My solutions**\n\n\uD83D\uDFE2 - $$easy$$  \n\uD83D\uDFE1 - $$medium$$ \n\uD83D\uDD34 - $$hard$$\n\n\uD83D\uDFE1 [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/4845532/there-is-an-80-chance-of-being-in-the-interview-full-problem-explanation)\n\uD83D\uDFE1 [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/solutions/4845742/simple-explanation-with-pictures)\n\uD83D\uDFE1 [39. Combination Sum](https://leetcode.com/problems/combination-sum/solutions/4847482/beat-8292-full-explanation-with-pictures)\n\uD83D\uDFE2 [2540. Minimum Common Value](https://leetcode.com/problems/minimum-common-value/solutions/4845076/beat-9759-full-explanation-with-pictures)\n\uD83D\uDFE2 [3005. Count Elements With Maximum Frequency](https://leetcode.com/problems/count-elements-with-maximum-frequency/solutions/4839796/beat-8369-full-explanation-with-pictures)\n\uD83D\uDFE2 [3028. Ant on the Boundary](https://leetcode.com/problems/ant-on-the-boundary/solutions/4837433/full-explanation-with-pictures)\n\uD83D\uDFE2 [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/solutions/4834682/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE1 [1750. Minimum Length of String After Deleting Similar Ends](https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/solutions/4824224/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE1 [948. Bag of Tokens](https://leetcode.com/problems/bag-of-tokens/solutions/4818912/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE1 [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/4813340/beat-10000-full-explanation-with-pictures)\n\uD83D\uDFE2 [977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/solutions/4807704/square-sorter-python-python3-javascript-c)\n\uD83D\uDFE2 [2864. Maximum Odd Binary Number](https://leetcode.com/problems/maximum-odd-binary-number/solutions/4802402/visual-max-odd-binary-solver-python-python3-javascript-c)\n\uD83D\uDFE1 [1609. Even Odd Tree](https://leetcode.com/problems/even-odd-tree/solutions/4797529/even-odd-tree-validator-python-python3-javascript-c)\n\uD83D\uDFE2 [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/4795373/why-not-1-line-of-code-python-python3-c-everyone-can-understand)\n\uD83D\uDFE1 [513. Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/solutions/4792022/binary-tree-explorer-mastered-javascript-python-python3-c-10000-efficiency-seeker)\n\uD83D\uDFE2 [1. Two Sum](https://leetcode.com/problems/two-sum/solutions/4791305/5-methods-python-c-python3-from-easy-to-difficult)\n\uD83D\uDFE2 [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/solutions/4787634/surpassing-9793-memory-magician-excelling-at-9723)\n[More...](https://leetcode.com/DevOgabek/)\n, status: null, voteStatus: 0, voteCount: 27, creationDate: 1709132447, isHidden: null, author: {username: DevOgabek, isActive: true, nameColor: null, activeBadge: {displayName: Mar LeetCoding Challenge, icon: /static/images/badges/dcc-2024-3.png}, profile: {userAvatar: https://assets.leetcode.com/users/DevOgabek/avatar_1711458357.png, reputation: 5628}}}, searchMeta: null}, {id: 4033190, title: ðŸš€C++ || Java || Python || Two Methods || Explained IntuitionðŸš€, commentCount: 4, topLevelCommentCount: 2, viewCount: 5061, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 6090486, content: # Problem Description\n**Given** an integer x, return **true** if x is a **palindrome**, and **false** otherwise.\n\n**Palindrome** is a **word**, **phrase**, **number**, or **other sequence of characters** that **reads** the **same** **forward** and **backward**. In simpler terms, it\'s something that `remains unchanged when its order is reversed`.\n\n- Here are a few **examples** of palindromes:\n    - Words :"racecar", "madam"\n    - Numbers: 121, 1331, 12321\n\n- **Constraints:**\n    - `-2e31 <= x <= 2e31 - 1`\n\n---\n# Intuition\n## First Approach (Convert to String)\nThe **first** approach is to **convert our number into a string** and there we can **access** any digit **freely** unlike the integer that we can\'t do that there.\nthen we can make a **mirror** around the middle of the string and **compare** the first char with last char, the second with the one before last and so on.\nif there is a **difference** then return false otherwise return true. \n\n![image.png](https://assets.leetcode.com/users/images/d6c0868b-843e-4f69-a092-4a5f4c39051f_1694475883.578209.png)\n\n![image.png](https://assets.leetcode.com/users/images/cf45160a-6169-463a-a4d0-8c85c5fa029a_1694475917.7519221.png)\n\n\n## Second Approach (Extract Digits using %)\n\n**Modulo operation** is is a mathematical operation that returns the remainder when one number is divided by another.\n- 7 % 3 = 1\n- 9 % 5 = 4\n\nModulo operation is very helpful in our problem since it helps us to **extract the least digit in our number**.\nThe solution is **extract** the digit from the original number then **put it as least digit** in our new reversed number then **delete** that digit by dividing by 10.\n\n**Example : 121**\n```\nnumber = 121 , reversed = 0 \ndigit = 121 % 10 = 1 \nreversed = 0 * 10 + 1 = 1\nnumber = 121 / 10 = 12\n```\n```\nnumber = 12 , reversed = 1 \ndigit = 12 % 10 = 2 \nreversed = 1 * 10 + 2 = 2\nnumber = 12 / 10 = 1\n```\n```\nnumber = 1 , reversed = 12\ndigit = 1 % 10 = 1 \nreversed = 12 * 10 + 1 = 121\nnumber = 1 / 10 = 0\n```\nWe can see that reversed number **equal** to original number which means it is palindrome.\n\n\n---\n\n\n# Approach\n## First Approach (Convert to String)\n- **Convert** the integer x to a string representation.\n- Determine the **length** of the string.\n- Set up a for **loop** that iterates from the beginning of the string (index 0) to halfway through the string (length / 2).\n- Inside the loop, **compare** the character at the **current** position (number[i]) with the character at the **corresponding** position from the end of the string (number[length - i - 1]).\n- If the characters **do not match** (i.e., the number is not palindrome from the center outward), return **false** immediately, indicating that it\'s not a palindrome.\n- If the **loop** **completes** without finding any mismatches (all digits match), return **true**, indicating that the integer is a palindrome.\n\n# Complexity\n- **Time complexity:**$$O(N)$$\nSince we are iterating over all the digits.\n- **Space complexity:**$$O(N)$$\nSince we are storing the number as a string where `N` here is the number of the digits.\n---\n## Second Approach (Extract Digits using %)\n- Create **two long variables**, number and reversed, both initially set to the value of the input integer x. The number variable stores the **original** number, and reversed will store the **number in reverse order**.\n- Enter a while **loop** that continues as long as the value of x is greater than 0.\n- Inside the **loop**:\n    - Calculate the **last digit of x** by taking the remainder of x when divided by 10 **(x % 10)**. This digit is stored in the digit variable.\n    - **Update the reversed variable** by multiplying it by 10 (shifting digits left) and then adding the digit to it. This effectively builds the reversed number digit by digit.\n    - **Remove the last digit** from x by dividing it by 10 (x /= 10).\n- After the loop completes, all digits of x have been processed and reversed in reversed.\n- Check if the number (the original input) is **equal** to the reversed (the reversed input). If they are equal, return **true**, indicating that the integer is a palindrome. If they are not equal, return **false**.\n\n# Complexity\n- **Time complexity:**$$O(N)$$\nSince we are iterating over all the digits.\n- **Space complexity:**$$O(1)$$\nWe only store two additional variables.\n\n# Code\n## First Approach (Convert to String)\n```C++ []\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        string number = to_string(x) ;\n        int length = number.size() ;\n        for(int i = 0 ; i < length / 2 ; i ++){\n            if(number[i] != number[length - i - 1])\n                return false ;\n        }\n        return true;\n    }\n};\n```\n```Java []\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String number = Integer.toString(x);\n        int length = number.length();\n        for (int i = 0; i < length / 2; i++) {\n            if (number.charAt(i) != number.charAt(length - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n```Python []\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        number = str(x)\n        length = len(number)\n        \n        for i in range(length // 2):\n            if number[i] != number[length - i - 1]:\n                return False\n        \n        return True\n```\n## Second Approach (Extract Digits using %)\n```C++ []\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        long long number = x, reversed = 0;\n        while(x > 0){\n            int digit = x % 10 ;\n            reversed = (reversed * 10) + digit ; \n            x /= 10 ;\n        }\n        return number == reversed ;\n    }\n};\n```\n```Java []\nclass Solution {\n    public boolean isPalindrome(int x) {\n        long number = x;\n        long reversed = 0;\n        \n        while (x > 0) {\n            int digit = x % 10;\n            reversed = (reversed * 10) + digit;\n            x /= 10;\n        }\n        return number == reversed;\n    }\n}\n```\n```Python []\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        number = x\n        reversed_num = 0\n        \n        while x > 0:\n            digit = x % 10\n            reversed_num = (reversed_num * 10) + digit\n            x //= 10\n        \n        return number == reversed_num\n```\n\n![HelpfulJerry.jpg](https://assets.leetcode.com/users/images/dfd2724e-bad7-4416-9f70-e1cf0e9f582f_1698515177.081801.jpeg)\n\n\n\n, status: null, voteStatus: 0, voteCount: 17, creationDate: 1694476805, isHidden: null, author: {username: MohamedMamdouh20, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1694009290.png, reputation: 3455}}}, searchMeta: null}, {id: 2797115, title: Easy Python Solution with O(1) space, commentCount: 1, topLevelCommentCount: 1, viewCount: 5051, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 4478167, content: ```\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        \n        res = 0\n        temp = x\n        \n        while temp:\n            temp, n = divmod(temp, 10)\n            res = (res * 10) + n\n                \n        return res == x\n```, status: null, voteStatus: 0, voteCount: 17, creationDate: 1668013002, isHidden: null, author: {username: bogartpi, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1666622010.png, reputation: 94}}}, searchMeta: null}, {id: 3871467, title: Palindrome without using convertation to str, commentCount: 10, topLevelCommentCount: 2, viewCount: 3392, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}], post: {id: 5877567, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe hint was not to use convertation x to string , so I used tricks of division. \n\n# Approach\nWe start from the latest digit of initial number and build reverted number. Then check is real number equals to reverted and returns the result. \n\n# Complexity\n- Time complexity: O(n) \n*where n is length of x , we just go through all numbers of initial x \n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution(object):\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        reversed_number = 0\n        number = x\n        while x > 0:\n            digit = x % 10\n            x = x // 10\n            reversed_number = reversed_number * 10 + digit\n\n        return number == reversed_number\n```, status: null, voteStatus: 0, voteCount: 12, creationDate: 1691316074, isHidden: null, author: {username: k_chubarova, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/katechubarova/avatar_1636021301.png, reputation: 23}}}, searchMeta: null}, {id: 4850674, title: [VIDEO] Visualization of Solution Using Modulo and Floor Division, commentCount: 1, topLevelCommentCount: 1, viewCount: 816, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 7146164, content: https://www.youtube.com/watch?v=OlTk8wM48ww\n\nThe idea here is that we don\'t need to reverse all the digits, only <i>half</i> the digits.  The first line checks some edge cases, and returns False immediately if the number is negative or ends with a 0 (with the exception of the number 0 itself).  The loop then uses the modulo and floor division operators to reverse the digits and transfer them to the `half` variable.\n\nOnce the halfway point is reached, we return True if the two halves are equal to each other.  If the number originally had an <i>odd</i> number of digits, then the two halves will be off by 1 digit, so we also remove that digit using floor division, then compare for equality.\n# Code\n```\nclass Solution(object):\n    def isPalindrome(self, x):\n        if x < 0 or (x != 0 and x % 10 == 0):\n            return False\n\n        half = 0\n        while x > half:\n            half = (half * 10) + (x % 10)\n            x = x // 10\n\n        return x == half or x == half // 10\n```\n\n# Alternate solution\n```\nclass Solution(object):\n    def isPalindrome(self, x):\n        x = str(x)\n        return x == x[::-1]\n```\nAlternate solution: turn the number into a string, reverse it, and see if they\'re equal.  This is the simplest solution, but the question does challenge us to solve it <i>without</i> turning the number into a string.\n, status: null, voteStatus: 0, voteCount: 9, creationDate: 1710031838, isHidden: null, author: {username: AlgoEngine, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1673908639.png, reputation: 5273}}}, searchMeta: null}, {id: 2329273, title: â­C#, Java, Python3,JavaScript Solution ( 90~99% Faster ), commentCount: 0, topLevelCommentCount: 0, viewCount: 1709, pinned: false, isFavorite: false, solutionTags: [{name: Java, slug: java}, {name: Python3, slug: python3}, {name: JavaScript, slug: javascript}], post: {id: 3839309, content: See the code : \u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\u2B50\n\n**\uD83E\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\n\n![image](https://assets.leetcode.com/users/images/5afaf588-9ac5-4ce7-ba46-bfbddb3e7586_1658709281.7354767.png)\n\n\n, status: null, voteStatus: 0, voteCount: 9, creationDate: 1658709132, isHidden: null, author: {username: zyrastory, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2022, icon: https://leetcode.com/static/images/badges/2022/lg/2022-annual-100.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1649596945.png, reputation: 773}}}, searchMeta: null}, {id: 4120683, title: âœ…ðŸ’¡100% Acceptance Rate with â£ï¸Easy and Detailed Explanation - O(log10(x)) solution ðŸ’¡ðŸ˜„, commentCount: 2, topLevelCommentCount: 1, viewCount: 2109, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: Linked List, slug: linked-list}, {name: Math, slug: math}, {name: Two Pointers, slug: two-pointers}, {name: Dynamic Programming, slug: dynamic-programming}, {name: Backtracking, slug: backtracking}], post: {id: 6205926, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nTo check if an integer is a palindrome, we reverse the integer and compare it with the original number. If they are the same, the number is a palindrome. However, we need to handle some special cases like negative numbers and numbers ending with zero.\n\n---\n# Do upvote if you like the solution and explanation \uD83D\uDCA1\uD83D\uDE04\n\n---\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n1. If the input number x is negative or ends with a zero (except when x is 0 itself), it cannot be a palindrome. In such cases, we return false.\n\n2. We initialize a variable reversed to 0. We use a while loop to reverse the second half of the integer x. In each iteration of the loop:\n\n3. Multiply reversed by 10 to shift its digits to the left.\nAdd the last digit of x to reversed (obtained using x % 10).\nDivide x by 10 to remove the last digit.\n- After the loop, we check if x is equal to reversed or if x is equal to reversed / 10. This step handles both even and odd-length palindromes. If the condition is true, we return true, indicating that x is a palindrome; otherwise, we return false.\n\n---\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nThe time complexity of this code is O(log10(x)), where log10(x) is the number of digits in x. In the worst case, the while loop runs for half of the digits in x, so the time complexity is proportional to the number of digits.\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nThe space complexity of this code is O(1) because it uses a fixed amount of extra space regardless of the input x.\n\n---\n\n# \uD83D\uDCA1"If you have journeyed this far, I would kindly beseech you to consider upvoting this solution, thereby facilitating its reach to a wider audience."\u2763\uFE0F\uD83D\uDCA1\n\n---\n\n\n# Code\n```\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        // If x is negative or ends with 0 but is not 0 itself, it cannot be a palindrome.\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n\n        // When the length of the remaining number is odd, we can remove the middle digit.\n        // For example, in the number 12321, we can remove the middle \'3\'.\n        return x == reversed || x == reversed / 10;\n    }\n};\n\n```, status: null, voteStatus: 0, voteCount: 8, creationDate: 1696264836, isHidden: null, author: {username: anshuP_cs24, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1696058046.png, reputation: 288}}}, searchMeta: null}, {id: 3280798, title: Python3 || one-liner || easiest solution, commentCount: 0, topLevelCommentCount: 0, viewCount: 2667, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Math, slug: math}], post: {id: 5112367, content: # Approach\n<!-- Describe your approach to solving the problem. -->\n- convert integer x to string.\n- now return true if reverse of x and original order is same else false.\n\n# Complexity\n- Time complexity: O(N)\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: O(1)\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        return str(x) == str(x)[::-1]\n```, status: null, voteStatus: 0, voteCount: 7, creationDate: 1678464131, isHidden: null, author: {username: shivam_1110, isActive: true, nameColor: null, activeBadge: {displayName: Feb LeetCoding Challenge, icon: /static/images/badges/dcc-2023-2.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1674718657.png, reputation: 282}}}, searchMeta: null}]}}}, {data: {questionSolutions: {hasDirectResults: true, totalNum: 274, solutions: [{id: 2976919, title: Solution, commentCount: 10, topLevelCommentCount: 6, viewCount: 37411, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python3, slug: python3}], post: {id: 4716149, content: ```C++ []\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length(), m = p.length();\n        bool dp[n+1][m+1];\n        memset(dp, false, sizeof(dp));\n        dp[0][0] = true;\n        \n        for(int i=0; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                if(p[j-1] == \'*\'){\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == \'.\') && dp[i-1][j]);\n                }\n                else{\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \'.\');\n                }\n            }\n        }\n        \n        return dp[n][m];\n    }\n};\n```\n\n```Python3 []\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        i, j = len(s) - 1, len(p) - 1\n        return self.backtrack({}, s, p, i, j)\n\n    def backtrack(self, cache, s, p, i, j):\n        key = (i, j)\n        if key in cache:\n            return cache[key]\n\n        if i == -1 and j == -1:\n            cache[key] = True\n            return True\n\n        if i != -1 and j == -1:\n            cache[key] = False\n            return cache[key]\n\n        if i == -1 and p[j] == \'*\':\n            k = j\n            while k != -1 and p[k] == \'*\':\n                k -= 2\n            \n            if k == -1:\n                cache[key] = True\n                return cache[key]\n            \n            cache[key] = False\n            return cache[key]\n        \n        if i == -1 and p[j] != \'*\':\n            cache[key] = False\n            return cache[key]\n\n        if p[j] == \'*\':\n            if self.backtrack(cache, s, p, i, j - 2):\n                cache[key] = True\n                return cache[key]\n            \n            if p[j - 1] == s[i] or p[j - 1] == \'.\':\n                if self.backtrack(cache, s, p, i - 1, j):\n                    cache[key] = True\n                    return cache[key]\n        \n        if p[j] == \'.\' or s[i] == p[j]:\n            if self.backtrack(cache, s, p, i - 1, j - 1):\n                cache[key] = True\n                return cache[key]\n\n        cache[key] = False\n        return cache[key]\n```\n\n```Java []\nenum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == \'.\'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == \'*\'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}\n```\n, status: null, voteStatus: 0, voteCount: 467, creationDate: 1672532793, isHidden: null, author: {username: deleted_user, isActive: false, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 4332}}}, searchMeta: null}, {id: 529694, title: This is NOT a fast algorithm, but a VERY detailed explanation for 'dumb' people like myself, commentCount: 2, topLevelCommentCount: 2, viewCount: 2771, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 999137, content: **This is NOT a fast algorithm, it is intended to explain the naive algorithm to those who struggled like I did.**\n\nThe solution provided by Leedcode Solution, or tutorials on YouTube all fail to explain the question clearly enough before jumping into DP and other speedy algorithm.\n\n# Intuition and Analysis\n\n* Let s[i] and p[j] be the elements we are comparing.\n* Without \'\\*\', compare element one by one,\n```\nif mismatch:\n\treturn False\nelse:\n\ti++\n\tj++\n```\n* With \'\\*\'\n\t* case 1 we skip s[i] due to mismatch\n\t* case 2 we delete/ignore/skip s[i] one or more times.\n\n**THE CATCH** lies in \'one or more times\', most tutorial will tell you to delete s[i] until you fiind a mismatch e.g.\n```\n        s = \'aaaab\', p = \'a*b\'\n        delete/ignore/skip \'a\' 4 times\n        s = \'b\', p = \'b\' BINGO!\n```\nBut this algorithm can be easily defeated by\n\n\ts = \'aaa\', p = \'a*a\'\n\t\t\nThis will result in s = \'\', p = \'a\'.\n\n**THE KEY** is try all the possibilities of the number of times s[i] can be deleted/ignored/skipped, if any possibility results in True, then this part of string matching is True because \'\\*\' gives this kind of flexibility. In the example above, the correct number of times is 2, you want be left with s = \'a\', p =\'a\'.\n\n**For implementation, please see in code, I rewrote readable version of simplied code.**\n\nI have struggled with this question for hours, I really hope this kind of \'dumb\' explaination can help you, because most answers I have looked at are trying too hard to be smart for newbies like myself.\n\n\n```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Edge case\n        if p is \'\':\n            if s is \'\':\n                return True\n            else:\n                return False\n        # Simplified version:\n        # if not p:\n        #     return not s\n\n        if s:\n            first_char_match = p[0] in (s[0], \'.\')\n        else:\n            first_char_match = False\n        # Simplified version:\n        # first_char_match = bool(s) and p[0] in (s[0], \'.\')\n\n        # len(p) < 2, p[1] will raise error\n        if len(p) > 1 and p[1] == \'*\':\n            """\n            Try all possibilities:\n            1) 0 occurrence, zero_ocr\n            2) repeat is for one or more occurrence.\n               This is bit subtle. The correct number of times of \n               deleting/ignoring/skipping will result in either case\n               being True.\n               e.g. s = \'aaa\', p = \'a*a\'\n                    skips twice\n                    s = \'a\', p[2:] = \'a\' -> True\n               e.g. s = \'aab\', p = \'a*b\'\n                    ...\n                    s = \'b\', p = \'a*b\'\n                    zero_ocr = isMatch(\'b\', \'b\') -> True\n                    first_char_match = False\n                    return zero_ocr, thus return True in the end\n            """\n            zero_ocr = self.isMatch(s, p[2:])\n            if first_char_match:\n                repeat = self.isMatch(s[1:], p)\n                return zero_ocr or repeat\n            return zero_ocr\n            # Simplified version\n            # return self.isMatch(s, p[2:]) \\\n            #        or (first_char_match and self.isMatch(s[1:], p))\n        else:\n            if first_char_match:\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n```, status: null, voteStatus: 0, voteCount: 31, creationDate: 1583412948, isHidden: null, author: {username: W-Qiu, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/w-qiu/avatar_1571142613.png, reputation: 99}}}, searchMeta: null}, {id: 2056415, title: [0ms][1LINER][100%][Fastest Solution Explained] O(n) time complexity | O(n) space complexity, commentCount: 3, topLevelCommentCount: 3, viewCount: 8462, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: JavaScript, slug: javascript}, {name: Kotlin, slug: kotlin}, {name: PHP, slug: php}], post: {id: 3458319, content: (Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\n***Take care brother, peace, love!***\n\n```\n```\n\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\n* *** Python ***\n\n```\n\n    def isMatch(self, s: str, p: str) -> bool:\n        s, p = \' \'+ s, \' \'+ p\n        lenS, lenP = len(s), len(p)\n        dp = [[0]*(lenP) for i in range(lenS)]\n        dp[0][0] = 1\n\n        for j in range(1, lenP):\n            if p[j] == \'*\':\n                dp[0][j] = dp[0][j-2]\n\n        for i in range(1, lenS):\n            for j in range(1, lenP):\n                if p[j] in {s[i], \'.\'}:\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j] == "*":\n                    dp[i][j] = dp[i][j-2] or int(dp[i-1][j] and p[j-1] in {s[i], \'.\'})\n\n        return bool(dp[-1][-1])\n\n```\n\n```\n```\n\n```\n```\n***"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes.." - \uD835\uDCD0\uD835\uDCF7\uD835\uDCF8\uD835\uDCF7\uD835\uDD02\uD835\uDCF6\uD835\uDCF8\uD835\uDCFE\uD835\uDCFC***, status: null, voteStatus: 0, voteCount: 20, creationDate: 1653034174, isHidden: null, author: {username: darian-catalin-cucer, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1680878634.png, reputation: 2245}}}, searchMeta: null}, {id: 3243200, title: [ Beats 98% ] Regular Expression Matching using Dynamic Programming in Python, commentCount: 15, topLevelCommentCount: 4, viewCount: 9945, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: String, slug: string}, {name: Dynamic Programming, slug: dynamic-programming}, {name: Recursion, slug: recursion}], post: {id: 5064740, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThis problem can be solved by using dynamic programming. We can define dp(i, j) as the boolean value indicating whether the substring s[i:] matches the pattern p[j:].\n# Approach\n<!-- Describe your approach to solving the problem. -->\nWe can solve the problem by defining a recursive function that tries to match s[i:] with p[j:] for all possible i and j indices. The function should return true if and only if it matches the entire string.\n\nTo avoid redundant computation, we can use memoization to store the previously computed results of dp(i, j) in a memo dictionary. The recursive function first checks if the result is already computed in the memo dictionary and returns it if so.\n\nIf j reaches the end of p, the function returns true if and only if i also reaches the end of s.\n\nIf the next character in p is followed by a \'\', the function can match zero or more occurrences of the preceding character. The function recursively tries two cases: either skip the preceding character and the \'\', or match the preceding character and recursively try to match the remaining part of s and p. The function returns true if either case succeeds.\n\nOtherwise, the function simply checks if the next character in p matches the next character in s or is a dot character (\'.\') that matches any character. If so, the function recursively tries to match the remaining part of s and p. The function returns true if both cases succeed.\n# Complexity\n- Time complexity: O(SP), where S is the length of the string s and P is the length of the pattern p. The function tries to match each character in s with each character in p at most once and uses memoization to avoid redundant computation.\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: O(SP), where S is the length of the string s and P is the length of the pattern p. The function uses memoization to store the previously computed results of dp(i, j).\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        memo = {}\n    \n        def dp(i: int, j: int) -> bool:\n            if (i, j) in memo:\n                return memo[(i, j)]\n        \n            if j == len(p):\n                return i == len(s)\n        \n            first_match = i < len(s) and (p[j] == s[i] or p[j] == \'.\')\n        \n            if j + 1 < len(p) and p[j+1] == \'*\':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        \n            memo[(i, j)] = ans\n            return ans\n    \n        return dp(0, 0)\n```, status: null, voteStatus: 0, voteCount: 17, creationDate: 1677663477, isHidden: null, author: {username: Rare_Zawad, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1675490863.png, reputation: 353}}}, searchMeta: null}, {id: 2383634, title: [Fastest Solution Explained][0ms][100%] O(n)time complexity O(n)space complexity, commentCount: 4, topLevelCommentCount: 2, viewCount: 6424, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Java, slug: java}, {name: Python, slug: python}, {name: Python3, slug: python3}, {name: C, slug: c}, {name: JavaScript, slug: javascript}, {name: Swift, slug: swift}, {name: Kotlin, slug: kotlin}, {name: PHP, slug: php}], post: {id: 3914069, content: \n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\n***Take care brother, peace, love!***\n\n```\n```\n\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\n* *** Java ***\n\n```\n\npublic boolean isMatch(String s, String p) {\n\t\t/**\n\t\t * This solution is assuming s has no regular expressions.\n\t\t * \n\t\t * dp: res[i][j]=is s[0,...,i-1] matched with p[0,...,j-1];\n\t\t * \n\t\t * If p[j-1]!=\'*\', res[i][j] = res[i-1][j-1] &&\n\t\t * (s[i-1]==p[j-1]||p[j-1]==\'.\'). Otherwise, res[i][j] is true if\n\t\t * res[i][j-1] or res[i][j-2] or\n\t\t * res[i-1][j]&&(s[i-1]==p[j-2]||p[j-2]==\'.\'), and notice the third\n\t\t * \'or\' case includes the first \'or\'.\n\t\t * \n\t\t * \n\t\t * Boundaries: res[0][0]=true;//s=p="". res[i][0]=false, i>0.\n\t\t * res[0][j]=is p[0,...,j-1] empty, j>0, and so res[0][1]=false,\n\t\t * res[0][j]=p[j-1]==\'*\'&&res[0][j-2].\n\t\t * \n\t\t * O(n) space is enough to store a row of res.\n\t\t */\n\n\t\tint m = s.length(), n = p.length();\n\t\tboolean[] res = new boolean[n + 1];\n\t\tres[0] = true;\n\n\t\tint i, j;\n\t\tfor (j = 2; j <= n; j++)\n\t\t\tres[j] = res[j - 2] && p.charAt(j - 1) == \'*\';\n\n\t\tchar pc, sc, tc;\n\t\tboolean pre, cur; // pre=res[i - 1][j - 1], cur=res[i-1][j]\n\n\t\tfor (i = 1; i <= m; i++) {\n\t\t\tpre = res[0];\n\t\t\tres[0] = false;\n\t\t\tsc = s.charAt(i - 1);\n\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tcur = res[j];\n\t\t\t\tpc = p.charAt(j - 1);\n\t\t\t\tif (pc != \'*\')\n\t\t\t\t\tres[j] = pre && (sc == pc || pc == \'.\');\n\t\t\t\telse {\n\t\t\t\t\t// pc == \'*\' then it has a preceding char, i.e. j>1\n\t\t\t\t\ttc = p.charAt(j - 2);\n\t\t\t\t\tres[j] = res[j - 2] || (res[j] && (sc == tc || tc == \'.\'));\n\t\t\t\t}\n\t\t\t\tpre = cur;\n\t\t\t}\n\t\t}\n\n\t\treturn res[n];\n\t}\n\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\n* *** Python ***\n\n```\n\ncache = {}\ndef isMatch(self, s, p):\n    if (s, p) in self.cache:\n        return self.cache[(s, p)]\n    if not p:\n        return not s\n    if p[-1] == \'*\':\n        if self.isMatch(s, p[:-2]):\n            self.cache[(s, p)] = True\n            return True\n        if s and (s[-1] == p[-2] or p[-2] == \'.\') and self.isMatch(s[:-1], p):\n            self.cache[(s, p)] = True\n            return True\n    if s and (p[-1] == s[-1] or p[-1] == \'.\') and self.isMatch(s[:-1], p[:-1]):\n        self.cache[(s, p)] = True\n        return True\n    self.cache[(s, p)] = False\n    return False\n\n```\n\n```\ndef isMatch(self, s, p):\n    dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\n    dp[0][0] = True\n    for i in range(1, len(p)):\n        dp[i + 1][0] = dp[i - 1][0] and p[i] == \'*\'\n    for i in range(len(p)):\n        for j in range(len(s)):\n            if p[i] == \'*\':\n                dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1]\n                if p[i - 1] == s[j] or p[i - 1] == \'.\':\n                    dp[i + 1][j + 1] |= dp[i + 1][j]\n            else:\n                dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == \'.\')\n    return dp[-1][-1]\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\n* *** C++ ***\n\n\nWe can solve the problem using recursion. We need the helper function to keep track of the current indices of the pattern and the string. The basic condition would be when pattern index reaches the end, then we will check if the string index has also reached the end or not.\n\nNow we will check if the pattern current index matches the string current index character, this would be true either when the characters are equal i.e. s[i]==p[j] or if the p[j]==\'.\' since \'.\' can be replaced by any character.\n\nIf the next pattern character is \'\' that means the current pattern character p[j] could occur 0 or infinite times. So, then there would be two possibility either we can take match the current pattern character with the string and move i by 1 or we can just take zero occurence of the current pattern character and move the pattern character by 2. We will apply the OR condition between these two conditions since if either of them matches then it solves our problem and if next pattern character is not \'\' , then we need to check if the current character matches or not and also move both string and pattern character by 1.\n\nThe time complexity of this brute force approach is O(3^(max(m,n)) and space complexity is O(max(m,n)) where m and n are the length of pattern and string respectively.\n\n```\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        return helper(s,p,0,0);\n    }\n    \n    bool helper(string s, string p, int i, int j)\n    {\n        if(j==p.length())\n            return i==s.length();\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\'.\' ));\n        \n        if(j+1<p.length() && p[j+1]==\'*\')\n        {\n            return (helper(s,p,i,j+2)|| (first_match && helper(s,p,i+1,j) ));\n        }\n        else\n        {\n            return (first_match && helper(s,p,i+1,j+1));\n        }\n    }\n};\n```\n\nWe are actually recomputing the solution for the same subproblems many times. So to avoid that we can initialize dp matrix with all values with being -1. Now if dp[i][j]>=0 then that means this has been already computed so we can return the results here only, thus, it saves time and we don\'t need to recompute that again. Notice that we are saving the results in dp[i][j] in the second last line and this result would always be positive either 0 or 1.\n\nThe time complexity is now O(mn) and space complexity is O(mn) where m and n are the length of pattern and string respectively.\n\n```\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length(),-1));\n        return helper(s,p,0,0,dp);\n    }\n    \n    bool helper(string s, string p, int i, int j,vector<vector<int>> &dp)\n    {\n        if(j==p.length())\n            return i==s.length();\n        if(dp[i][j]>=0)\n            return dp[i][j];\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\'.\' ));\n        bool ans=0;\n        if(j+1<p.length() && p[j+1]==\'*\')\n        {\n            ans= (helper(s,p,i,j+2,dp)|| (first_match && helper(s,p,i+1,j,dp) ));\n        }\n        else\n        {\n            ans= (first_match && helper(s,p,i+1,j+1,dp));\n        }\n        dp[i][j]=ans;\n        return ans;\n    }\n};\n```\n\nBottom up solution\n\nWe can derive the bottom up solution from top down approach only. We will make the matrix of length (s.length()+1)* (p.length()+1) . dp[s.length()][p.length()]=1 since both have ended at that point.\n\n```\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n    vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\n        dp[s.length()][p.length()]=1;\n        \n        for(int i=s.length();i>=0;i--)\n        {\n            for(int j=p.length()-1;j>=0;j--)\n            {\n                bool first_match=(i<s.length() && (p[j]==s[i]|| p[j]==\'.\'));\n                    if(j+1<p.length() && p[j+1]==\'*\')\n                    {\n                        dp[i][j]=dp[i][j+2] || (first_match && dp[i+1][j]);\n                    }\n                else\n                {\n                    dp[i][j]=first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        \n    return dp[0][0];\n    }\n};\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\n* *** JavaScript ***\n\n\n```\n\nfunction isMatch(s, p) {\n  var lenS = s.length;\n  var lenP = p.length;\n  var map = {};\n\n  return check(0, 0);\n\n  function check(idxS, idxP) {\n    if (map[idxS + \':\' + idxP] !== undefined) return map[idxS + \':\' + idxP];\n    if (idxS > lenS) return false;\n    if (idxS === lenS && idxP === lenP) return true;\n\n    if (p[idxP] === \'.\' || p[idxP] === s[idxS]) {\n      map[idxS + \':\' + idxP] = p[idxP + 1] === \'*\' ?\n        check(idxS + 1, idxP) || check(idxS, idxP + 2) :\n        check(idxS + 1, idxP + 1);\n    } else {\n      map[idxS + \':\' + idxP] = p[idxP + 1] === \'*\' ?\n        check(idxS, idxP + 2) : false;\n    }\n    return map[idxS + \':\' + idxP];\n  }\n}\n\n```\n\n```\nconst isMatch = (string, pattern) => {\n    // early return when pattern is empty\n    if (!pattern) {\n\t\t// returns true when string and pattern are empty\n\t\t// returns false when string contains chars with empty pattern\n        return !string;\n    }\n    \n\t// check if the current char of the string and pattern match when the string has chars\n    const hasFirstCharMatch = Boolean(string) && (pattern[0] === \'.\' || pattern[0] === string[0]);\n\n    // track when the next character * is next in line in the pattern\n    if (pattern[1] === \'*\') {\n        // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\'s because the current pattern may be skipped.\n        // otherwise check hasFirstCharMatch. That\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\n\t\t// If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\'s because current char matches the pattern char. \n        return (\n            isMatch(string, pattern.slice(2)) || \n            (hasFirstCharMatch && isMatch(string.slice(1), pattern))\n        );\n    }\n    \n    // now we know for sure that we need to do 2 simple actions\n\t// check the current pattern and string chars\n\t// if so, then can proceed with next string and pattern chars (s+1, p+1)\n    return hasFirstCharMatch ? isMatch(string.slice(1), pattern.slice(1)) : false;\n};\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\n* *** Python3 ***\n\n\nIf dp[i][j] == False, it means s[:i] doesn\'t match p[:j]\u2028If dp[i][j] == True, it means s[:i] matches p[:j]\u2028\'.\' Matches any single character.\u2028\'\' Matches zero or more of the preceding element.\u2028s = "aa"\u2028p = "a"\u2028Output: true\u2028Explanation: \'*\' means zero or more of the preceding element, \'a\'. Therefore, by repeating \'a\' once, it becomes "aa".\n\n```\ns = "aab"\np = "c*a*b"\n                 c      *       a      *     b\ndp = [ \n         [True, False, True, False, True, False], \n\t a  [False, False, False, True, True, False], \n\t a  [False, False, False, False, True, False], \n\t b\t[False, False, False, False, False, True]] \n\t\n#  Case 1 p[:j] ==  alphabet or \'.\'\n#  Case 2: p[:j] is \'*\'\n\t# Case 2a: p[:j-1] doesn\'t need a \'*\' to match the substring s[:i]\n\t    #1  p[:j-1] ==s[:i]   dp[i][j] =d[i-1][j]\n\t\t    0  a  *                0   a  a \n        0                      0\n        a        T        ---> a\n        a        T             a         T\n\t\t#2  p[:j-1] == \'.\'      dp[i][j]=dp[i][j-2]\n\t\t    0  a  b  *\n        0  \n        a     T     T          \n        \n\t# Case 2b: p[:j] needs \'*\' to match the substring s[:i]\n```\n```\n # about *:\n case 1: 0 preceding element\n case 2: 1 or more preceding element\n\t\t\t   the preceding element could be a \'.\' or an alpharbet.\n\t\t\t   more proceding element is easy to handle once you use dynamic programming. \n ```\n ```\nclass Solution:\n    def isMatch(self, s, p):\n        n = len(s)\n        m = len(p)\n        dp = [[False for _ in range (m+1)] for _ in range (n+1)]\n        dp[0][0] = True\n        for c in range(1,m+1):\n            if p[c-1] == \'*\' and c > 1:\n                dp[0][c] = dp[0][c-2]\n        for r in range(1,n+1):\n            for c in range(1,m+1):\n                if p[c-1] == s[r-1] or p[c-1] == \'.\':\n                    dp[r][c] = dp[r-1][c-1]\n                elif c > 1 and p[c-1] == \'*\':\n                    if  p[c-2] ==\'.\' or s[r-1]==p[c-2]:\n                        dp[r][c] =dp[r][c-2] or dp[r-1][c]\n                    else:\n                        dp[r][c] = dp[r][c-2]\n        return dp[n][m]\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\n* *** Kotlin ***\n\n\n```\n\nclass Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        return isMatchRecursive(s, p)\n    }\n    \n    fun isMatchRecursive(s: String, p: String): Boolean {\n        if (p == "") return s == ""\n        \n        if (p.length >= 2 && p[1] == \'*\' && s.length > 0 && (s[0] == p[0] || p[0] == \'.\')) {\n            return isMatchRecursive(s.substring(1), p) || isMatchRecursive(s, p.substring(2))\n        } else if (p.length >= 2 && p[1] == \'*\') {\n            return isMatchRecursive(s, p.substring(2))\n        }\n        \n        return if (s.length > 0) {\n            if (s[0] == p[0] || p[0] == \'.\') {\n                isMatchRecursive(s.substring(1), p.substring(1))\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n}\n\n```\n\n```\nclass Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        return p.toRegex().matches(s)\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\n* *** Swift ***\n\n\n```\n\nclass Solution {\n    func isMatch(_ s: String, _ p: String) -> Bool {\n        \n        var visit = [[Bool]]()\n        let sLength = s.count, pCount = p.count\n        \n        for _ in 0...sLength + 1 {\n            visit.append([Bool](repeating: false, count: pCount + 1))\n        }\n        \n        visit[sLength][pCount] = true\n        \n        for i in stride(from: sLength, through: 0, by: -1) {\n            for j in stride(from: pCount - 1, through: 0, by: -1) {\n                \n                let arrS = Array(s), arrP = Array(p)\n                \n                let first = i < sLength && (arrS[i] == arrP[j] || arrP[j] == ".")\n                \n                if j + 1 < pCount && arrP[j + 1] == "*" {\n                    visit[i][j] = visit[i][j + 2] || first && visit[i + 1][j]\n                } else {\n                    visit[i][j] = first && visit[i + 1][j + 1]\n                }\n            }\n        }\n        return visit[0][0]\n    }\n}\n\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\n* *** PHP ***\n\n\n```\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        return preg_match("/^{$p}$/", $s);\n    }\n}\n```\n\nHowever, that kinda defeats the point of the exercise, which is to show you can write a regex matcher. So here is my solution.\n```\nclass Solution {\n    \n    const WILDCARD = "*";\n    const ANY_CHAR = ".";\n    \n    /**\n     * @param String $string\n     * @param String $pattern\n     * @return Boolean\n     */\n    function isMatch($string, $pattern) \n    {\n        if (!$pattern) {\n            return !$string;\n        }\n        \n        $matchResult = $string && ($string[0] === $pattern[0] || self::ANY_CHAR === $pattern[0]);\n        $greedyMatch = !empty($pattern[1]) && $pattern[1] == self::WILDCARD;\n\n        if (!$matchResult && !$greedyMatch) {\n            return false;\n        }\n\n        if ($greedyMatch) {\n            return ($matchResult && $this->isMatch(substr($string, 1), $pattern)) || $this->isMatch($string, substr($pattern, 2));\n        }\n        \n        return $matchResult && $this->isMatch(substr($string, 1), substr($pattern, 1));\n    }\n}\n```\n\n```\n```\n\n```\n```\n\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\n* *** C ***\n\n\n```\n\nbool match(char* s, char* p) {\n    return (s[0] == p[0]) || (p[0] == \'.\' && s[0]);\n}\n\nbool isMatch(char * s, char * p){\n    if (!p[0]) return !s[0];\n    if (p[1] == \'*\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\n    if (p[0] == \'.\') return s[0] && isMatch(s+1, p+1);\n    return match(s, p) && isMatch(s+1, p+1);\n}\n\n```\n\n```\n```\n\n```\n```\n\n***"Open your eyes. Expect us." - \uD835\uDCD0\uD835\uDCF7\uD835\uDCF8\uD835\uDCF7\uD835\uDD02\uD835\uDCF6\uD835\uDCF8\uD835\uDCFE\uD835\uDCFC***\n, status: null, voteStatus: 0, voteCount: 13, creationDate: 1659713546, isHidden: null, author: {username: darian-catalin-cucer, isActive: true, nameColor: null, activeBadge: {displayName: Annual Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg2023.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1680878634.png, reputation: 2245}}}, searchMeta: null}, {id: 366219, title: [Python3]dynamic programming, commentCount: 4, topLevelCommentCount: 3, viewCount: 2111, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 696697, content: If dp[i][j] == False, it means s[:i] doesn\'t match p[:j]\nIf dp[i][j] == True, it means s[:i] matches p[:j]\n\'.\' Matches any single character.\n\'*\' Matches zero or more of the preceding element.\ns = "aa"\np = "a*"\nOutput: true\nExplanation: \'*\' means zero or more of the preceding element, \'a\'. Therefore, by repeating \'a\' once, it becomes "aa".\n```\ns = "aab"\np = "c*a*b"\n                 c      *       a      *     b\ndp = [ \n         [True, False, True, False, True, False], \n\t a  [False, False, False, True, True, False], \n\t a  [False, False, False, False, True, False], \n\t b\t[False, False, False, False, False, True]] \n\t\n#  Case 1 p[:j] ==  alphabet or \'.\'\n#  Case 2: p[:j] is \'*\'\n\t# Case 2a: p[:j-1] doesn\'t need a \'*\' to match the substring s[:i]\n\t    #1  p[:j-1] ==s[:i]   dp[i][j] =d[i-1][j]\n\t\t    0  a  *                0   a  a \n        0                      0\n        a        T        ---> a\n        a        T             a         T\n\t\t#2  p[:j-1] == \'.\'      dp[i][j]=dp[i][j-2]\n\t\t    0  a  b  *\n        0  \n        a     T     T          \n        \n\t# Case 2b: p[:j] needs \'*\' to match the substring s[:i]\n```\n```\n # about *:\n case 1: 0 preceding element\n case 2: 1 or more preceding element\n\t\t\t   the preceding element could be a \'.\' or an alpharbet.\n\t\t\t   more proceding element is easy to handle once you use dynamic programming. \n \n \n```\n\n\n\n\n```\nclass Solution:\n    def isMatch(self, s, p):\n        n = len(s)\n        m = len(p)\n        dp = [[False for _ in range (m+1)] for _ in range (n+1)]\n        dp[0][0] = True\n        for c in range(1,m+1):\n            if p[c-1] == \'*\' and c > 1:\n                dp[0][c] = dp[0][c-2]\n        for r in range(1,n+1):\n            for c in range(1,m+1):\n                if p[c-1] == s[r-1] or p[c-1] == \'.\':\n                    dp[r][c] = dp[r-1][c-1]\n                elif c > 1 and p[c-1] == \'*\':\n                    if  p[c-2] ==\'.\' or s[r-1]==p[c-2]:\n                        dp[r][c] =dp[r][c-2] or dp[r-1][c]\n                    else:\n                        dp[r][c] = dp[r][c-2]\n        return dp[n][m]\n```, status: null, voteStatus: 0, voteCount: 12, creationDate: 1566695545, isHidden: null, author: {username: zhanweiting, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/weiting-zhan/avatar_1529194985.png, reputation: 3849}}}, searchMeta: null}, {id: 2532721, title: Dynamic programming | Python, commentCount: 1, topLevelCommentCount: 1, viewCount: 1654, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 4124206, content: Please upvote this post if you find it helpful.\n\n```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        n_s=len(s)\n        n_p=len(p)\n        dp=[[False]*(n_p+1) for _ in range(n_s+1)]\n        dp[0][0]=True\n        \n        \n        #For empty string but the "*" in pattern might return True\n        for i in range(1,n_p+1):\n            if p[i-1]=="*":\n                dp[0][i]=dp[0][i-2]\n        \n        for i in range(1,n_s+1):\n            for j in range(1,n_p+1):\n                #When the character in string matches with the patter or the pattern has \'.\', which accepts any character\n                if s[i-1]==p[j-1] or p[j-1]==\'.\':\n                    dp[i][j]=dp[i-1][j-1]\n                #When the pattern has "*", this shows that we need to check the [j-2] for the character, which can be the string character or \'.\'. In this case we will check the [i-1][j], to check if the character except the current one is True.\n                \n                elif p[j-1]=="*":\n                    dp[i][j]=dp[i][j-2]\n                    if p[j-2]==\'.\' or p[j-2]==s[i-1]:\n                        dp[i][j]=dp[i][j] or dp[i-1][j]\n                    \n            \n        return dp[n_s][n_p]\n```\n, status: null, voteStatus: 0, voteCount: 7, creationDate: 1662353174, isHidden: null, author: {username: ankush_A2U8C, isActive: true, nameColor: null, activeBadge: {displayName: SQL II, icon: https://assets.leetcode.com/static_assets/others/SQL-2.png}, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 29}}}, searchMeta: null}, {id: 3364697, title: one-line python solution, commentCount: 11, topLevelCommentCount: 10, viewCount: 2459, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5217883, content: # Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        return re.match(fr"^{p}$", s) is not None\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1680331004, isHidden: null, author: {username: vinhDev30062002, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1678005962.png, reputation: 6}}}, searchMeta: null}, {id: 3194902, title: dp / python3 / time O(mn) / space O(mn), commentCount: 2, topLevelCommentCount: 1, viewCount: 4923, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 5001892, content: This problem can be solved using dynamic programming. Let dp[i][j] be a boolean indicating whether the first i characters of s match the first j characters of p. We can initialize dp[0][0] = True because an empty string matches an empty pattern.\n\nFor the first row dp[0][j], we need to consider two cases: if p[j-1] is \'*\', we can ignore it and look at dp[0][j-2] (the pattern without the \'*\' and its preceding character), or if p[j-2] matches the empty string, we can look at dp[0][j-1] (the pattern with only the \'*\' and its preceding character).\n\nFor each subsequent cell dp[i][j], we need to consider three cases: if p[j-1] is a regular character and matches s[i-1], then dp[i][j] = dp[i-1][j-1]. If p[j-1] is a \'*\', then we can either ignore the preceding character and look at dp[i][j-2] (the pattern without the \'*\' and its preceding character), or if the preceding character matches s[i-1], we can look at dp[i-1][j] (the pattern with the \'*\' and one more repetition of the preceding character), or if the preceding character does not match s[i-1], we can ignore both the preceding character and the \'*\' and look at dp[i][j-2]. If p[j-1] is a ., then dp[i][j] = dp[i-1][j-1].\n\nThe final answer is dp[m][n], where m and n are the lengths of s and p, respectively.\n\nThe time complexity of this algorithm is O(mn) and the space complexity is O(mn), where m and n are the lengths of s and p, respectively.\n\n# Code\n```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        for j in range(1, n+1):\n            if p[j-1] == \'*\':\n                dp[0][j] = dp[0][j-2]\n            else:\n                dp[0][j] = j > 1 and p[j-2] == \'*\' and dp[0][j-2]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == s[i-1] or p[j-1] == \'.\':\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == \'*\':\n                    dp[i][j] = dp[i][j-2] or (p[j-2] == s[i-1] or p[j-2] == \'.\') and dp[i-1][j]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n```, status: null, voteStatus: 0, voteCount: 6, creationDate: 1676578713, isHidden: null, author: {username: pussyBoy, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/default_avatar.jpg, reputation: 6}}}, searchMeta: null}, {id: 4815724, title: 113.2 (Approach 1 : Dynamic Programming) | O( n * m)âœ… | Python & C++(Step by step explanation)âœ…, commentCount: 0, topLevelCommentCount: 0, viewCount: 795, pinned: false, isFavorite: false, solutionTags: [{name: C++, slug: cpp}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 7101387, content: # Intuition\nThe problem can be solved using dynamic programming. We can create a 2D table where `memory[i][j]` represents whether the substring of `s` starting from index `i` and the pattern `p` starting from index `j` match.\n\n# Approach\n1. **Initialization**:\n   - We initialize a 2D array `memory` with dimensions `(len(s) + 1) x (len(p) + 1)`. This is done to handle the case where either `s` or `p` is empty.\n   - We set `memory[len(s)][len(p)]` to `True` because an empty substring of `s` and an empty pattern `p` match.\n\n2. **Iteration**:\n   - We iterate through the substrings of `s` and patterns `p` from the end towards the beginning using two nested loops.\n   - For each index `i` and `j`, we check if the current characters match or if the pattern character is `\'.\'`. This is indicated by the variable `match`.\n   - If the next character in the pattern is `\'*\'`, we handle the \'*\' wildcard character by exploring both options: matching zero occurrences and matching the current character. This is achieved by updating the `memory[i][j]` value accordingly.\n   - If the next character is not `\'*\'`, we simply check if the current characters match and update the `memory[i][j]` value accordingly.\n\n3. **Return**:\n   - After the iteration is complete, we return `memory[0][0]`, which represents whether the entire `s` matches the entire `p`.\n\nThe overall approach is dynamic programming, where we fill the `memory` table iteratively based on previously computed values. We utilize this table to store intermediate results of subproblems, which helps in avoiding redundant computations and improves the efficiency of the solution. The iteration is done from the end towards the beginning to ensure that we have access to the necessary subproblem solutions when computing the current cell values.\n\n# Complexity\n- Time complexity: \\(O(m * n)\\), where \\(m\\) is the length of string `s` and \\(n\\) is the length of pattern `p`. We iterate through each cell in the `memory` table once.\n- Space complexity: \\(O(m * n)\\), where \\(m\\) is the length of string `s` and \\(n\\) is the length of pattern `p`. We use a 2D array `memory` to store the results of subproblems. Each cell in the table requires constant space. \n\n# Code(Python)\n```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Initialize a 2D array `memory` with dimensions (len(s) + 1) x (len(p) + 1)\n        memory = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        # Set memory[len(s)][len(p)] to True since an empty substring of s and an empty pattern p match\n        memory[len(s)][len(p)] = True\n\n        # Iterate through the substrings of s and patterns p from the end towards the beginning\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                # Check if the current characters match or if the pattern character is \'.\'\n                match = i < len(s) and (s[i] == p[j] or p[j] == ".")\n\n                if (j + 1) < len(p) and p[j + 1] == "*":\n                    # If the next character in the pattern is \'*\', handle the \'*\' wildcard character\n                    memory[i][j] = memory[i][j + 2]\n                    if match:\n                        memory[i][j] = memory[i + 1][j] or memory[i][j]\n                elif match:\n                    # If the characters match, move to the next characters in both strings\n                    memory[i][j] = memory[i + 1][j + 1]\n\n        # Return memory[0][0], which represents whether the entire s matches the entire p\n        return memory[0][0]\n```\n\n# Code(C++)\n```c++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        // Initialize a 2D vector memory with dimensions (s.size() + 1) x (p.size() + 1)\n        vector<vector<bool>> memory(s.size() + 1, vector<bool>(p.size() + 1, false));\n        // Set memory[s.size()][p.size()] to true since an empty substring of s and an empty pattern p match\n        memory[s.size()][p.size()] = true;\n\n        // Iterate through the substrings of s and patterns p from the end towards the beginning\n        for (int i = s.size(); i >= 0; i--) {\n            for (int j = p.size() - 1; j >= 0; j--) {\n                // Check if the current characters match or if the pattern character is \'.\'\n                bool match = i < s.size() && (s[i] == p[j] || p[j] == \'.\');\n\n                if (j + 1 < p.size() && p[j + 1] == \'*\') {\n                    // If the next character in the pattern is \'*\', handle the \'*\' wildcard character\n                    memory[i][j] = memory[i][j + 2];\n                    if (match) {\n                        memory[i][j] = memory[i + 1][j] || memory[i][j];\n                    }\n                } else if (match) {\n                    // If the characters match, move to the next characters in both strings\n                    memory[i][j] = memory[i + 1][j + 1];\n                }\n            }\n        }\n\n        // Return memory[0][0], which represents whether the entire s matches the entire p\n        return memory[0][0];\n    }\n};\n```\n\n\n# Please upvote the solution if you understood it.\n![1_3vhNKl1AW3wdbkTshO9ryQ.jpg](https://assets.leetcode.com/users/images/0161dd3b-ad9f-4cf6-8c43-49c2e670cc21_1699210823.334661.jpeg)\n\n, status: null, voteStatus: 0, voteCount: 5, creationDate: 1709457643, isHidden: null, author: {username: monster0Freason, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1696336529.png, reputation: 1222}}}, searchMeta: null}, {id: 4815625, title: 113.1 (Approach 1 : recursive) | O( n)âœ… | Python & C++(Step by step explanation)âœ…, commentCount: 0, topLevelCommentCount: 0, viewCount: 450, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}, {name: Recursion, slug: recursion}, {name: Memoization, slug: memoization}], post: {id: 7101263, content: # Intuition\nThe problem can be approached using dynamic programming, where we recursively check if the current characters of the string and pattern match, considering cases for the \'*\' wildcard character. We use memoization to avoid redundant computations and improve the efficiency of the solution.\n\n# Approach\nWe can solve this problem using a depth-first search (DFS) approach with memoization. We define a recursive function `dfs(i, j)` that checks if the substring of `s` starting from index `i` and the pattern `p` starting from index `j` match. We consider different cases:\n- If the current characters match or the pattern character is \'.\', we move to the next character in both `s` and `p`.\n- If the next character in `p` is \'*\', we have two options:\n  - Match zero occurrences of the preceding character in `p`, moving to `dfs(i, j + 2)`.\n  - If the current characters match, we move to the next character in `s` and continue matching with the same pattern in `p`.\n  - ![image.png](https://assets.leetcode.com/users/images/b33df742-f7cd-4084-bbb6-6906ff46fd56_1709455718.8010354.png)\n\n- If none of the above cases match, the strings don\'t match.\n\nWe memoize the results of subproblems to avoid redundant computations.\n![image.png](https://assets.leetcode.com/users/images/2fd41334-43fd-4c24-8a38-c34a69a9339e_1709456257.6265855.png)\n\n\n# Complexity\n- Time complexity: \\(O(m * n)\\), where \\(m\\) is the length of string `s` and \\(n\\) is the length of pattern `p`. In the worst case, we might have to explore all possible combinations of matching characters, which can take \\(O(m * n)\\) time.\n- Space complexity: \\(O(m * n)\\), where \\(m\\) is the length of string `s` and \\(n\\) is the length of pattern `p`. We use a memoization table to store the results of subproblems, which can take \\(O(m \\times n)\\) space in the worst case.\n\n# Code(Python)\n```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        memory = {}  # Memoization dictionary to store computed results\n        \n        def dfs(i, j):\n            # Check if the result for the current indices is already memoized\n            if (i, j) in memory:\n                return memory[(i, j)]\n            \n            # Base cases\n            if i >= len(s) and j >= len(p):\n                return True\n            if j >= len(p):\n                return False\n\n            # Check if the current characters match or if the pattern character is \'.\'\n            same = i < len(s) and (s[i] == p[j] or p[j] == ".")\n            \n            # If the next character in pattern is \'*\', handle the \'*\' wildcard character\n            if (j + 1) < len(p) and p[j + 1] == "*":\n                # Explore both options: matching zero occurrences and matching current character\n                memory[(i, j)] = dfs(i, j + 2) or (same and dfs(i + 1, j))\n                return memory[(i, j)]\n            \n            # If the characters match, move to the next characters in both strings\n            if same:\n                memory[(i, j)] = dfs(i + 1, j + 1)\n                return memory[(i, j)]\n            \n            # If none of the above cases match, return False\n            memory[(i, j)] = False\n            return False\n\n        # Start the DFS from the beginning of both strings\n        return dfs(0, 0)\n```\n\n# Code(C++)\n```c++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        // Memoization map to store computed results\n        map<pair<int, int>, bool> memory;\n\n        return dfs(s, p, 0, 0, memory);\n    }\n\nprivate:\n    bool dfs(string& s, string& p, int i, int j, map<pair<int, int>, bool>& memory) {\n        // Check if the result for the current indices is already memoized\n        if (memory.find({i, j}) != memory.end()) {\n            return memory[{i, j}];\n        }\n\n        // Base cases\n        if (i >= s.size() && j >= p.size()) {\n            return true;\n        }\n        if (j >= p.size()) {\n            return false;\n        }\n\n        // Check if the current characters match or if the pattern character is \'.\'\n        bool same = i < s.size() && (s[i] == p[j] || p[j] == \'.\');\n\n        // If the next character in pattern is \'*\', handle the \'*\' wildcard character\n        if (j + 1 < p.size() && p[j + 1] == \'*\') {\n            // Explore both options: matching zero occurrences and matching current character\n            memory[{i, j}] = dfs(s, p, i, j + 2, memory) || (same && dfs(s, p, i + 1, j, memory));\n            return memory[{i, j}];\n        }\n\n        // If the characters match, move to the next characters in both strings\n        if (same) {\n            memory[{i, j}] = dfs(s, p, i + 1, j + 1, memory);\n            return memory[{i, j}];\n        }\n\n        // If none of the above cases match, return False\n        memory[{i, j}] = false;\n        return memory[{i, j}];\n    }\n};\n```\n\n\n# Please upvote the solution if you understood it.\n![1_3vhNKl1AW3wdbkTshO9ryQ.jpg](https://assets.leetcode.com/users/images/0161dd3b-ad9f-4cf6-8c43-49c2e670cc21_1699210823.334661.jpeg)\n, status: null, voteStatus: 0, voteCount: 5, creationDate: 1709456325, isHidden: null, author: {username: monster0Freason, isActive: true, nameColor: null, activeBadge: {displayName: 50 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg50.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1696336529.png, reputation: 1222}}}, searchMeta: null}, {id: 528767, title: [Python3] 64 ms  1-Liner  RE MODULE, commentCount: 4, topLevelCommentCount: 3, viewCount: 388, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}], post: {id: 997418, content: ```\nimport re\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        return True if re.fullmatch(p,s) else False\n```, status: null, voteStatus: 0, voteCount: 4, creationDate: 1583335815, isHidden: null, author: {username: bachana3435, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/bachana3435/avatar_1579788868.png, reputation: 4}}}, searchMeta: null}, {id: 2392690, title: Python 95% faster, commentCount: 1, topLevelCommentCount: 1, viewCount: 1873, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 3926596, content: ```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \n        dp = {}\n        def dfs(i,j):\n            if (i,j) in dp:\n                return dp[(i,j)]\n            \n            if i>=len(s) and j>=len(p):\n                return True\n            if i<= len(s) and j>= len(p):\n                return False\n            match  =  i< len(s) and ((s[i] == p[j]) or (p[j] == \'.\'))\n            \n            if j < len(p)-1 and  p[j+1] == \'*\':\n                dp[(i,j)] = ( dfs(i,j+2) # dont use *  \n                    or (match and dfs(i+1,j)) )\n                return dp[(i,j)]\n            if match:\n                dp[(i,j)] = dfs(i+1,j+1) \n                return dp[(i,j)]\n        \n        return dfs(0,0)\n```, status: null, voteStatus: 0, voteCount: 3, creationDate: 1659869163, isHidden: null, author: {username: Abhi_009, isActive: true, nameColor: null, activeBadge: {displayName: SQL I, icon: https://assets.leetcode.com/static_assets/others/SQLI.png}, profile: {userAvatar: https://assets.leetcode.com/users/avatars/avatar_1702811257.png, reputation: 43}}}, searchMeta: null}, {id: 2199084, title: python 3 | memoization, commentCount: 0, topLevelCommentCount: 0, viewCount: 989, pinned: false, isFavorite: false, solutionTags: [{name: Python, slug: python}, {name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 3658650, content: ```\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        \n        @lru_cache(None)\n        def helper(i, j):\n            if j == n:\n                return i == m\n            \n            match = i != m and (p[j] == \'.\' or s[i] == p[j])\n            if j == n - 1 or p[j + 1] != \'*\':\n                return match and helper(i + 1, j + 1)\n            \n            return helper(i, j + 2) or (match and helper(i + 1, j))\n        \n        return helper(0, 0), status: null, voteStatus: 0, voteCount: 3, creationDate: 1656224003, isHidden: null, author: {username: derek-y, isActive: true, nameColor: null, activeBadge: {displayName: 100 Days Badge 2023, icon: https://assets.leetcode.com/static_assets/marketing/lg100.png}, profile: {userAvatar: https://assets.leetcode.com/users/derekyoungman65/avatar_1632234502.png, reputation: 384}}}, searchMeta: null}, {id: 336345, title: Python simple DP, commentCount: 3, topLevelCommentCount: 1, viewCount: 1572, pinned: false, isFavorite: false, solutionTags: [{name: Python3, slug: python3}, {name: Dynamic Programming, slug: dynamic-programming}], post: {id: 642960, content: string s  use index i and  string p use index j\ndp[i][j] means the match status between p[:i] and s[:j]\ndp[0][0] means the match status of two empty strings, and dp[1][1] means the match status of p[0] and s[0]. \nTherefore, when refering to the i-th and the j-th characters of p and s for updating dp[i][j], we use p[i - 1] and s[j - 1].\n```python\n    # dp\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False]*(len(p)+1) for i in range(len(s)+1)]\n\t\t# Update the corner case of matching two empty strings. egg s=\'a\' p=\'a\', so s[0] = p[0]  ==> dp[1][1] == dp[0][0], we can see dp[0][0] need to set True\n        dp[0][0] = True\n\t\t# Update the corner case of when s is an empty string but p is not.\n        # Since each \'*\' can eliminate the charter before it, the dp table is vertically updated by the one before previous\n        for j in range(2,len(p)+1):\n            if p[j-1] == \'*\':  \n                dp[0][j] = dp[0][j-2]\n        \n        for i in range(1,len(s)+1):\n            for j in range(1,len(p)+1):\n                dp[i][j] = (p[j-1] in [s[i-1],\'.\']  and dp[i-1][j-1]) or (p[j-1] == \'*\' and ((p[j-2] in [s[i-1],\'.\'] and dp[i-1][j] ) or (dp[i][j-2]))) \n        return dp[len(s)][len(p)]\n\n```\n```python\ndp[i][j] = (p[j-1] in [s[i-1],\'.\']  and dp[i-1][j-1]) or (p[j-1] == \'*\' and ((p[j-2] in [s[i-1],\'.\'] and dp[i-1][j] ) or (dp[i][j-2]))) \n```\nHere\'s the explanation to this code sentence\n```python\nif p[j-1] in [s[i-1],\'.\']:\n\t# first condition p[j-1] == s[i-1] or p[j-1] == \'.\' \n\t# egg. s=\'a\' p =\'.\' or \'a\'\n\tdp[i][j] = dp[i-1][j-1]\nif p[j-1] == \'*\':\n\t# second condition  p[j-1] == \'*\' , \'*\' means zero\n\t# egg. s=\'b\' p =\'ba*\'\n\tdp[i][j] = dp[i][j-2]\n\tif p[j-2] in [s[i-1],\'.\']:\n\t\t# last condition  p[j-1] == \'*\', \'*\' means more of the preceding element\n\t\t# egg. s=\'aa\' p =\'a*\'\n\t\tdp[i][j] = dp[i][j] or dp[i-1][j]\n```\n[Similar problem: 44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/discuss/338080/Python-Simple-DP), status: null, voteStatus: 0, voteCount: 3, creationDate: 1563261888, isHidden: null, author: {username: gyh75520, isActive: true, nameColor: null, activeBadge: null, profile: {userAvatar: https://assets.leetcode.com/users/gyh75520/avatar_1563708731.png, reputation: 334}}}, searchMeta: null}]}}}]
Positional arguments: []
Connection closed
